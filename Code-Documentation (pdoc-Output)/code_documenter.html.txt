<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>code_documenter API documentation</title>
<meta name="description" content="Created on: Fri, 2023-12-29 (00:45:39) …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>code_documenter</code></h1>
</header>
<section id="section-intro">
<p>Created on: Fri, 2023-12-29 (00:45:39)</p>
<p>@author: Matthias Kader</p>
<p>Für Ziel und Ablauf des Scriptes siehe MArkdown im Verzeichnis ../Tests/Programmablauf.html</p>
<h3 id="fertig-implementiert">Fertig implementiert:</h3>
<p>• Implementierung Inhaltsverzeichnis / Index</p>
<p>• Gesamtlayout inkl. Titel, Zwischenüberschriften für einzelne Sections</p>
<p>• Einbindung vom Programmkopf-Docstring</p>
<p>• Implementierung von References-Durchsuchungen</p>
<p>• Implementierung eines Exportes zu HTML</p>
<p>• Einbindung organisatorischer Daten bzgl. des zu dokumentierenden Codes und des verwendeten Skripts zum Dokumentieren</p>
<h3 id="todo-groere-todos">TODO: Größere TODOS:</h3>
<p>• Call Sequenz / Calling Sequence:</p>
<p>Schön (Ausblick) wäre auch ein weiterer Unterpunkt pro Prozedur, in der die Aufrufabfolge hervorgeht.
Idee ist etwas wie die Aufrufebenen-Auflistung beim Noten-Converter-Programm, d.h. ausgehend von einer Prozedur soll eine Liste stehen der Aufrufe von weiteren Prozeduren die aufgerufen werden (und die in diesem Dokument auch dokumentiert werden&hellip; also keine Builtins o.ä.). Im Idealfall kann jeder Punkt dieser Liste wiederum erweitert/expanded werden, darin ist dann wiederum die Liste von DIESER AUFGERUFENEN Funktion drin usw&hellip; Rekursiv. Jede Methode, die einmal so dokumentiert wurde kann weiter verwendet werden per Direktzugriff....</p>
<h3 id="ausblick-fur-spater-und-in-schon">AUSBLICK für später und in schön:</h3>
<p>• Index an der Seite wie eine NavBar zum einzelnd scrollen</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#39;&#39;&#39;
Created on: Fri, 2023-12-29 (00:45:39)


@author: Matthias Kader


Für Ziel und Ablauf des Scriptes siehe MArkdown im Verzeichnis ../Tests/Programmablauf.html




### Fertig implementiert:

• Implementierung Inhaltsverzeichnis / Index

• Gesamtlayout inkl. Titel, Zwischenüberschriften für einzelne Sections

• Einbindung vom Programmkopf-Docstring

• Implementierung von References-Durchsuchungen

• Implementierung eines Exportes zu HTML



• Einbindung organisatorischer Daten bzgl. des zu dokumentierenden Codes und des verwendeten Skripts zum Dokumentieren



### TODO: Größere TODOS:



• Call Sequenz / Calling Sequence:

Schön (Ausblick) wäre auch ein weiterer Unterpunkt pro Prozedur, in der die Aufrufabfolge hervorgeht.
Idee ist etwas wie die Aufrufebenen-Auflistung beim Noten-Converter-Programm, d.h. ausgehend von einer Prozedur soll eine Liste stehen der Aufrufe von weiteren Prozeduren die aufgerufen werden (und die in diesem Dokument auch dokumentiert werden... also keine Builtins o.ä.). Im Idealfall kann jeder Punkt dieser Liste wiederum erweitert/expanded werden, darin ist dann wiederum die Liste von DIESER AUFGERUFENEN Funktion drin usw... Rekursiv. Jede Methode, die einmal so dokumentiert wurde kann weiter verwendet werden per Direktzugriff....



### AUSBLICK für später und in schön:

• Index an der Seite wie eine NavBar zum einzelnd scrollen


&#39;&#39;&#39;














from datetime import datetime
import os
import re

import markdown

import subprocess
import gitinfo






# =============================================================================
#### GLOBALS: ####
# =============================================================================

DEBUG = 1

CONVERT_TO_HTML = 1





def db(*args):
    &#34;&#34;&#34;
    Schleust zum printen durch - nur zum Debuggen
    &#34;&#34;&#34;
    if DEBUG == False:
        return
    
    print(&#34;__DEBUG_PRINT__\n&#34;)
    for _ in args:
        print(_)





# =============================================================================
#### Workaround: Verwendung von MetaClasses: Metaklassen für Direktaufrufe / implizite Aufrufe einer Classmethod direkt nach Implementierung einer Klasse ####
# =============================================================================


# =============================================================================
#### # WIEDERHOLFUNKTION-KANDIDAT!!! ####
# =============================================================================
class AutoCallMeta(type):
    &#34;&#34;&#34;
    Sofern diese Klasse als metaclass für eine andere Klasse verwendet wird, wird die unten aufgeführte Klassenmethode direkt nach Definition ohne ein zusätzlichen, expliziten Aufruf automatisch aufgerufen.

    Dazu muss nur der Name der aufzurufenden Methode in der Klassenvariable &#39;class_name_to_call_implicit&#39; parametrisiert werden.
    &#34;&#34;&#34;    
    class_name_to_call_implicit = &#34;initialize_class&#34; # NUR HIER ZU PARAMETRISIEREN!
    
    def __init__(cls, name, bases, attrs):
        super().__init__(name, bases, attrs)
        func_name  = AutoCallMeta.class_name_to_call_implicit

        # Aufruf der relevanten Methode, sofern sie vorhanden ist:
        if hasattr(cls, func_name):
            func = getattr(cls, func_name)
            # Aufruf:
            func()














# =============================================================================
#### CLASSES: ####
# =============================================================================






class MetaData(metaclass=AutoCallMeta):
    &#34;&#34;&#34;
    In dieser Klasse werden hauptsächlich Daten gespeichert, die später als Art MetaDaten angesehen werden können.
    Der Parent-class / metaclass sorgt dafür, dass direkt nach Implementierung dieser (gewöhnlichen) Klasse eine in der metaclass parametrisierte Methode aufgerufen wird.
    Somit ist kein expliziter Aufruf der Klassenmethode MetaData.initialize_class erforderlich, da dies über die metaclass erledigt wird.

    # TODO: Die Klasse ist noch nicht fertig.

    Zu den hierin gespeicherten Daten gehören z. B.:

    - Dieses Dokumentations-Tool-Script
        - Versionsinformationen, basierend auf dem letzten Git-Commit
        - TODO: Versionsnummer dieses Scriptes...
    - Das zu dokumentierende Modul
        - Dateipfad
        - Dateiname
        - Datum der letzten Speicherung / Änderung
    - Aktuellen Zeitstempel zur Angabe des Zeitpunktes der Dokumentation
      
    &#34;&#34;&#34;


    __input_path:str = None
    __output_dir:str = None


    @classmethod
    def get_input_path(cls) -&gt; str:
        return cls.__input_path
    
    
    @classmethod
    def get_input_filename(cls) -&gt; str:
        return cls.__input_filename
    
    
    
    @classmethod
    def get_output_filename(cls) -&gt; str:
        return cls.__output_filename
    
    

    @staticmethod
    def get_last_modified_timestamp(file_path) -&gt; str:
        # Den Zeitstempel der letzten Änderung der Datei auslesen
        timestamp = os.path.getmtime(file_path)
        
        # Den Zeitstempel in ein lesbares Datum umwandeln
        last_modified_datetime = datetime.fromtimestamp(timestamp)
        
        # Das Datum im gewünschten Format ausgeben
        formatted_date = last_modified_datetime.strftime(&#39;%Y-%m-%d %H:%M&#39;)
        
        return formatted_date





    @classmethod
    def extract_date_of_change(cls):
        &#34;&#34;&#34;
        Liesst das letzte Aenderungsdatum der Input-Datei aus und speichert diese in der Klassenvariable cls.input_file_date_of_change
        &#34;&#34;&#34;

        date_of_change = cls.get_last_modified_timestamp(cls.__input_path)
        cls.input_file__date_of_change = date_of_change






    @classmethod
    def set_input_path(cls, input_path:str=None):
        &#34;&#34;&#34;
        Prüft den optional übergebenen Pfad, ob er existiert und dort eine .bas Datei vorliegt.
        Ist dies nicht der Fall, oder wird kein Pfad übergeben, wird per Input ein neuer Pfad abgefragt. 
        Bis zu einem gültigen Pfad wird die Methode rekursiv aufgerufen.
        Bislang gibt es noch keine Möglichkeit für den Nutzer, die Eingabe abzubrechen (außer Programmabbruch...)

        Args:
            input_path (str, optional): Dateipfad zur .bas-Datei, die dokumenteirt werden soll - als Foreward-Slash und ohne Anführungszeichen. Defaults to None.

        &#34;&#34;&#34;

        if input_path != None:
            if os.path.isfile(input_path):
                if input_path.endswith(&#34;.bas&#34;):
                    cls.__input_path = input_path
                    cls.extract_date_of_change()
                    return
                
        neuer_input = input(&#34;!!! FEHLER !!! Die Angegebene Datei ist keine .bas Datei! Bitte einen gueltigen Pfad zur entsprechenden Datei eingeben (Foreward-Slashes! ohne Anfuehrungszeichen)\n&gt; Ihre Eingabe: &#34;)

        cls.set_input_path(neuer_input)


    @classmethod
    def set_output_dir(cls, output_dir:str=None):
        &#34;&#34;&#34;
        Prüft den optional übergebenen Pfad, ob er existiert und ob dies ein Verzeichnis ist
        Ist dies nicht der Fall, oder wird kein Pfad übergeben, wird per Input ein neuer Pfad abgefragt. 
        Bis zu einem gültigen Pfad wird die Methode rekursiv aufgerufen.
        Bislang gibt es noch keine Möglichkeit für den Nutzer, die Eingabe abzubrechen (außer Programmabbruch...)

        Args:
            output_dir (str, optional): Dateipfad zum Ordner, in dem die generierten Output-Dateien exportiert werden sollen - als Foreward-Slash und ohne Anführungszeichen. Defaults to None.

        &#34;&#34;&#34;

        if output_dir != None:
            if os.path.isdir(output_dir):
                cls.__output_dir = output_dir
                return
        neuer_input = input(&#34;!!! FEHLER !!! Der  angegebene Pfad ist kein gueltiges Verzeichnis. Bitte einen gueltigen Pfad fuer den Export der Output-Dateien  eingeben (Foreward-Slashes! ohne Anfuehrungszeichen)\n&gt; Ihre Eingabe: &#34;)

        cls.set_output_dir(neuer_input)



    # OBSOLET: nicht erforderlich - zur Vorbeugung von Verwendchslung daher auskommenteirt:
    # @classmethod
    # def get_output_dir(cls) -&gt; str:
    #     return cls.__output_dir
    
    


    @staticmethod
    def get_count_of_commits():
        &#34;&#34;&#34;
        ### ACHTUNG: Nicht funktional!!!
        &#34;&#34;&#34;


        cmd = &#34;git rev-list --count HEAD&#34;
        return_ =  subprocess.run(cmd)
        
        db(return_)

        db(str(return_).split(&#34; &#34;)[0])
        # return str(return_).split(&#34; &#34;)[0]
        return str(return_)



    @classmethod
    def extract_git_info(cls):
        info:dict = gitinfo.get_git_info()

        # Übernehme die Infos aus git in die Klasse:
        for key, value in info.items():

            # if not hasattr(cls, key):
            #     # Wenn nicht, erstelle es und weise den Wert zu
            #     setattr(cls, key, value)

            attr_name =  f&#34;documenter_version__{key}&#34;

            setattr(cls, attr_name, value)
            db(getattr(cls, attr_name))




            # bold = &#34;**&#34; if key in keys_bold else &#34;&#34;
            # indent_message = &#34;** \n&gt; **&#34; if key == &#34;message&#34; else &#34; &#34;

            # cls.gitinfo = cls.gitinfo + &#34;- &#34; + bold + key + &#34;:&#34; + indent_message + value + bold  + &#34;\n&#34;





    # @classmethod
    # def git_info_to_str(cls):

    #     info:dict = gitinfo.get_git_info()
    #     cls.gitinfo = &#34;## Infos zum Script, welches für die Erstellung dieser Dokumentation verwendet wurde:\n\n&#34;

    #     keys_bold = [&#34;commit&#34;, &#34;message&#34;, &#34;refs&#34;, &#34;author_date&#34;]


    #     for key, value in info.items():
    #         bold = &#34;**&#34; if key in keys_bold else &#34;&#34;
    #         indent_message = &#34;** \n&gt; **&#34; if key == &#34;message&#34; else &#34; &#34;

    #         cls.gitinfo = cls.gitinfo + &#34;- &#34; + bold + key + &#34;:&#34; + indent_message + value + bold  + &#34;\n&#34;





    @classmethod
    def save_current_timestamp(cls):

        # Aktuelles Datum und Uhrzeit
        current_datetime = datetime.now()

        # Wandele das Datum und die Uhrzeit in einen Zeitstempel um
        current_timestamp = int(current_datetime.timestamp())

        db(f&#34;Current Timestamp: {current_timestamp}&#34;)

        current_datetime.strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)

        cls.date_of_process = current_datetime.strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)







    @classmethod
    def make_output_filename(cls):
        
        cls.__input_filename = os.path.basename(cls.__input_path)
        cls.__output_filename = cls.__input_filename + &#34; - Dokumentation&#34;




    @classmethod
    def get_output_path(cls, extension=&#34;.md&#34;) -&gt; str:
        &#34;&#34;&#34;
        Gibt den gesamten Pfad fuer die neu zu generierende Output-Datei zurueck, inkl. Dateierweiterung.

        Args:
            extension (str, optional): Dateiendung der Output-Dtaei. Defaults to &#34;.md&#34;. Modifizierbar z. B. zu .html oder .txt

        Returns:
            str : Dateipfad
        &#34;&#34;&#34;

        path =  os.path.join(cls.__output_dir, cls.__output_filename + extension)
        return path
    
    




    @classmethod
    def initialize_class(cls):
        &#34;&#34;&#34;
        Diese Methode wird implizit direkt nach Implementierung dieser Klasse aufgerufen.
        Somit muss sie nicht mehr von außen aufgerufen werden.
        Sie initialisiert alle Attribute mit ihren WErten.
        &#34;&#34;&#34;




        # HACK: path for Source-vba-code
        input_file_path = &#34;input_data/beispiel_modul.bas&#34;
        # input_file_path = &#34;input_data/beispiel_modul1.bas&#34;
        # input_file_path = &#34;input_data/beispiel_modul1.bas&#34;
        
        cls.set_input_path(input_file_path)






        # HACK: DIR FOR OAUTPUT
        # Schreibe die Datei erst in eine Markdown-Datei:
        output_dir = &#34;output_data&#34;
        cls.set_output_dir(output_dir)










        # cls.git_info_to_str()
        cls.extract_git_info()
        # cls.count_of_commits = cls.get_count_of_commits()




        cls.save_current_timestamp()


        cls.make_output_filename()








class Procedure():
    &#34;&#34;&#34;
    Allgemeine Klasse zur Bereitstellung von Inhalten, die fuer alle Prozeduren (Subs und Functions) erforderlich sind. Dazu gehoert:
        
        • Definition des Dateipfades fuer Template, in die der extrahierte Text übernommen wird
        
        • Flag-Variable, ob nach Beginn oder Ende der Prozedur gesucht wird
        
        • Regex-Muster als String für den Beginn und das Ende einer Prozedur - wobei innerhalb dieses Strings der Platzhalter für die Prozedurart in den Subklassen noch ersetzt werden muss. Ebenfalls
    &#34;&#34;&#34;

    # TEMPLATE = &#34;templates/prozedur.md&#34;
    # HACK: für weiterentwicklung bzgl abruffolge:
    TEMPLATE = &#34;templates/prozedur_dev.md&#34;


    search_for_begin = True # initialer wErt




    # TODO: Das wäre eig. schöner wenn sie private vars sind...

    # Das folgenden Regex-Muster berücksichtigt nicht das Auskommentieren dieser Zeile
    regex_begin_pattern = r&#34;&#34;&#34;.*     # Start mit beliebigen Zeichen
                        (?:Private|Public|Friend)?
                        (?:PLACEHOLDER_PROCEDURE_TYPE)    # Beinhaltet das KEyword
                        \s+        # mind. 1 bis n Leerzeichen
                        (\w+)        # mind. 1 bis n Wortzeichen
                        \(         # Geöffnete Klammer
                        &#34;&#34;&#34;



    # BUGFIX: Besonders beim Beispielmmodul 1 wird zu früh beendet! Neue Regex &gt; V. 0.1.2
    regex_end_pattern = r&#34;&#34;&#34;.*?     # Start mit beliebigen Zeichen
                        (?:End)    # Beinhaltet das KEyword
                        \s+        # mind. 1 bis n Leerzeichen
                        (?:PLACEHOLDER_PROCEDURE_TYPE)    # Beinhaltet das KEyword
                        \s+         # mind. 1 bis n Leerzeichen
                        .*&#34;&#34;&#34;
    


    &#39;&#39;&#39;
    # ALT: Bis Version 0.1.1:
    regex_end_pattern = r&#34;&#34;&#34;.*?     # Start mit beliebigen Zeichen
                        (?:End)    # Beinhaltet das KEyword
                        \s+        # mind. 1 bis n Leerzeichen
                        (?:PLACEHOLDER_PROCEDURE_TYPE)?    # Beinhaltet das KEyword
                        .*&#34;&#34;&#34;
    &#39;&#39;&#39;






    # Zum späteren Prüfen bzgl. Auskommentierung extra Regex:
    __regex_ausschlus_kommentar_pattern = r&#34;&#34;&#34;&#39;    # KommentarApostroph
                                        .?       # Beliebiges Zeichen
                                        &#34;&#34;&#34;

    # Hier ist keine weitere Konkretisierung durch Subklassen erforderlich, daher direkt kompiliert:
    regex_ausschluss_kommentar = re.compile(__regex_ausschlus_kommentar_pattern, re.VERBOSE | re.IGNORECASE)



    @classmethod
    def initialize_input_code(cls, input_path:str):
        &#34;&#34;&#34;
        Liesst den zu analysierenden und zu dokumentierenden Input-Quellcode ein und speichert ihn innerhalb dder Superklasse als immer verfuegbare Liste einzelner Zeileninhalte ab.

        ### TODO: Später sollte hier auch noch eine einfache GUI erstellt werden zur Auswahl!
        ggf. sollte diese GUI aber losgelöst von dieser Klasse sein (Wiederholfunktion!). Daher als Kapselung mit übergebenen input-path!
        &#34;&#34;&#34;

        with open(input_path, &#34;r&#34;) as file:
            cls.raw_source_code = file.readlines()






    @classmethod
    def detail_analyse_procedures(cls):
        &#34;&#34;&#34;
        Detail-Auswertung aller zuvor identifizierten Prozeduren (unabhängig ihrer Art).
        Die einzelnen Komponenten werden dabei in Objekte der Subklassen gespeichert
        &#34;&#34;&#34;

        for procedure_type_cls in [Sub, Function]:

            for line_begin, line_end in procedure_type_cls.matches_line_ixs:

                # db(line_begin, line_end)
                
                # TODO: Bug ausmisten!
                # BUG: sofern nach ein End {procedure_type} in der allerletzten Zeile des Quellcodes steht undn KEINE LEERZEILE FOLGT, isst line_end = None . Das raised einen TypeError: unsupported operand type(s) for +: &#39;NoneType&#39; and &#39;int&#39;
                lines = cls.raw_source_code[line_begin:line_end + 1]

                sub = procedure_type_cls(tuple(lines))



    @classmethod
    # def identify_procedures(cls, list_of_code_lines:list[str]):
    def identify_procedures(cls):
        &#34;&#34;&#34;
        Identifizieren  aller Prozeduren (Methoden und Funktione) auf Klassenebene und Speichern der Zeilennummern der Deklarations- und End-Zeilen innerhalb der jeweiligen Klassenvariablen.

        Durchsucht werden die einzelnen Strings der als Liste übergebenen Zeileninhalte des Quellcodes.

        Args:
            raws (list[str]): Liste mit einem Eintrag pro Zeile des Quellcodes

        &#34;&#34;&#34;

        for ix, text in enumerate(cls.raw_source_code):

            # db(text)

            if cls.search_for_begin:

                if Sub.check_and_get_match(text, ix):
                    current_procedure_type_cls = Sub
                    continue

                if Function.check_and_get_match(text, ix):
                    current_procedure_type_cls = Function


            else:
                # Suche nach dem entsprechend passenden Ende
                current_procedure_type_cls.search_end_of_procedure(text, ix)



            













    @classmethod
    def check_and_get_match(cls, text:str, line_no:int) -&gt; bool:
        &#34;&#34;&#34;
        Prüft eine einzelne Zeile eines Codes (den übergebenen text), ob es sich um ein Match einer Deklarationszeile handelt, und auch, ob diese NICHT-auskommentiert ist. Sofern dies der Fall ist, wird dieses MAtch in die Liste der MAtsches aufgenommen.

        Args:
            text (str): Zu prüfender Text ausschnitt
            line_no (int) : Zeilennummer der Liste an gesamt zu untersuchenden Zeilen

        Returns:
            bool: True falls das match aufgenommen wurde
        &#34;&#34;&#34;

        if cls.regex_begin.match(text):
            if not cls.regex_ausschluss_kommentar.match(text):
                # Dann aufnehmen in die Liste der MAtches! inkl. Platzhalter für Endzeilennummer:
                cls.matches_line_ixs.append([line_no, None])
                Procedure.search_for_begin = False

                return True
        
        return False






    @classmethod
    def search_end_of_procedure(cls, text:str, line_no:int) -&gt; bool:
        &#34;&#34;&#34;
        Prüft eine einzelne Zeile eines Codes (den übergebenen text), ob es sich um ein Match einer Deklarations-END-zeile handelt, und auch, ob diese NICHT-auskommentiert ist. Sofern dies der Fall ist, wird dieses MAtch in die Liste der MAtsches aufgenommen.

        Args:
            text (str): Zu prüfender Text ausschnitt
            line_no (int) : Zeilennummer der Liste an gesamt zu untersuchenden Zeilen

        Returns:
            bool: True falls das match aufgenommen wurde
        &#34;&#34;&#34;

        
        # BUG: Durch die Regex wird aber auch etwas wie End sub  gefunden obwohl es um end function geht! Daher wurde der PRogrammablauf im main angepasst, um sicherzustellen, dass immer nach der richtigen Klassen-Beendigung gesucht wird... Falls Langeweile: Später mal schauen warum...
        if cls.regex_end.match(text):
            if not cls.regex_ausschluss_kommentar.match(text):
                # Dann aufnehmen in die Liste der MAtches!
                cls.matches_line_ixs[-1][-1] = line_no

                Procedure.search_for_begin = True

                return True
        
        return False


    


    @classmethod
    def initialize_page_top_text(cls):
        &#34;&#34;&#34;
        Initialisiert den Text für den Markdown-Text des  Headers der Seite und speichert es in der Klassenvariable cls.head. 
        Zugriff erfolgt über die Superklasse Procedure. 

        
        &#34;&#34;&#34;

        page_top_text = cls.__read_template(&#34;templates/sec_head.md&#34;)

        # Gesamtanzahl an verfügbaren prozeduren je Art einsetzen:
        placeholder_replacer = {
            &#34;@PLACEHOLDER_INPUT_FILE@&#34; : MetaData.get_input_filename(),
            &#34;@PLACEHOLDER_TIMESTAMP_NOW@&#34; : MetaData.date_of_process,
            &#34;@PLACEHOLDER_TIMESTAMP_SOURCEFILE@&#34; : MetaData.input_file__date_of_change,
        }


        for placeholder, replacer in placeholder_replacer.items():
            page_top_text = page_top_text.replace(placeholder, str(replacer))

        cls.page_top_text = page_top_text
        




    @classmethod
    def initialize_toc(cls):
        &#34;&#34;&#34;
        Initialisiert den Text für den Markdown-Text des  Table of content und speichert es in der Klassenvariable cls.toc. Zugriff erfolgt über die Superklasse Procedure. 
        Innerhalb des resultierenden Textes sind weiterhin jeweils 1 Platzhalter fuer jede Prozedur-Art vorhanden. Diese werden spaeter gesondert ersetzt.
        &#34;&#34;&#34;

        toc = cls.__read_template(&#34;templates/sec_toc.md&#34;)

        # Gesamtanzahl an verfügbaren prozeduren je Art einsetzen:
        placeholder_replacer = {
            &#34;@PLACEHOLDER_SUBS_COUNTS@&#34; : len(Sub.instances),
            &#34;@PLACEHOLDER_FUNCTIONS_COUNTS@&#34; : len(Function.instances),
        }


        for placeholder, replacer in placeholder_replacer.items():
            toc = toc.replace(placeholder, str(replacer))

        cls.toc = toc
        






    @classmethod
    def generate_toc_entries(cls, subklasse):
        &#34;&#34;&#34;
        
        Generiert die Einzelnen Eintraege aller Prozeduren der uebergebenen subklasse und fuegt diese in die Klassenvariable cls.toc ein, indem Platzhalter verwendet werden.
        
        Zugriff auf Superklassen-Ebene


        Args:
            subklasse (Sub | Function): Klasse, die aktuell gelistet werden soll
        &#34;&#34;&#34;


        toc = cls.toc # shortcut

        keyword_type = subklasse.KEYWORD_TYPE.upper()
        platzhalter = f&#34;@PLACEHOLDER_ENTRIES_{keyword_type}S@&#34;
        

        for (prozedur_obj, prozedur_name, prozedur_initialisierungszeile) in subklasse.all_procedures_final:

            # Iterieren ueber jede Instanz:

            # TODO: Vorgehen wenn es KEINE instanz gibt???! - sollte kein Problem sein, dadurch dass nach jedem Einfügen immer wieder der Ausgangszustand bzgl. des Platzhalters wiederhergestellt wird un dieser am Ende gelöscht wird??!

            # Aufbau des Markdown.-Codes fuer diesen TOC-Eintrag:
            new_entry = &#34;* [```{temp_prozedur_name}```](#{temp_prozedur_name}) &lt;small&gt;(Zeile {temp_prozedur_zeile})&lt;/small&gt;&#34;.format(temp_prozedur_name=prozedur_name, temp_prozedur_zeile=prozedur_initialisierungszeile)

            # Append the placeholder to have this flag for insert further entries:
            new_entry = new_entry + &#34;\n  &#34; + platzhalter
            # ACHTUNG: Leerzeichen vorweg sind relevant fuer korrekte Einrueckung im MArkdown!


            toc = toc.replace(platzhalter, new_entry)


        # After all procedures of 1 type: Delete the leaving placeholder in the toc for this type of procedures.
        toc = toc.replace(platzhalter, &#34;&#34;)

        # store into class-variable:
        cls.toc = toc

        













    @classmethod
    def analyse_references(cls):
        &#34;&#34;&#34;
        Zugriff erfolgt über die Superklasse Procedure. Innerhalb der Methode wird ueber jedes Objekt jeder Subklasse iterriert.

        Zur Vereinfachung wird eine neue Klassenvariable auf Superklassen-Ebene erstellt, in der alle Elemente der beiden gleichnamigen Listen der einzelnen Subklassen Sub und Function.all_procedures_final enthalten sind. Diese Liste ist sortiert nach aufsteigender Zeilennummer.

        Es wird dann nach Referenzierungen (Aufrufen) jeder Einzelnen Prozedur im gesamten Quelltext gesucht. Bei einem gefundenen Match wird weiter identifiziert, innerhalb welcher uebergeordneten Prozedur dieser Aufruf erfolgte. 
        Fuer jedes Objekt wird eine Objektvariable (Liste) references erstellt, die initial leer ist und bei gefundenen Matches jeweils mit einem Tuple der folgenden Form erweitert wird: (line_no, bezeichnung_uebergeordnete_prozedur, zeilentext_des_aufrufes)

        &#34;&#34;&#34;

        # ERstellung der gemeinsamen Liste auf Superklassen-Ebene:
        all_procedures = Sub.all_procedures_final + Function.all_procedures_final


        # Sortierung der neuen Liste: Basierend auf der Zeilen-Nummer der Deklarationszeile
        cls.all_procedures_final = sorted(all_procedures, key=lambda stored_tuple: stored_tuple[2])


        for (prozedur_obj, prozedur_name, prozedur_initialisierungszeile) in cls.all_procedures_final:

            # Erstellen einer Objektvariable: Liste fuer alle noch zu findenen Referenzierungen:
            prozedur_obj.references = []
            
            &#34;&#34;&#34;
            # DEBUG:
            # BEISPIELERGEBNIS:
                # prozedur_obj = &lt;__main__.Function object at 0x0000018180C603A0&gt;
                # prozedur_name = &#34;addieren&#34;
                # prozedur_initialisierungszeile = 24

            &#34;&#34;&#34;
            
            # ACHTUNG: Die folgende regex matcht zwar NICHT etwas wie &#39; Prozedurname, aber ohne das Leerzeichen (&#39;Prozedurname) wird fälschlicherweise immer noch gematcht! Daher nach dem matschen einfach nochmal prüfen, ob VOR dem ProcName noch ein &#39; steht... dann entnehme das Matsch wieder (ähnliches Vorgehensweise wie bei der Identifizierung von Procedures-Deklarationen...). 
            # regex_ansatz = re.compile(r&#34;(?&lt;!(&#39;.*))(\W{___PROC_NAME___}\W)&#34;.format(___PROC_NAME___=prozedur_name))
            # ACHTUNG: Durch diese Einschränkung brauche ich EH diese Kontrolle, daher wird jetzt doch eine regex verwendet, die das Auskommentieren GAR NICHT berücksichtigt, somit werden auch alle auskommentierten Aufrufe gematcht... Dafür wird stattdessen direkt mit berücksichtigt, dass Deklarationszeilen NICHT gematcht werden sollen! Eine einzelne Abfrage hierzu ist also nicht mehr erforderlich!
            # regex = re.compile(r&#34;(?&lt;!(Function|Sub))\W{___PROC_NAME___}\W&#34;.format(___PROC_NAME___=prozedur_name))
            # regex = re.compile(r&#34;\b(!Function|Sub\b)\W{___PROC_NAME___}\W&#34;.format(___PROC_NAME___=prozedur_name))
            
            
            
            regex_call = re.compile(r&#34;\bcall\s+{___PROC_NAME___}\b&#34;.format(___PROC_NAME___=prozedur_name))



            # Folgende macht leider einen erroer .  im &#34;normalen &#34; regex geht es, in python.re nicht:
            # regex_brackets = re.compile(r&#34;(?&lt;!((Function|Sub).*))({___PROC_NAME___}\()&#34;.format(___PROC_NAME___=prozedur_name))

            # ACHTUNG: es wird hiermit DOCH NICHT ABGEFANGEN, dass die Deklarationszeile nicht gematcht wird! die muss also später noch raus kommen!
            regex_brackets = re.compile(r&#34;\b{___PROC_NAME___}\(&#34;.format(___PROC_NAME___=prozedur_name))



            # Durchsuche den GESAMTEN QUELLTEXT nach einem Aufruf dieser Prozedur:
            for line_no, line_text in enumerate(cls.raw_source_code, 1):



                # db(&#34;gesuchte Methode:&#34;, prozedur_name, &#34;Line-Nr = &#34;, line_no, &#34;  :  &#34;, line_text)


                if line_no == prozedur_initialisierungszeile:
                    # Dann ist dies die  Deklarationszeile der Funktion, zu der die Aufrufe gefunden werden sollen - also ignorieren!
                    continue



                if not (match:=regex_brackets.search(line_text)):
                    # Kein Aufruf mittels ...PROZEDURNAME(...
                    if not (match:=regex_call.search(line_text)):
                        # Kein Aufruf mittels ...Call PROZEDURNAME...

                        continue
                
                
                # TODO: Backreference auf die Gruppe mit dem Sub-Namen (kenie backref nötig, da es ja EH nur nach dieser gesucht wird!)
                ziel_prozedur_name = prozedur_name
                # db(match)
                    


                # An dieser Stelle ist match IMMER != None:
                # db(match)

                # Check wheather there is a comment-symbol before the procedure name:
                __prozedur_name_start_pos = match.span()[0]
                if (cls.regex_ausschluss_kommentar.search(line_text[0:__prozedur_name_start_pos])):
                    # Dann kommentar
                    continue


                # Hier ist eine tatsächlicher Aufruf gefunden worden, der jetzt dokumentiert werden muss:
                # JEtzt muss der Aufruf dokumentiert werdn!
                


                # ACHTUNG:  WICHTIG:  Der folgende Schritt / die Logik und Anwendung war mir neu  -  nochmal recherchieren! sowohl mit dem filtern / nach eigenem Key, als auch, dass das Ergebnis nicht DIE EINZELNE ZAHL  ist, sondern tatsächlich direkt das TUPLE, IN DEM DIESE EINZELNE ZAHL GESPEICHERT IST!  Extrem praktich!!!!

                
                # Logik zum Finden der aufrufenden Prozedur: Die Deklarationszeilennummer muss &lt; line_no sein. Die nächste dran ist die Zeilennummer der Deklarationszeile
                aufrufende_prozedur_tuple_relevant = [tpl for tpl in cls.all_procedures_final if tpl[2] &lt; line_no]

                # Das relevante Tuple der Liste cls.all_procedures_final wird in der selben Form gespeichert in der folgenden Variable:
                aufrufende_prozedur_tuple = min(aufrufende_prozedur_tuple_relevant, key=lambda x_tuple: abs(x_tuple[2] - line_no))


                # prozedur_obj.references.append((line_no, aufrufende_prozedur_tuple[1], line_text))

                #Erweiterung um den Prozedurnamen, der aufgerufen wird:
                # ziel_prozedur_name = &#34;&#34;

                prozedur_obj.references.append((line_no, aufrufende_prozedur_tuple[1], line_text, ziel_prozedur_name))



                
                &#34;&#34;&#34;
                # _BUGFIX: Fehlerhafte Zuordnung! ERLEDIGT + OK IN V. &gt;= 0.2.0

                Aktuelle Parameter im scope:
                    line_no = 68
                    aufrufende_prozedur_tuple[1] = &#34;bauer&#34; # _BUGFIX: SOLLTE MAIN SEIN!!!!!


                &#34;&#34;&#34;

                # db(prozedur_obj.references)





    @classmethod
    def finilize(cls, output_file_path:str):
        &#34;&#34;&#34;
        ### TODO: Ob wirklich alles hier in die Klasse gehört ist fraglich! 
        
        Zugriff erfolgt über die Superklasse Procedure. Innerhalb der MEthode wird wiederum in Schleifen itteriert ueber die Subklassen.
        
        Bereitet die finale Ausgabe vor und ruft weitere MEthoden zum Schreiben dieser Ausgabe / der Markdown-Datei auf.
        Zu dieser Vorbereitung gehört:
         
            • Sortierung der einzelnen Prozeduren innerhalb der verschiedenen Prozedur-Arten gemaess der alphabetischen Reihenfolge ihrer Bezeichner (Namen)
            
            • Konfigurieren / Initilalisierung der Zwischenüberschriften / Header-Texte unterhalb der einzelnen Section-Überschriften (gespeichert in Klassenvariable cls.header)


        Args:
            output_file_path (str): Dateipfad der zu erstellenden Markdown-Datei
        &#34;&#34;&#34;





        cls.initialize_page_top_text()


        # =============================================================================
        #### # Extrahiere den Modulweiten Docstring (sofern es einen gibt): ####
        # =============================================================================
        
        # Beginne erst ab Zeile 1 wegen der Codierungszeichen!
        __modul_docstring = cls.identify_docstring(cls.raw_source_code[1:], trim_empty_rows=True, return_alternativ_text=True)
        __template_docstring = cls.__read_template(&#34;templates/sec_modulinfos.md&#34;)
        # Ersetze Platzhalter in der Template durch gefundenen Docstring:
        cls.modul_docstring = __template_docstring.replace(&#34;@PLACEHOLDER_MODUL_DOCSTRING@&#34;, __modul_docstring)

        
        






        # Vorbereitung des TOCS:
        cls.initialize_toc()




        for procedure_type_cls in [Sub, Function]: 



            # Initialisieren des Headers unterhalb der Section-Überschrift  (aus gesonderter Template) und in Klassenvariable speichern:
            content = cls.__read_template(procedure_type_cls.TEMPLATE_SECTION_HEAD)

            cls.header = content





            # Instanzen der Prozeduren  Alphabetisch  sortieren nach den Namen! und in Klassenvariable speichern:
            procedure_type_cls.sort_procedures_by_names()


            # Ergänze einen einzigen Eintrag für eine Methode! und haenge sie dem TOC an
            # WICHTIG: Auf Superklassen-Ebene!
            cls.generate_toc_entries(procedure_type_cls)

        
        # Durchsuche gesamten Quelltext nach allen Referenzierungen für jeweils alle gefundenen Prozeduren und speichere sie in den jeweiligen Objekten der einzelnen Prozeduren:
        cls.analyse_references()

        # JULIA: Diese Referenzierungen müssen jetzt noch in die Template prozedur.md eingebaut werden! Aktuell erfolgt das alles inkl. der Auswertung in der Methode write_to_file

        # TODO: Diese Referenzierungen müssen jetzt noch in die Template prozedur.md eingebaut werden! Aktuell erfolgt das alles inkl. der Auswertung in der Methode write_to_file










        # Aufruf der Methode zum tatsächlichen Schreiben der Textdatei:
        cls.write_to_file(output_file_path)



    
    def generate_calling_entries(self) -&gt; None:
        &#34;&#34;&#34;
        # TODO: # JULIA                                         
        mitten in dev.

        ansatz vorhanden



        Generiert die Dokumentatoin der Abrufsequenzen / Abruffolgen.
        Speichert das Ergebnis in der bereits existierenden Objektvariable procedure_obj.documentation
        &#34;&#34;&#34;


        # TODO                                                                      
        # JULIA                                                                     
        &#34;&#34;&#34;
        
        MÖGLICHE HERANGEHENSWEISEN


        - Vorgehensweise A:
            - Durchsuche gesamten Code DIESER Prozedur nach einem Aufruf einre Prozedur, die hier bereits bekannt ist (via regex)

        - Vorgehensweise B:
            -  Durchsuche alle OBJEKT-INSTANZEN aller Prozeduren beim key=References und schaue, ob eine zeilennummer der referenzierung innerhalb der zeilennummer dieser prozedur hier liegt.
            - scheint mir der entwicklungs-technisch schnellere weg zu sein...
            - bei langen programmen mit vielen prozeduren ist es besonders ineffizient, je kürzer die HIER TATSÄCHLICH GERADE zu dokumentierende funktion ist, aber das ist mir mal egal....
            - Vorteil: keine regex entwicklung / duplikat wie bei references!


        &#34;&#34;&#34;

        &#34;&#34;&#34;
        # Referenzierungs-zeile muss hierzwischen liegen:
        self.line_begin
        self.line_end







        &#34;&#34;&#34;

        # TODO: Extrahiere alle Referenzierungen dazwischen:
        db(&#34;...&#34;)

        self.calling_sequences = []

        # bei hauptfunc1 --&gt; soll 2 einträge: unterfunkntionA + B
        
        Procedure.all_procedures_final
        # liste mit exemplarischen einzel-Eintrag: 
        # (procedure_obj, procedure_name, procedure_line )



        for (procedure_obj, uebergeordnete_prozedur_name, procedure_declaration_line_no) in Procedure.all_procedures_final:

            &#34;&#34;&#34;
            # iterater = 6 # schleifenzähler pro prozedur
            # einzelprozedur = Procedure.all_procedures_final[iterater][0]
            # ENTSPRICHT JETZT:
            procedure_obj

            procedure_obj.references
            # liste mit exemplarischen einzel-Eintrag: 
            # (line_nr_aufruf, &#34;uebergeordnetes_sub&#34;, code)
            &#34;&#34;&#34;
            
            # SCHNELLERER ANSATZ:
            # Filtern der liste, so dass uebergeordnetes_sub == name
            # dann fertig!

            relevante_references = [_ for _ in procedure_obj.references if uebergeordnete_prozedur_name == self.name]

            for (line_no_reference, uebergeordnetes_sub, code, ziel_prozedur_name) in relevante_references:

                self.calling_sequences.append((line_no_reference, uebergeordnetes_sub, code, ziel_prozedur_name)) # relevant ist nur der name aus der regex im cod
                # TODO: ??? ggf doch nicht nötig? Bei erstellung dieses tupels bei analyse der referenzen --&gt; speichere auch das ziel, aleso den subname
            

            &#34;&#34;&#34;
            # ALTER ALTERNATIVER ANSATZ:

            # ist line_nr zwischen self.line.begin + self.line.end der ZU DOKUMENTIERENDEN Prozedur??
            for (line_no_reference, uebergeordnetes_sub, code) in procedure_obj.references:
                if line_no_reference &lt; self.line_begin:
                    continue
                if line_no_reference &gt; self.line_end:
                    continue
                # SONST: liegt es darin!!! AUFNEHMEN IN LISTE!!!!

                self.calling_sequences.append((line_no_reference, uebergeordnetes_sub, code))
            &#34;&#34;&#34;



                # TODO:  Am Ende vor der dokumentation die liste noch sortieren aufsteigend nach line_no_reference konzeptionell identisch wie im index/toc

                # JULIA: LOGIK FALSCH????
            db(self.calling_sequences)


            _PLACEHOLDER_REFERENCE = &#34;@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@&#34;

            # TODO: ersetze im doc:
            doc = self.documentation

    


            # Initialisierung und  Parametrisierung  des Einleitungssatzes:
            einleitungssatz = &#34;Keine weiteren Aufrufe zu hier dokumentierten Prozeduren gefunden.&#34; # default

            if len(self.calling_sequences) &gt; 0:

                einleitungssatz = &#34;Innehalb der Prozedur werden die folgenden, untergeordneten Prozeduren aufgerufen:&#34;

            for (line_no_reference, uebergeordnetes_sub, line_code, target_procedure_name) in self.calling_sequences:


                # TODO:
                # HACK:
                target_procedure_name = &#34;main&#34;



                replacer_placeholder_reference = f&#34;&lt;small&gt;  Zeile {line_no_reference} &lt;/small&gt; : ```{line_code}``` ODER: {target_procedure_name}&#34;
                # replacer_placeholder_reference = f&#34;* [```{code}```](#{target_procedure}) : &lt;small&gt;  Zeile {line_no_reference} : ```{line_code}``` &lt;/small&gt;&#34;

                replacer_placeholder_reference = replacer_placeholder_reference  + f&#34;\n{_PLACEHOLDER_REFERENCE}&#34;
                    
                # Ersetzen:
                doc = doc.replace(_PLACEHOLDER_REFERENCE, replacer_placeholder_reference)

                    
            # Loeschen des verbliebenen Platzhalters zum Einfuegen einzelner Referenzen:
            doc = doc.replace(_PLACEHOLDER_REFERENCE, &#34;&#34;)



            # Einsetzen des Einleitungssatzes:
            doc = doc.replace(&#34;@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@&#34;, einleitungssatz)


            # shortcut / resubstitution:
            self.documentation = doc




    
    # @classmethod # eigentlich bezieht sich das auf ein einzelnes Objekt!!!
    def generate_reference_entries(self) -&gt; None:
    # def generate_reference_entries(cls, procedure_obj) -&gt; None:
        &#34;&#34;&#34;
        Generiert von dem Objekt der Subklasse Function oder Sub die Dokumentation der Referenzierungen.
        Speichert das Ergebnis in der bereits existierenden Objektvariable procedure_obj.documentation
        &#34;&#34;&#34;



        # TODO: Struktur...? das gehört zu den references... ist eig. statisch, müsste nicht jedes mal beim funktionsaufruf neu gemacht werden, aber so ist es zusammen...
        _PLACEHOLDER_REFERENCE = &#34;@PLACEHOLDER_PROCEDURE_REFERENCES_ENTRY@&#34; 



        # shortcut:
        doc:str = self.documentation 

        # Alle Referenzierungen sind in der Objektvariablen  procedure_obj.references gespeichert:
        count_of_references = len(self.references)

        # ERsetzen des Platzhalters für die Anzahl der Referenzierungen in der bisherigen Dokumentation:
        doc = doc.replace(&#34;@PLACEHOLDER_PROCEDURE_COUNT_OF_REFERENCES@&#34;, str(count_of_references))
        

        # Initialisierung und  Parametrisierung  des Einleitungssatzes:
        einleitungssatz = &#34;Kein Aufruf gefunden.&#34; # default

        if count_of_references &gt; 0:

            einleitungssatz = &#34;Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:&#34;

            
            # Iterrieren ueber jede Referenzierung, um diese zu dokumentieren:
            for (line_no, calling_procedure_name, line_code, target_procedure_name) in self.references:

                # Zusammenbau des Ersatzwertes für den Platzhalter inkl. Anhängen des Platzhalters für weitere Ersetzungen:
                
                # Um MArkdown nicht zu zerschiessen muss der letzte Zeilenumbruch des line_codes entfernt werrden:
                line_code:str = line_code.rstrip(&#34;\n&#34;)

                replacer_placeholder_reference = f&#34;* [```{calling_procedure_name}```](#{calling_procedure_name}) : &lt;small&gt;  Zeile {line_no} : ```{line_code}``` &lt;/small&gt;&#34;


                # # AUSBLICK: weitere collapse details : funktioniert technisch, allerdings steht das collapsable immer in neuer Zeile und daher wird es groß - vielleicht später in schön machen...
                # __replacer_placeholder_reference = f&#34;*   [```{calling_procedure_name}```](#{calling_procedure_name})  &lt;details&gt; &lt;summary&gt;: &lt;small&gt;Zeile {line_no}&lt;/small&gt; &lt;/summary&gt; ```{line_code}``` &lt;/details&gt;&#34;



                replacer_placeholder_reference = replacer_placeholder_reference  + f&#34;\n{_PLACEHOLDER_REFERENCE}&#34;
                
                # Ersetzen:
                doc = doc.replace(_PLACEHOLDER_REFERENCE, replacer_placeholder_reference)


        # Loeschen des verbliebenen Platzhalters zum Einfuegen einzelner Referenzen:
        doc = doc.replace(_PLACEHOLDER_REFERENCE, &#34;&#34;)



        # Einsetzen des Einleitungssatzes:
        doc = doc.replace(&#34;@PLACEHOLDER_PROCEDURE_REFERENCES_INTRODUCTION@&#34;, einleitungssatz)


        # shortcut / resubstitution:
        self.documentation = doc
        
        # TODO: Auslagern in eigene Funktion!     ENDE                       








    @classmethod
    def write_to_file(cls, output_file_path:str):
        &#34;&#34;&#34;
        Schreibt die Dokumentation aller Prozeduren (aller Art) in die als Dateipfad übergebene Zieldatei(pfad).
        &#34;&#34;&#34;



        # initialize_toc



        with open(output_file_path, &#34;w&#34;, ) as file:

            ## TODO: Dies gehört eigentlich nicht mehr in die Klasse Procedure, aber aktuell trotzdem hierher, um alles zusammen zu haben. Ggf.s später refactoring...
            # Initialisiere die Seite mit Titel und organisatorischen Hinweisen:
            content = cls.__read_template(&#34;templates/sec_head.md&#34;)


                                
            # # TEST                                                                                                              
            # # Extrahiere Daten von der Version DIESES DOKUMENTIER-TOOLS:
            # content = MetaData.gitinfo 
            # content = content + &#34;\n&#34;*3 + &#34;Datum der Umwandlung: &#34; + MetaData.date_of_process
                          


            # TODO: Hier muss noch Placeholders ersetzt werden!!&#39;
            file.write(cls.page_top_text)


            #Einfügen des Index / TOCs /  Inhaltsverzeichnis:
            file.write(cls.toc)


            # schreiben der Modulinfos / Docstrings:
            file.write(cls.modul_docstring)





            # # TODO: Struktur...? das gehört zu den references...
            # _PLACEHOLDER_REFERENCE = &#34;@PLACEHOLDER_PROCEDURE_REFERENCES_ENTRY@&#34; 


            for procedure_type_cls in [Sub, Function]: # Reihenfolge wichtig fuer die Reihenfolge der Dokumentierten Sections!


                # Überschrift der Section einfügen (aus gesonderter Template):
                file.write(procedure_type_cls.header)



                # Dokumentieren aller einzelnen Prozeduren:
                for procedur_infos in procedure_type_cls.all_procedures_final:
                # for (procedure_obj, procedure_name, procedure_line) in procedure_type_cls.all_procedures_final:

                    procedure_obj:Procedure = procedur_infos[0]





                    procedure_obj.generate_reference_entries()

                    &#34;&#34;&#34;
                    # TODO: Auslagern in eigene Funktion!     START                        erledigt ab V. 0.2.2

                    # shortcut:
                    doc:str = procedure_obj.documentation 

                    # Alle Referenzierungen sind in der Objektvariablen  procedure_obj.references gespeichert:
                    count_of_references = len(procedure_obj.references)

                    # ERsetzen des Platzhalters für die Anzahl der Referenzierungen in der bisherigen Dokumentation:
                    doc = doc.replace(&#34;@PLACEHOLDER_PROCEDURE_COUNT_OF_REFERENCES@&#34;, str(count_of_references))
                    

                    # Initialisierung und  Parametrisierung  des Einleitungssatzes:
                    einleitungssatz = &#34;Kein Aufruf gefunden.&#34; # default

                    if count_of_references &gt; 0:

                        einleitungssatz = &#34;Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:&#34;

                        
                        # Iterrieren ueber jede Referenzierung, um diese zu dokumentieren:
                        for (line_no, calling_procedure_name, line_code) in procedure_obj.references:

                            # Zusammenbau des Ersatzwertes für den Platzhalter inkl. Anhängen des Platzhalters für weitere Ersetzungen:
                            
                            # Um MArkdown nicht zu zerschiessen muss der letzte Zeilenumbruch des line_codes entfernt werrden:
                            line_code:str = line_code.rstrip(&#34;\n&#34;)

                            replacer_placeholder_reference = f&#34;* [```{calling_procedure_name}```](#{calling_procedure_name}) : &lt;small&gt;  Zeile {line_no} : ```{line_code}``` &lt;/small&gt;&#34;


                            # # AUSBLICK: weitere collapse details : funktioniert technisch, allerdings steht das collapsable immer in neuer Zeile und daher wird es groß - vielleicht später in schön machen...
                            # __replacer_placeholder_reference = f&#34;*   [```{calling_procedure_name}```](#{calling_procedure_name})  &lt;details&gt; &lt;summary&gt;: &lt;small&gt;Zeile {line_no}&lt;/small&gt; &lt;/summary&gt; ```{line_code}``` &lt;/details&gt;&#34;



                            replacer_placeholder_reference = replacer_placeholder_reference  + f&#34;\n{_PLACEHOLDER_REFERENCE}&#34;
                            
                            # Ersetzen:
                            doc = doc.replace(_PLACEHOLDER_REFERENCE, replacer_placeholder_reference)


                    # Loeschen des verbliebenen Platzhalters zum Einfuegen einzelner Referenzen:
                    doc = doc.replace(_PLACEHOLDER_REFERENCE, &#34;&#34;)



                    # Einsetzen des Einleitungssatzes:
                    doc = doc.replace(&#34;@PLACEHOLDER_PROCEDURE_REFERENCES_INTRODUCTION@&#34;, einleitungssatz)


                    # shortcut / resubstitution:
                    procedure_obj.documentation = doc
                    
                    # TODO: Auslagern in eigene Funktion!     ENDE                       


                    &#34;&#34;&#34;


                    # JULIA: Versuche Wiederherstollung des Tails!!!!
                    # procedure_obj.generate_calling_entries()

                    file.write(procedure_obj.documentation)


                # Ausgabe der Zusammenfassung pro Section:
                print(&#34;Es wurden {} {}s identifiziert und dokumentiert.&#34;.format(len(procedure_type_cls.instances), procedure_type_cls.KEYWORD_TYPE))



            ## TODO: Dies gehört eigentlich nicht mehr in die Klasse Procedure, aber aktuell trotzdem hierher, um alles zusammen zu haben. Ggf.s später refactoring...
            # Finalisiere die Seite mit Schlusbemerkungen:
            content = cls.__read_template(&#34;templates/sec_tail.md&#34;)
            # HACK: Nur fuer ENtwicklungsstadium!
            content = content.replace(&#34;@PLACEHOLDER_TIMESTAMP_NOW@&#34;, MetaData.date_of_process)
            content = content.replace(&#34;@PLACEHOLDER_DOC_PYTHON@&#34;, __doc__.replace(&#34;\n&#34;, &#34;&lt;br&gt;&#34;))
            content = content.replace(&#34;@PLACEHOLDER_DOCUMENTER_VERSION__AUTHOR@&#34;, MetaData.documenter_version__author.rstrip(&#34; &lt;_&gt;&#34;))
            content = content.replace(&#34;@PLACEHOLDER_DOCUMENTER_VERSION__COMMIT@&#34;, MetaData.documenter_version__commit)
            content = content.replace(&#34;@PLACEHOLDER_DOCUMENTER_VERSION__DATE@&#34;, MetaData.documenter_version__author_date)

            file.write(content)






    @classmethod
    def sort_procedures_by_names(cls):
        &#34;&#34;&#34;
        Füllen der Klassenvariable der **SUBKLASSE** cls.all_procedures_final mit einem Tupel pro Prozedur, in dem sowohl das einzelne Objekt, als auch seine Bezeichnung und die Zeilennummer der Deklaratrion enthalten ist in der Form [(object:Procedure, object.name:str, object.line_begin)]. 
        Diese Liste wird nach Fertigstellung sortiert basierend auf den alphabetischen Bezeichnern, sodass der Zusammenhang zwischen den Objekten und den Namen weiterhin gegeben ist, gleichzeitig aber die Objekte in der alphabetischen Reihenfolge ihrer Namen dokumentiert werden können.

        &#34;&#34;&#34;

        all_procedures = [] 


        for procedure_obj in cls.instances:
            
            all_procedures.append((procedure_obj, procedure_obj.name, procedure_obj.line_begin))



        # Nach dem Füllen: Sortieren basierend auf den Bezeichner-Namen:
        cls.all_procedures_final = sorted(all_procedures, key=lambda stored_tuple: stored_tuple[1])



        
            













    @staticmethod
    def __read_template(template_file_path) -&gt; str:
        &#34;&#34;&#34;
        Ließt die uebergebene Template-MArkdown Datei ein und gibt den Inhalt als String zurück.
        
        Args:
            template (str) : Dateipfad zur Template

        Return:
            str : Textinhalt der Template
        &#34;&#34;&#34;
        with open(template_file_path, &#34;r&#34;) as file:
            content = file.read()
            return content





    def read_template(self, template=&#34;einzelprozedur&#34;) -&gt; str:
        &#34;&#34;&#34;
        Ließt die relevante Template-MArkdown Datei ein und gibt den Inhalt als String zurück. 
        Sofern es sich um die Default-Template für eine beliebige Prozedur handelt
        wird außerdem auch das Attribut self.documentation mit diesem Text initialisiert.

        Args:
            template (str) : Dateipfad zur Template - Ausnahme: Falls die in der Klasse gespeicherte 
                            Standardtemplate self.TEMPLATE fuer eine Prozedur verwendet werden soll, 
                            dann muss das Stichwort &#34;einzelprozedur&#34; übergeben werden. 
                            Dies ist default der Fall --&gt; keine Angabe erforderlich.

        Return:
            str : Inhalt der Template
        &#34;&#34;&#34;


        if template == &#34;einzelprozedur&#34;:
        
            # Auslesen und Speichern in Objektvariable
            self.documentation = self.__read_template(self.TEMPLATE)
            return self.documentation


        # Bei NICHT-Standard-Prozedur-Template: Auslesen dieser Template und Rückgabe des Textinhaltes:
        content = self.__read_template(template)
        return content





    def generate_documentation(self):
        &#34;&#34;&#34;
        Dokumentiert die gefundenen Parameter unter Nutzung einer Template-Markdown-Textdatei und speichert den zu schreibenden Text im Attribut self.documentation
        &#34;&#34;&#34;

        self.read_template()

        placeholder_replacer = {
            &#34;@PLACEHOLDER_PROCEDURE_TYPE@&#34; : self.KEYWORD_TYPE,
            &#34;@PLACEHOLDER_PROCEDURE_MODIFIER@&#34; : self.modifier,
            &#34;@PLACEHOLDER_PROCEDURE_NAME@&#34; : self.name,
            &#34;@PLACEHOLDER_PROCEDURE_LINE_BEGIN@&#34; : self.line_begin,
            &#34;@PLACEHOLDER_PROCEDURE_DOCSTRING@&#34; : self.docstring,
            &#34;@PLACEHOLDER_PROCEDURE_SOURCE_CODE@&#34; : self.source_code,

            # # TODO:  Kommen die References extra??! Wahrscheinlich schon stand jetzt (Version&gt; 0.1.3)
            # &#34;@PLACEHOLDER_PROCEDURE_REFERENCES@&#34; : self.references,
            # &#34;@PLACEHOLDER_PROCEDURE_COUNT_OF_REFERENCES@&#34; : self.count_of_references,
        }


        for placeholder, replacer in placeholder_replacer.items():
            self.documentation = self.documentation.replace(placeholder, str(replacer))













    def extract_source_code(self):
        &#34;&#34;&#34;
        Ließt den source_code aus und speichert diesen im Attribut self.source_code
        &#34;&#34;&#34;

        source_code = &#34;&#34;
        for line in self.lines:
            source_code = source_code + line

        self.source_code = source_code





    def extract_modifier(self):
        &#34;&#34;&#34;
        Ließt den Modifier aus und speichert diesen im Attribut self.modifier
        &#34;&#34;&#34;
        # Wiederverwendung der Deklarationszeilen-Regex:
        match = self.regex_begin.match(self.lines[0])

        # Entnehme den String bis vor den NAmen:
        pos_name = match.string.find(self.name + &#34;(&#34;)
        potentieller_modifier = match.string[0:pos_name]

        # Identifiziere hieraus den modifier:
        
        # # Eigentlich sollte es schon auf Grundlage der eigentlichen regex gehen, funktioniert aber nicht! Es wird immer was leres zurückgegeben, daher, neue regex! (Bei Zeit mal schauen warum!)
        # # Extraktion der Gruppe mit dem Name: (eigentlicher Ansatz)
        # db(match.groups())
        # modifier = match.group(1)
        
        
        regex_modifier = re.compile(r&#34;((?:Private|Public|Friend)?)&#34;)
        match = regex_modifier.match(potentieller_modifier)
        modifier = match.group(1)


        if modifier == &#34;&#34;:
            modifier = &#34;Public&#34;

        # db(modifier)

        self.modifier = modifier




    def extract_name(self):
        &#34;&#34;&#34;
        Ließt den Bezeichnungsnamen aus und speichert diesen im Attribut self.name
        &#34;&#34;&#34;
        # Wiederverwendung der Deklarationszeilen-Regex:
        
        
        match = self.regex_begin.match(self.lines[0])

        # db(match.groups())
        # Extraktion der Gruppe mit dem Name:
        name = match.group(1)

        # db(name)

        self.name = name



    def extract_line_numbers(self):
        &#34;&#34;&#34;
        Ließt die relevanten Start- und End-Zeilennummern aus und speichert diesen im Attribut self.line_begin und self.line_end
        &#34;&#34;&#34;
        # Hole Index der Instanzenliste, dieser ist gleich dem Index der matches_line_ixs Liste:
        ix = self.instances.index(self) 

        match_lines_ix = self.matches_line_ixs[ix]
        
        self.line_begin = match_lines_ix[0] + 1
        self.line_end = match_lines_ix[1] + 1




    @staticmethod
    def identify_docstring(text_lines:tuple[str], trim_empty_rows=False, return_alternativ_text=False) -&gt; str:
        &#34;&#34;&#34;
        ### ACHTUNG: Entstanden aus der Methode extract_docstring(self), die auf Objektebene anzuwenden ist. 
        Um die gleiche Logik aber auch fuer den modulweiten Docstring nutzen zu koennen, wird dieses Konstrukt eingefuehrt.


        Ließt den ersten Block-KOmmentar / docstring aus und gibt ihn zurueck.
        Als Docstring wird jede Kommentarzeile gewertet, die DIREKT UND OHNE VORHERIGE LEERZEEILE UNTERHALB DER ERSTEN UEBERGEBENEN ZEILE steht. 
        Sobald eine Leerzeile folgt, wird der Docstring als beendet angesehen.

        Beispiel:
                &#39; Dies ist ein Kommentar direkt unter der Deklarationszeile. Somit wird es als Docstring gewertet.
                &#39; Dies auch
                &#39;
                &#39; Da die vorherige Zeile AUCH einen Kommentar (einen leeren) enthält, ist dies hier immer noch Bestandteil des Docstrings.

                &#39; Vor dieser Zeile war ein NICHT-Kommentar, daher gehört das hier nicht mehr zum Docstring
                MsgBox(&#34;Das gehört zum Programm&#34;)
            End Sub

            
        Args:
            text_lines (tuple[str]): Tuple mit den einzelnen Textzeilen, die zu der relevaten  Prozedur gehoeren.
            trim_empty_rows (bool) : False, sofern der Algorithmus direkt bei einer Leerzeile abgebrochen werden soll ( = DEFAULT), 
                                        oder True, falls der Algorithmus bei vorangehenden Leerzeilen solange weiterlaufen soll, bis dass KEINE Leerzeile mehr vorliegt oder eine andere Abbruchsbedingung erreicht ist.
            return_alternativ_text (bool | str) : Default = False. Dann wird beim Nicht-Finden ein leerer String zurückgegeben. 
                                                    Bei True wird in solchen Fällen der in der MEthode definierte Alternativ-ERsatztext zurückgegeben. 
                                                    Bei Übergabe eines Strings wird in diesen Fällen dieser String zurückgegeben.
        Returns:
            str : Docstring / Blockkommentar
        &#34;&#34;&#34;


        docstring  = &#34;&#34;


        for line in text_lines:
            # line:str
            content = line.lstrip(&#34; &#34;)

            if(content[0]) == &#34;&#39;&#34;:
               # gehört zum Docstring
                docstring = docstring + content.lstrip(&#34;&#39;&#34;)
                continue # nächste Zeile


            if trim_empty_rows == False:

                break

            # ELSE: Dann trimme die leere Reihe
            if docstring != &#34;&#34;:
                # Dann gibt es bereits einen Docstring -&gt; Abbruch
                break


            if re.match(r&#34;^\s*\n?$&#34;, content):
                # Dann besteht die Zeile nur aus Whitespaces --&gt; Trimmen!
                # Rekursiver Aufruf dieser Methode mit jeweils einer vordersten Zeile weniger!
                docstring = Procedure.identify_docstring(text_lines[1:], trim_empty_rows=True, return_alternativ_text=False) 
                # TODO: Fehlervermeidung / Grenzfall:  IndexOutOfRange (Ende angekommen, --&gt; docstring vorhanden --&gt; Wird Error geben!
                break



        # =============================================================================
        #### #  Alternativtext bei leeren Docstrings: ####
        # =============================================================================
        
        if return_alternativ_text == True:

            if docstring == &#34;&#34;:
                docstring = &#34;*No information availible. For more information expand source code.*&#34; #  Die Sternchen bewirken im MArkdown ein Kursivdruck

        elif isinstance(return_alternativ_text, str):
            if docstring == &#34;&#34;:
                docstring = return_alternativ_text


        return docstring
  




    def extract_docstring(self):
        &#34;&#34;&#34;
        # CHANGELOG: 2023-12-30 - 03:17:04 Bis V. 0.0.5 war diese Funktion &#39;alleinherschend&#39;. 
        Erst danach  wurde die Durchschleusung zur static method identify_docstring eingeführt,
        um damit auch modulweite Docstrings finden zu koennen.


        Ließt den docstring aus und speichert diesen im Attribut self.docstring
        Sofern kein Docstring im Code identifiziert wurde, wird eine entsprechende Info in den Text geschrieben.

        Als Docstring wird jede Kommentarzeile gewertet, die DIREKT UND OHNE VORHERIGE LEERZEEILE UNTERHALB DER DEKLARIERUNGSZEILE der Prozedur steht. Sobald eine Leerzeile folgt, wird der Docstring als beendet angesehen.

        Beispiel:
            Private Sub beispielProgramm() &#39; Deklarationszeile
                &#39; Dies ist ein Kommentar direkt unter der Deklarationszeile. Somit wird es als Docstring gewertet.
                &#39; Dies auch
                &#39;
                &#39; Da die vorherige Zeile AUCH einen Kommentar (einen leeren) enthält, ist dies hier immer noch Bestandteil des Docstrings.

                &#39; Vor dieser Zeile war ein NICHT-Kommentar, daher gehört das hier nicht mehr zum Docstring
                MsgBox(&#34;Das gehört zum Programm&#34;)
            End Sub
        &#34;&#34;&#34;


        # Docstring ueber generalisierte Methode herausfiltern:
        docstring = self.identify_docstring(self.lines[1:], return_alternativ_text=True)

        # Speichern im Objekt:
        self.docstring = docstring







    def extract_references(self):
        &#34;&#34;&#34;
        ### TODO: Wird aktuell (Version &gt; 0.1.2) ganz wo anders erledigt, ist dort noch nicht optimal - aber um Redundanzen und Verewchslungen vorzubeugen, wird diese Methode erst mal platt gemacht und nicht mehr aufgerufen!

        Später wäre es shcön...
        
        ### ALT: 
        Durchsucht den gesamten Quelltext nach Referenzierungen (Aufrufen) dieser Prozedur und speichert diese im Attribut self.references
        # TODO ALLES
        &#34;&#34;&#34;
        # self.references = &#34; # TODO ... self.references&#34;
        # self.count_of_references = &#34; # TODO ... self.count_of_references&#34;
        pass



    def __init__(self, text_lines:tuple[str]) -&gt; None:
        &#34;&#34;&#34;
        Erstellt ein Prozedur-Objekt, wodurch die einzelnen Komponenten des Codes gesucht und gespeichert werden.
        Uebergeben muss ein beliebig grosses Tuple, wobei jedes Element davon den String einre einzelnen Zeile dieser Prozedur enthaelt.

        Args:
            text_lines (tuple[str]): Tuple mit den einzelnen Textzeilen, die zu der relevaten  Prozedur gehoeren.
        &#34;&#34;&#34;

        # TODO: Ist  dies notwendig???! Eigentlich nicht! Dies ist schon die superklasse!
        super().__init__()

        # Merken der instanc zum späteren Iterieren: Klassenzuweisung dynamisch!
        type(self).instances.append(self)
        
        # Speichern aller Textzeilen:
        self.lines = text_lines




        # =============================================================================
        #### # HErausfiltern einzelner KOmponenten: ####
        # =============================================================================
        
        self.extract_line_numbers()
        self.extract_source_code()
        self.extract_name()
        self.extract_modifier()
        
        self.extract_docstring()




        # TODO:        Muss noch irgendwoghin!                                     
        # self.extract_references()



        # =============================================================================
        #### Zusammenfassen und Schreiben der Dokumentation: ####
        # =============================================================================
        
        self.generate_documentation()




















class Sub(Procedure):
    &#34;&#34;&#34;
    Subklasse für eine VBA-Sub-Prozedur.
    U.a. wird hier auch der von der Superklasse vor-initialisierte Regex-Ausdruck konkretisiert und kompiliert, der im VBA-Syntax für den Beginn und das Ende der Prozedurart erforderlich ist.

    Die meisten Methoden sind in der übergeordneten Superklasse gelagert, da sie vom Ablauf fuer VBA-Subs und VBA-Methoden identisch sind.

    &#34;&#34;&#34;

    matches_line_ixs = []
    instances = []

    all_procedures_final = [] # Liste wird erst nach Identifizierung aller Prozeduren erstellt. Sie dient der Sortierung  der Instanzen basierend auf der alphabetischen Reihenfolge ihrer Prozedur-Bezeichnungen

    
    KEYWORD_TYPE = &#34;Sub&#34; 

    TEMPLATE_SECTION_HEAD = &#34;templates/sec_subs.md&#34;
    

    # Konkretisierung und Kompilierung der Regex-Ausdrücke:

    regex_begin = re.compile(Procedure.regex_begin_pattern.replace(&#34;PLACEHOLDER_PROCEDURE_TYPE&#34;, KEYWORD_TYPE), re.VERBOSE | re.IGNORECASE)


    regex_end = re.compile(Procedure.regex_end_pattern.replace(&#34;PLACEHOLDER_PROCEDURE_TYPE&#34;, KEYWORD_TYPE), re.VERBOSE | re.IGNORECASE)















class Function(Procedure):
    &#34;&#34;&#34;
    Subklasse für eine VBA-Sub-Prozedur.
    U.a. wird hier auch der von der Superklasse vor-initialisierte Regex-Ausdruck konkretisiert und kompiliert, der im VBA-Syntax für den Beginn und das Ende der Prozedurart erforderlich ist.

    Die meisten Methoden sind in der übergeordneten Superklasse gelagert, da sie vom Ablauf fuer VBA-Subs und VBA-Methoden identisch sind.

    &#34;&#34;&#34;

    matches_line_ixs = []
    instances = []
    
    all_procedures_final = [] # Liste wird erst nach Identifizierung aller Prozeduren erstellt. Sie dient der Sortierung  der Instanzen basierend auf der alphabetischen Reihenfolge ihrer Prozedur-Bezeichnungen
    
    KEYWORD_TYPE = &#34;Function&#34; 
    
    TEMPLATE_SECTION_HEAD = &#34;templates/sec_functions.md&#34;
    
    
    # Konkretisierung und Kompilierung der Regex-Ausdrücke:

    regex_begin = re.compile(Procedure.regex_begin_pattern.replace(&#34;PLACEHOLDER_PROCEDURE_TYPE&#34;, KEYWORD_TYPE), re.VERBOSE | re.IGNORECASE)


    regex_end = re.compile(Procedure.regex_end_pattern.replace(&#34;PLACEHOLDER_PROCEDURE_TYPE&#34;, KEYWORD_TYPE), re.VERBOSE | re.IGNORECASE)









# =============================================================================
#### FUNCTIONS: ####
# =============================================================================































# =============================================================================
#### MAIN: 
# =============================================================================
def main():
    &#34;&#34;&#34;
    Hauptprogramm. Steuert den Gesamt-Ablauf des Scripts. 
    Die meisten Methoden sind innerhalb der Superklasse Procedure definiert.
    &#34;&#34;&#34;

    &#34;&#34;&#34;
    # REFACTORING: In MetaData.initialize_class

    # HACK: path for Source-vba-code
    # input_file_path = &#34;input_data/beispiel_modul.bas&#34;
    # input_file_path = &#34;input_data/beispiel_modul1.bas&#34;
    input_file_path = &#34;input_data/beispiel_modul2.bas&#34;

    MetaData.set_input_path(input_file_path)

    &#34;&#34;&#34;
    

    # initialize the class including reading the input file:
    Procedure.initialize_input_code(MetaData.get_input_path())


    #  Identifizieren und Speichern der Deklarationszeilen von Prozeduren:
    Procedure.identify_procedures()



    # Detail-Analyse und Speicherung einzelner Bestandteile in Objekten:
    Procedure.detail_analyse_procedures()



    &#34;&#34;&#34;
    # REFACTORING: In MetaData.initialize_class
    # 
    # Schreibe die Datei erst in eine Markdown-Datei:
    output_dir = &#34;output_data/demo_output.md&#34;
    MetaData.set_output_dir(output_dir)

    &#34;&#34;&#34;


    Procedure.finilize(MetaData.get_output_path())




    # Generiere HTML Datei from Markdown:
    if CONVERT_TO_HTML:
        markdown.markdownFromFile(
            input=MetaData.get_output_path(extension=&#34;.md&#34;),
            output=MetaData.get_output_path(extension=&#34;.html&#34;), 
            encoding=&#34;utf8&#34;
        )

        print(&#34;HTML-Datei wurde aus MD-Datei generiert.&#34;)
        



    print(chr(13), &#39;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ENDE.&#39;)









if __name__ == &#39;__main__&#39;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="code_documenter.db"><code class="name flex">
<span>def <span class="ident">db</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"><p>Schleust zum printen durch - nur zum Debuggen</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def db(*args):
    &#34;&#34;&#34;
    Schleust zum printen durch - nur zum Debuggen
    &#34;&#34;&#34;
    if DEBUG == False:
        return
    
    print(&#34;__DEBUG_PRINT__\n&#34;)
    for _ in args:
        print(_)</code></pre>
</details>
</dd>
<dt id="code_documenter.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Hauptprogramm. Steuert den Gesamt-Ablauf des Scripts.
Die meisten Methoden sind innerhalb der Superklasse Procedure definiert.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    &#34;&#34;&#34;
    Hauptprogramm. Steuert den Gesamt-Ablauf des Scripts. 
    Die meisten Methoden sind innerhalb der Superklasse Procedure definiert.
    &#34;&#34;&#34;

    &#34;&#34;&#34;
    # REFACTORING: In MetaData.initialize_class

    # HACK: path for Source-vba-code
    # input_file_path = &#34;input_data/beispiel_modul.bas&#34;
    # input_file_path = &#34;input_data/beispiel_modul1.bas&#34;
    input_file_path = &#34;input_data/beispiel_modul2.bas&#34;

    MetaData.set_input_path(input_file_path)

    &#34;&#34;&#34;
    

    # initialize the class including reading the input file:
    Procedure.initialize_input_code(MetaData.get_input_path())


    #  Identifizieren und Speichern der Deklarationszeilen von Prozeduren:
    Procedure.identify_procedures()



    # Detail-Analyse und Speicherung einzelner Bestandteile in Objekten:
    Procedure.detail_analyse_procedures()



    &#34;&#34;&#34;
    # REFACTORING: In MetaData.initialize_class
    # 
    # Schreibe die Datei erst in eine Markdown-Datei:
    output_dir = &#34;output_data/demo_output.md&#34;
    MetaData.set_output_dir(output_dir)

    &#34;&#34;&#34;


    Procedure.finilize(MetaData.get_output_path())




    # Generiere HTML Datei from Markdown:
    if CONVERT_TO_HTML:
        markdown.markdownFromFile(
            input=MetaData.get_output_path(extension=&#34;.md&#34;),
            output=MetaData.get_output_path(extension=&#34;.html&#34;), 
            encoding=&#34;utf8&#34;
        )

        print(&#34;HTML-Datei wurde aus MD-Datei generiert.&#34;)
        



    print(chr(13), &#39;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ENDE.&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="code_documenter.AutoCallMeta"><code class="flex name class">
<span>class <span class="ident">AutoCallMeta</span></span>
<span>(</span><span>name, bases, attrs)</span>
</code></dt>
<dd>
<div class="desc"><p>Sofern diese Klasse als metaclass für eine andere Klasse verwendet wird, wird die unten aufgeführte Klassenmethode direkt nach Definition ohne ein zusätzlichen, expliziten Aufruf automatisch aufgerufen.</p>
<p>Dazu muss nur der Name der aufzurufenden Methode in der Klassenvariable 'class_name_to_call_implicit' parametrisiert werden.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AutoCallMeta(type):
    &#34;&#34;&#34;
    Sofern diese Klasse als metaclass für eine andere Klasse verwendet wird, wird die unten aufgeführte Klassenmethode direkt nach Definition ohne ein zusätzlichen, expliziten Aufruf automatisch aufgerufen.

    Dazu muss nur der Name der aufzurufenden Methode in der Klassenvariable &#39;class_name_to_call_implicit&#39; parametrisiert werden.
    &#34;&#34;&#34;    
    class_name_to_call_implicit = &#34;initialize_class&#34; # NUR HIER ZU PARAMETRISIEREN!
    
    def __init__(cls, name, bases, attrs):
        super().__init__(name, bases, attrs)
        func_name  = AutoCallMeta.class_name_to_call_implicit

        # Aufruf der relevanten Methode, sofern sie vorhanden ist:
        if hasattr(cls, func_name):
            func = getattr(cls, func_name)
            # Aufruf:
            func()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.type</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="code_documenter.AutoCallMeta.class_name_to_call_implicit"><code class="name">var <span class="ident">class_name_to_call_implicit</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="code_documenter.Function"><code class="flex name class">
<span>class <span class="ident">Function</span></span>
<span>(</span><span>text_lines: tuple[str])</span>
</code></dt>
<dd>
<div class="desc"><p>Subklasse für eine VBA-Sub-Prozedur.
U.a. wird hier auch der von der Superklasse vor-initialisierte Regex-Ausdruck konkretisiert und kompiliert, der im VBA-Syntax für den Beginn und das Ende der Prozedurart erforderlich ist.</p>
<p>Die meisten Methoden sind in der übergeordneten Superklasse gelagert, da sie vom Ablauf fuer VBA-Subs und VBA-Methoden identisch sind.</p>
<p>Erstellt ein Prozedur-Objekt, wodurch die einzelnen Komponenten des Codes gesucht und gespeichert werden.
Uebergeben muss ein beliebig grosses Tuple, wobei jedes Element davon den String einre einzelnen Zeile dieser Prozedur enthaelt.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text_lines</code></strong> :&ensp;<code>tuple[str]</code></dt>
<dd>Tuple mit den einzelnen Textzeilen, die zu der relevaten
Prozedur gehoeren.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Function(Procedure):
    &#34;&#34;&#34;
    Subklasse für eine VBA-Sub-Prozedur.
    U.a. wird hier auch der von der Superklasse vor-initialisierte Regex-Ausdruck konkretisiert und kompiliert, der im VBA-Syntax für den Beginn und das Ende der Prozedurart erforderlich ist.

    Die meisten Methoden sind in der übergeordneten Superklasse gelagert, da sie vom Ablauf fuer VBA-Subs und VBA-Methoden identisch sind.

    &#34;&#34;&#34;

    matches_line_ixs = []
    instances = []
    
    all_procedures_final = [] # Liste wird erst nach Identifizierung aller Prozeduren erstellt. Sie dient der Sortierung  der Instanzen basierend auf der alphabetischen Reihenfolge ihrer Prozedur-Bezeichnungen
    
    KEYWORD_TYPE = &#34;Function&#34; 
    
    TEMPLATE_SECTION_HEAD = &#34;templates/sec_functions.md&#34;
    
    
    # Konkretisierung und Kompilierung der Regex-Ausdrücke:

    regex_begin = re.compile(Procedure.regex_begin_pattern.replace(&#34;PLACEHOLDER_PROCEDURE_TYPE&#34;, KEYWORD_TYPE), re.VERBOSE | re.IGNORECASE)


    regex_end = re.compile(Procedure.regex_end_pattern.replace(&#34;PLACEHOLDER_PROCEDURE_TYPE&#34;, KEYWORD_TYPE), re.VERBOSE | re.IGNORECASE)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="code_documenter.Procedure" href="#code_documenter.Procedure">Procedure</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="code_documenter.Function.KEYWORD_TYPE"><code class="name">var <span class="ident">KEYWORD_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="code_documenter.Function.TEMPLATE_SECTION_HEAD"><code class="name">var <span class="ident">TEMPLATE_SECTION_HEAD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="code_documenter.Function.all_procedures_final"><code class="name">var <span class="ident">all_procedures_final</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="code_documenter.Function.instances"><code class="name">var <span class="ident">instances</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="code_documenter.Function.matches_line_ixs"><code class="name">var <span class="ident">matches_line_ixs</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="code_documenter.Function.regex_begin"><code class="name">var <span class="ident">regex_begin</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="code_documenter.Function.regex_end"><code class="name">var <span class="ident">regex_end</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="code_documenter.Procedure" href="#code_documenter.Procedure">Procedure</a></b></code>:
<ul class="hlist">
<li><code><a title="code_documenter.Procedure.analyse_references" href="#code_documenter.Procedure.analyse_references">analyse_references</a></code></li>
<li><code><a title="code_documenter.Procedure.check_and_get_match" href="#code_documenter.Procedure.check_and_get_match">check_and_get_match</a></code></li>
<li><code><a title="code_documenter.Procedure.detail_analyse_procedures" href="#code_documenter.Procedure.detail_analyse_procedures">detail_analyse_procedures</a></code></li>
<li><code><a title="code_documenter.Procedure.extract_docstring" href="#code_documenter.Procedure.extract_docstring">extract_docstring</a></code></li>
<li><code><a title="code_documenter.Procedure.extract_line_numbers" href="#code_documenter.Procedure.extract_line_numbers">extract_line_numbers</a></code></li>
<li><code><a title="code_documenter.Procedure.extract_modifier" href="#code_documenter.Procedure.extract_modifier">extract_modifier</a></code></li>
<li><code><a title="code_documenter.Procedure.extract_name" href="#code_documenter.Procedure.extract_name">extract_name</a></code></li>
<li><code><a title="code_documenter.Procedure.extract_references" href="#code_documenter.Procedure.extract_references">extract_references</a></code></li>
<li><code><a title="code_documenter.Procedure.extract_source_code" href="#code_documenter.Procedure.extract_source_code">extract_source_code</a></code></li>
<li><code><a title="code_documenter.Procedure.finilize" href="#code_documenter.Procedure.finilize">finilize</a></code></li>
<li><code><a title="code_documenter.Procedure.generate_calling_entries" href="#code_documenter.Procedure.generate_calling_entries">generate_calling_entries</a></code></li>
<li><code><a title="code_documenter.Procedure.generate_documentation" href="#code_documenter.Procedure.generate_documentation">generate_documentation</a></code></li>
<li><code><a title="code_documenter.Procedure.generate_reference_entries" href="#code_documenter.Procedure.generate_reference_entries">generate_reference_entries</a></code></li>
<li><code><a title="code_documenter.Procedure.generate_toc_entries" href="#code_documenter.Procedure.generate_toc_entries">generate_toc_entries</a></code></li>
<li><code><a title="code_documenter.Procedure.identify_docstring" href="#code_documenter.Procedure.identify_docstring">identify_docstring</a></code></li>
<li><code><a title="code_documenter.Procedure.identify_procedures" href="#code_documenter.Procedure.identify_procedures">identify_procedures</a></code></li>
<li><code><a title="code_documenter.Procedure.initialize_input_code" href="#code_documenter.Procedure.initialize_input_code">initialize_input_code</a></code></li>
<li><code><a title="code_documenter.Procedure.initialize_page_top_text" href="#code_documenter.Procedure.initialize_page_top_text">initialize_page_top_text</a></code></li>
<li><code><a title="code_documenter.Procedure.initialize_toc" href="#code_documenter.Procedure.initialize_toc">initialize_toc</a></code></li>
<li><code><a title="code_documenter.Procedure.read_template" href="#code_documenter.Procedure.read_template">read_template</a></code></li>
<li><code><a title="code_documenter.Procedure.regex_end_pattern" href="#code_documenter.Procedure.regex_end_pattern">regex_end_pattern</a></code></li>
<li><code><a title="code_documenter.Procedure.search_end_of_procedure" href="#code_documenter.Procedure.search_end_of_procedure">search_end_of_procedure</a></code></li>
<li><code><a title="code_documenter.Procedure.sort_procedures_by_names" href="#code_documenter.Procedure.sort_procedures_by_names">sort_procedures_by_names</a></code></li>
<li><code><a title="code_documenter.Procedure.write_to_file" href="#code_documenter.Procedure.write_to_file">write_to_file</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="code_documenter.MetaData"><code class="flex name class">
<span>class <span class="ident">MetaData</span></span>
</code></dt>
<dd>
<div class="desc"><p>In dieser Klasse werden hauptsächlich Daten gespeichert, die später als Art MetaDaten angesehen werden können.
Der Parent-class / metaclass sorgt dafür, dass direkt nach Implementierung dieser (gewöhnlichen) Klasse eine in der metaclass parametrisierte Methode aufgerufen wird.
Somit ist kein expliziter Aufruf der Klassenmethode MetaData.initialize_class erforderlich, da dies über die metaclass erledigt wird.</p>
<h1 id="todo-die-klasse-ist-noch-nicht-fertig">TODO: Die Klasse ist noch nicht fertig.</h1>
<p>Zu den hierin gespeicherten Daten gehören z. B.:</p>
<ul>
<li>Dieses Dokumentations-Tool-Script<ul>
<li>Versionsinformationen, basierend auf dem letzten Git-Commit</li>
<li>TODO: Versionsnummer dieses Scriptes&hellip;</li>
</ul>
</li>
<li>Das zu dokumentierende Modul<ul>
<li>Dateipfad</li>
<li>Dateiname</li>
<li>Datum der letzten Speicherung / Änderung</li>
</ul>
</li>
<li>Aktuellen Zeitstempel zur Angabe des Zeitpunktes der Dokumentation</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetaData(metaclass=AutoCallMeta):
    &#34;&#34;&#34;
    In dieser Klasse werden hauptsächlich Daten gespeichert, die später als Art MetaDaten angesehen werden können.
    Der Parent-class / metaclass sorgt dafür, dass direkt nach Implementierung dieser (gewöhnlichen) Klasse eine in der metaclass parametrisierte Methode aufgerufen wird.
    Somit ist kein expliziter Aufruf der Klassenmethode MetaData.initialize_class erforderlich, da dies über die metaclass erledigt wird.

    # TODO: Die Klasse ist noch nicht fertig.

    Zu den hierin gespeicherten Daten gehören z. B.:

    - Dieses Dokumentations-Tool-Script
        - Versionsinformationen, basierend auf dem letzten Git-Commit
        - TODO: Versionsnummer dieses Scriptes...
    - Das zu dokumentierende Modul
        - Dateipfad
        - Dateiname
        - Datum der letzten Speicherung / Änderung
    - Aktuellen Zeitstempel zur Angabe des Zeitpunktes der Dokumentation
      
    &#34;&#34;&#34;


    __input_path:str = None
    __output_dir:str = None


    @classmethod
    def get_input_path(cls) -&gt; str:
        return cls.__input_path
    
    
    @classmethod
    def get_input_filename(cls) -&gt; str:
        return cls.__input_filename
    
    
    
    @classmethod
    def get_output_filename(cls) -&gt; str:
        return cls.__output_filename
    
    

    @staticmethod
    def get_last_modified_timestamp(file_path) -&gt; str:
        # Den Zeitstempel der letzten Änderung der Datei auslesen
        timestamp = os.path.getmtime(file_path)
        
        # Den Zeitstempel in ein lesbares Datum umwandeln
        last_modified_datetime = datetime.fromtimestamp(timestamp)
        
        # Das Datum im gewünschten Format ausgeben
        formatted_date = last_modified_datetime.strftime(&#39;%Y-%m-%d %H:%M&#39;)
        
        return formatted_date





    @classmethod
    def extract_date_of_change(cls):
        &#34;&#34;&#34;
        Liesst das letzte Aenderungsdatum der Input-Datei aus und speichert diese in der Klassenvariable cls.input_file_date_of_change
        &#34;&#34;&#34;

        date_of_change = cls.get_last_modified_timestamp(cls.__input_path)
        cls.input_file__date_of_change = date_of_change






    @classmethod
    def set_input_path(cls, input_path:str=None):
        &#34;&#34;&#34;
        Prüft den optional übergebenen Pfad, ob er existiert und dort eine .bas Datei vorliegt.
        Ist dies nicht der Fall, oder wird kein Pfad übergeben, wird per Input ein neuer Pfad abgefragt. 
        Bis zu einem gültigen Pfad wird die Methode rekursiv aufgerufen.
        Bislang gibt es noch keine Möglichkeit für den Nutzer, die Eingabe abzubrechen (außer Programmabbruch...)

        Args:
            input_path (str, optional): Dateipfad zur .bas-Datei, die dokumenteirt werden soll - als Foreward-Slash und ohne Anführungszeichen. Defaults to None.

        &#34;&#34;&#34;

        if input_path != None:
            if os.path.isfile(input_path):
                if input_path.endswith(&#34;.bas&#34;):
                    cls.__input_path = input_path
                    cls.extract_date_of_change()
                    return
                
        neuer_input = input(&#34;!!! FEHLER !!! Die Angegebene Datei ist keine .bas Datei! Bitte einen gueltigen Pfad zur entsprechenden Datei eingeben (Foreward-Slashes! ohne Anfuehrungszeichen)\n&gt; Ihre Eingabe: &#34;)

        cls.set_input_path(neuer_input)


    @classmethod
    def set_output_dir(cls, output_dir:str=None):
        &#34;&#34;&#34;
        Prüft den optional übergebenen Pfad, ob er existiert und ob dies ein Verzeichnis ist
        Ist dies nicht der Fall, oder wird kein Pfad übergeben, wird per Input ein neuer Pfad abgefragt. 
        Bis zu einem gültigen Pfad wird die Methode rekursiv aufgerufen.
        Bislang gibt es noch keine Möglichkeit für den Nutzer, die Eingabe abzubrechen (außer Programmabbruch...)

        Args:
            output_dir (str, optional): Dateipfad zum Ordner, in dem die generierten Output-Dateien exportiert werden sollen - als Foreward-Slash und ohne Anführungszeichen. Defaults to None.

        &#34;&#34;&#34;

        if output_dir != None:
            if os.path.isdir(output_dir):
                cls.__output_dir = output_dir
                return
        neuer_input = input(&#34;!!! FEHLER !!! Der  angegebene Pfad ist kein gueltiges Verzeichnis. Bitte einen gueltigen Pfad fuer den Export der Output-Dateien  eingeben (Foreward-Slashes! ohne Anfuehrungszeichen)\n&gt; Ihre Eingabe: &#34;)

        cls.set_output_dir(neuer_input)



    # OBSOLET: nicht erforderlich - zur Vorbeugung von Verwendchslung daher auskommenteirt:
    # @classmethod
    # def get_output_dir(cls) -&gt; str:
    #     return cls.__output_dir
    
    


    @staticmethod
    def get_count_of_commits():
        &#34;&#34;&#34;
        ### ACHTUNG: Nicht funktional!!!
        &#34;&#34;&#34;


        cmd = &#34;git rev-list --count HEAD&#34;
        return_ =  subprocess.run(cmd)
        
        db(return_)

        db(str(return_).split(&#34; &#34;)[0])
        # return str(return_).split(&#34; &#34;)[0]
        return str(return_)



    @classmethod
    def extract_git_info(cls):
        info:dict = gitinfo.get_git_info()

        # Übernehme die Infos aus git in die Klasse:
        for key, value in info.items():

            # if not hasattr(cls, key):
            #     # Wenn nicht, erstelle es und weise den Wert zu
            #     setattr(cls, key, value)

            attr_name =  f&#34;documenter_version__{key}&#34;

            setattr(cls, attr_name, value)
            db(getattr(cls, attr_name))




            # bold = &#34;**&#34; if key in keys_bold else &#34;&#34;
            # indent_message = &#34;** \n&gt; **&#34; if key == &#34;message&#34; else &#34; &#34;

            # cls.gitinfo = cls.gitinfo + &#34;- &#34; + bold + key + &#34;:&#34; + indent_message + value + bold  + &#34;\n&#34;





    # @classmethod
    # def git_info_to_str(cls):

    #     info:dict = gitinfo.get_git_info()
    #     cls.gitinfo = &#34;## Infos zum Script, welches für die Erstellung dieser Dokumentation verwendet wurde:\n\n&#34;

    #     keys_bold = [&#34;commit&#34;, &#34;message&#34;, &#34;refs&#34;, &#34;author_date&#34;]


    #     for key, value in info.items():
    #         bold = &#34;**&#34; if key in keys_bold else &#34;&#34;
    #         indent_message = &#34;** \n&gt; **&#34; if key == &#34;message&#34; else &#34; &#34;

    #         cls.gitinfo = cls.gitinfo + &#34;- &#34; + bold + key + &#34;:&#34; + indent_message + value + bold  + &#34;\n&#34;





    @classmethod
    def save_current_timestamp(cls):

        # Aktuelles Datum und Uhrzeit
        current_datetime = datetime.now()

        # Wandele das Datum und die Uhrzeit in einen Zeitstempel um
        current_timestamp = int(current_datetime.timestamp())

        db(f&#34;Current Timestamp: {current_timestamp}&#34;)

        current_datetime.strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)

        cls.date_of_process = current_datetime.strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)







    @classmethod
    def make_output_filename(cls):
        
        cls.__input_filename = os.path.basename(cls.__input_path)
        cls.__output_filename = cls.__input_filename + &#34; - Dokumentation&#34;




    @classmethod
    def get_output_path(cls, extension=&#34;.md&#34;) -&gt; str:
        &#34;&#34;&#34;
        Gibt den gesamten Pfad fuer die neu zu generierende Output-Datei zurueck, inkl. Dateierweiterung.

        Args:
            extension (str, optional): Dateiendung der Output-Dtaei. Defaults to &#34;.md&#34;. Modifizierbar z. B. zu .html oder .txt

        Returns:
            str : Dateipfad
        &#34;&#34;&#34;

        path =  os.path.join(cls.__output_dir, cls.__output_filename + extension)
        return path
    
    




    @classmethod
    def initialize_class(cls):
        &#34;&#34;&#34;
        Diese Methode wird implizit direkt nach Implementierung dieser Klasse aufgerufen.
        Somit muss sie nicht mehr von außen aufgerufen werden.
        Sie initialisiert alle Attribute mit ihren WErten.
        &#34;&#34;&#34;




        # HACK: path for Source-vba-code
        input_file_path = &#34;input_data/beispiel_modul.bas&#34;
        # input_file_path = &#34;input_data/beispiel_modul1.bas&#34;
        # input_file_path = &#34;input_data/beispiel_modul1.bas&#34;
        
        cls.set_input_path(input_file_path)






        # HACK: DIR FOR OAUTPUT
        # Schreibe die Datei erst in eine Markdown-Datei:
        output_dir = &#34;output_data&#34;
        cls.set_output_dir(output_dir)










        # cls.git_info_to_str()
        cls.extract_git_info()
        # cls.count_of_commits = cls.get_count_of_commits()




        cls.save_current_timestamp()


        cls.make_output_filename()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="code_documenter.MetaData.date_of_process"><code class="name">var <span class="ident">date_of_process</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="code_documenter.MetaData.documenter_version__author"><code class="name">var <span class="ident">documenter_version__author</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="code_documenter.MetaData.documenter_version__author_date"><code class="name">var <span class="ident">documenter_version__author_date</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="code_documenter.MetaData.documenter_version__commit"><code class="name">var <span class="ident">documenter_version__commit</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="code_documenter.MetaData.documenter_version__gitdir"><code class="name">var <span class="ident">documenter_version__gitdir</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="code_documenter.MetaData.documenter_version__message"><code class="name">var <span class="ident">documenter_version__message</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="code_documenter.MetaData.documenter_version__parent"><code class="name">var <span class="ident">documenter_version__parent</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="code_documenter.MetaData.documenter_version__refs"><code class="name">var <span class="ident">documenter_version__refs</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="code_documenter.MetaData.documenter_version__tree"><code class="name">var <span class="ident">documenter_version__tree</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="code_documenter.MetaData.input_file__date_of_change"><code class="name">var <span class="ident">input_file__date_of_change</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="code_documenter.MetaData.extract_date_of_change"><code class="name flex">
<span>def <span class="ident">extract_date_of_change</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Liesst das letzte Aenderungsdatum der Input-Datei aus und speichert diese in der Klassenvariable cls.input_file_date_of_change</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def extract_date_of_change(cls):
    &#34;&#34;&#34;
    Liesst das letzte Aenderungsdatum der Input-Datei aus und speichert diese in der Klassenvariable cls.input_file_date_of_change
    &#34;&#34;&#34;

    date_of_change = cls.get_last_modified_timestamp(cls.__input_path)
    cls.input_file__date_of_change = date_of_change</code></pre>
</details>
</dd>
<dt id="code_documenter.MetaData.extract_git_info"><code class="name flex">
<span>def <span class="ident">extract_git_info</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def extract_git_info(cls):
    info:dict = gitinfo.get_git_info()

    # Übernehme die Infos aus git in die Klasse:
    for key, value in info.items():

        # if not hasattr(cls, key):
        #     # Wenn nicht, erstelle es und weise den Wert zu
        #     setattr(cls, key, value)

        attr_name =  f&#34;documenter_version__{key}&#34;

        setattr(cls, attr_name, value)
        db(getattr(cls, attr_name))




        # bold = &#34;**&#34; if key in keys_bold else &#34;&#34;
        # indent_message = &#34;** \n&gt; **&#34; if key == &#34;message&#34; else &#34; &#34;

        # cls.gitinfo = cls.gitinfo + &#34;- &#34; + bold + key + &#34;:&#34; + indent_message + value + bold  + &#34;\n&#34;</code></pre>
</details>
</dd>
<dt id="code_documenter.MetaData.get_count_of_commits"><code class="name flex">
<span>def <span class="ident">get_count_of_commits</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="achtung-nicht-funktional">ACHTUNG: Nicht funktional!!!</h3></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_count_of_commits():
    &#34;&#34;&#34;
    ### ACHTUNG: Nicht funktional!!!
    &#34;&#34;&#34;


    cmd = &#34;git rev-list --count HEAD&#34;
    return_ =  subprocess.run(cmd)
    
    db(return_)

    db(str(return_).split(&#34; &#34;)[0])
    # return str(return_).split(&#34; &#34;)[0]
    return str(return_)</code></pre>
</details>
</dd>
<dt id="code_documenter.MetaData.get_input_filename"><code class="name flex">
<span>def <span class="ident">get_input_filename</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_input_filename(cls) -&gt; str:
    return cls.__input_filename</code></pre>
</details>
</dd>
<dt id="code_documenter.MetaData.get_input_path"><code class="name flex">
<span>def <span class="ident">get_input_path</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_input_path(cls) -&gt; str:
    return cls.__input_path</code></pre>
</details>
</dd>
<dt id="code_documenter.MetaData.get_last_modified_timestamp"><code class="name flex">
<span>def <span class="ident">get_last_modified_timestamp</span></span>(<span>file_path) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_last_modified_timestamp(file_path) -&gt; str:
    # Den Zeitstempel der letzten Änderung der Datei auslesen
    timestamp = os.path.getmtime(file_path)
    
    # Den Zeitstempel in ein lesbares Datum umwandeln
    last_modified_datetime = datetime.fromtimestamp(timestamp)
    
    # Das Datum im gewünschten Format ausgeben
    formatted_date = last_modified_datetime.strftime(&#39;%Y-%m-%d %H:%M&#39;)
    
    return formatted_date</code></pre>
</details>
</dd>
<dt id="code_documenter.MetaData.get_output_filename"><code class="name flex">
<span>def <span class="ident">get_output_filename</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_output_filename(cls) -&gt; str:
    return cls.__output_filename</code></pre>
</details>
</dd>
<dt id="code_documenter.MetaData.get_output_path"><code class="name flex">
<span>def <span class="ident">get_output_path</span></span>(<span>extension='.md') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Gibt den gesamten Pfad fuer die neu zu generierende Output-Datei zurueck, inkl. Dateierweiterung.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>extension</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Dateiendung der Output-Dtaei. Defaults to ".md". Modifizierbar z. B. zu .html oder .txt</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str </code></dt>
<dd>Dateipfad</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_output_path(cls, extension=&#34;.md&#34;) -&gt; str:
    &#34;&#34;&#34;
    Gibt den gesamten Pfad fuer die neu zu generierende Output-Datei zurueck, inkl. Dateierweiterung.

    Args:
        extension (str, optional): Dateiendung der Output-Dtaei. Defaults to &#34;.md&#34;. Modifizierbar z. B. zu .html oder .txt

    Returns:
        str : Dateipfad
    &#34;&#34;&#34;

    path =  os.path.join(cls.__output_dir, cls.__output_filename + extension)
    return path</code></pre>
</details>
</dd>
<dt id="code_documenter.MetaData.initialize_class"><code class="name flex">
<span>def <span class="ident">initialize_class</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Diese Methode wird implizit direkt nach Implementierung dieser Klasse aufgerufen.
Somit muss sie nicht mehr von außen aufgerufen werden.
Sie initialisiert alle Attribute mit ihren WErten.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def initialize_class(cls):
    &#34;&#34;&#34;
    Diese Methode wird implizit direkt nach Implementierung dieser Klasse aufgerufen.
    Somit muss sie nicht mehr von außen aufgerufen werden.
    Sie initialisiert alle Attribute mit ihren WErten.
    &#34;&#34;&#34;




    # HACK: path for Source-vba-code
    input_file_path = &#34;input_data/beispiel_modul.bas&#34;
    # input_file_path = &#34;input_data/beispiel_modul1.bas&#34;
    # input_file_path = &#34;input_data/beispiel_modul1.bas&#34;
    
    cls.set_input_path(input_file_path)






    # HACK: DIR FOR OAUTPUT
    # Schreibe die Datei erst in eine Markdown-Datei:
    output_dir = &#34;output_data&#34;
    cls.set_output_dir(output_dir)










    # cls.git_info_to_str()
    cls.extract_git_info()
    # cls.count_of_commits = cls.get_count_of_commits()




    cls.save_current_timestamp()


    cls.make_output_filename()</code></pre>
</details>
</dd>
<dt id="code_documenter.MetaData.make_output_filename"><code class="name flex">
<span>def <span class="ident">make_output_filename</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def make_output_filename(cls):
    
    cls.__input_filename = os.path.basename(cls.__input_path)
    cls.__output_filename = cls.__input_filename + &#34; - Dokumentation&#34;</code></pre>
</details>
</dd>
<dt id="code_documenter.MetaData.save_current_timestamp"><code class="name flex">
<span>def <span class="ident">save_current_timestamp</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def save_current_timestamp(cls):

    # Aktuelles Datum und Uhrzeit
    current_datetime = datetime.now()

    # Wandele das Datum und die Uhrzeit in einen Zeitstempel um
    current_timestamp = int(current_datetime.timestamp())

    db(f&#34;Current Timestamp: {current_timestamp}&#34;)

    current_datetime.strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)

    cls.date_of_process = current_datetime.strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)</code></pre>
</details>
</dd>
<dt id="code_documenter.MetaData.set_input_path"><code class="name flex">
<span>def <span class="ident">set_input_path</span></span>(<span>input_path: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Prüft den optional übergebenen Pfad, ob er existiert und dort eine .bas Datei vorliegt.
Ist dies nicht der Fall, oder wird kein Pfad übergeben, wird per Input ein neuer Pfad abgefragt.
Bis zu einem gültigen Pfad wird die Methode rekursiv aufgerufen.
Bislang gibt es noch keine Möglichkeit für den Nutzer, die Eingabe abzubrechen (außer Programmabbruch&hellip;)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Dateipfad zur .bas-Datei, die dokumenteirt werden soll - als Foreward-Slash und ohne Anführungszeichen. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def set_input_path(cls, input_path:str=None):
    &#34;&#34;&#34;
    Prüft den optional übergebenen Pfad, ob er existiert und dort eine .bas Datei vorliegt.
    Ist dies nicht der Fall, oder wird kein Pfad übergeben, wird per Input ein neuer Pfad abgefragt. 
    Bis zu einem gültigen Pfad wird die Methode rekursiv aufgerufen.
    Bislang gibt es noch keine Möglichkeit für den Nutzer, die Eingabe abzubrechen (außer Programmabbruch...)

    Args:
        input_path (str, optional): Dateipfad zur .bas-Datei, die dokumenteirt werden soll - als Foreward-Slash und ohne Anführungszeichen. Defaults to None.

    &#34;&#34;&#34;

    if input_path != None:
        if os.path.isfile(input_path):
            if input_path.endswith(&#34;.bas&#34;):
                cls.__input_path = input_path
                cls.extract_date_of_change()
                return
            
    neuer_input = input(&#34;!!! FEHLER !!! Die Angegebene Datei ist keine .bas Datei! Bitte einen gueltigen Pfad zur entsprechenden Datei eingeben (Foreward-Slashes! ohne Anfuehrungszeichen)\n&gt; Ihre Eingabe: &#34;)

    cls.set_input_path(neuer_input)</code></pre>
</details>
</dd>
<dt id="code_documenter.MetaData.set_output_dir"><code class="name flex">
<span>def <span class="ident">set_output_dir</span></span>(<span>output_dir: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Prüft den optional übergebenen Pfad, ob er existiert und ob dies ein Verzeichnis ist
Ist dies nicht der Fall, oder wird kein Pfad übergeben, wird per Input ein neuer Pfad abgefragt.
Bis zu einem gültigen Pfad wird die Methode rekursiv aufgerufen.
Bislang gibt es noch keine Möglichkeit für den Nutzer, die Eingabe abzubrechen (außer Programmabbruch&hellip;)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>output_dir</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Dateipfad zum Ordner, in dem die generierten Output-Dateien exportiert werden sollen - als Foreward-Slash und ohne Anführungszeichen. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def set_output_dir(cls, output_dir:str=None):
    &#34;&#34;&#34;
    Prüft den optional übergebenen Pfad, ob er existiert und ob dies ein Verzeichnis ist
    Ist dies nicht der Fall, oder wird kein Pfad übergeben, wird per Input ein neuer Pfad abgefragt. 
    Bis zu einem gültigen Pfad wird die Methode rekursiv aufgerufen.
    Bislang gibt es noch keine Möglichkeit für den Nutzer, die Eingabe abzubrechen (außer Programmabbruch...)

    Args:
        output_dir (str, optional): Dateipfad zum Ordner, in dem die generierten Output-Dateien exportiert werden sollen - als Foreward-Slash und ohne Anführungszeichen. Defaults to None.

    &#34;&#34;&#34;

    if output_dir != None:
        if os.path.isdir(output_dir):
            cls.__output_dir = output_dir
            return
    neuer_input = input(&#34;!!! FEHLER !!! Der  angegebene Pfad ist kein gueltiges Verzeichnis. Bitte einen gueltigen Pfad fuer den Export der Output-Dateien  eingeben (Foreward-Slashes! ohne Anfuehrungszeichen)\n&gt; Ihre Eingabe: &#34;)

    cls.set_output_dir(neuer_input)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="code_documenter.Procedure"><code class="flex name class">
<span>class <span class="ident">Procedure</span></span>
<span>(</span><span>text_lines: tuple[str])</span>
</code></dt>
<dd>
<div class="desc"><p>Allgemeine Klasse zur Bereitstellung von Inhalten, die fuer alle Prozeduren (Subs und Functions) erforderlich sind. Dazu gehoert:</p>
<pre><code>• Definition des Dateipfades fuer Template, in die der extrahierte Text übernommen wird

• Flag-Variable, ob nach Beginn oder Ende der Prozedur gesucht wird

• Regex-Muster als String für den Beginn und das Ende einer Prozedur - wobei innerhalb dieses Strings der Platzhalter für die Prozedurart in den Subklassen noch ersetzt werden muss. Ebenfalls
</code></pre>
<p>Erstellt ein Prozedur-Objekt, wodurch die einzelnen Komponenten des Codes gesucht und gespeichert werden.
Uebergeben muss ein beliebig grosses Tuple, wobei jedes Element davon den String einre einzelnen Zeile dieser Prozedur enthaelt.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text_lines</code></strong> :&ensp;<code>tuple[str]</code></dt>
<dd>Tuple mit den einzelnen Textzeilen, die zu der relevaten
Prozedur gehoeren.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Procedure():
    &#34;&#34;&#34;
    Allgemeine Klasse zur Bereitstellung von Inhalten, die fuer alle Prozeduren (Subs und Functions) erforderlich sind. Dazu gehoert:
        
        • Definition des Dateipfades fuer Template, in die der extrahierte Text übernommen wird
        
        • Flag-Variable, ob nach Beginn oder Ende der Prozedur gesucht wird
        
        • Regex-Muster als String für den Beginn und das Ende einer Prozedur - wobei innerhalb dieses Strings der Platzhalter für die Prozedurart in den Subklassen noch ersetzt werden muss. Ebenfalls
    &#34;&#34;&#34;

    # TEMPLATE = &#34;templates/prozedur.md&#34;
    # HACK: für weiterentwicklung bzgl abruffolge:
    TEMPLATE = &#34;templates/prozedur_dev.md&#34;


    search_for_begin = True # initialer wErt




    # TODO: Das wäre eig. schöner wenn sie private vars sind...

    # Das folgenden Regex-Muster berücksichtigt nicht das Auskommentieren dieser Zeile
    regex_begin_pattern = r&#34;&#34;&#34;.*     # Start mit beliebigen Zeichen
                        (?:Private|Public|Friend)?
                        (?:PLACEHOLDER_PROCEDURE_TYPE)    # Beinhaltet das KEyword
                        \s+        # mind. 1 bis n Leerzeichen
                        (\w+)        # mind. 1 bis n Wortzeichen
                        \(         # Geöffnete Klammer
                        &#34;&#34;&#34;



    # BUGFIX: Besonders beim Beispielmmodul 1 wird zu früh beendet! Neue Regex &gt; V. 0.1.2
    regex_end_pattern = r&#34;&#34;&#34;.*?     # Start mit beliebigen Zeichen
                        (?:End)    # Beinhaltet das KEyword
                        \s+        # mind. 1 bis n Leerzeichen
                        (?:PLACEHOLDER_PROCEDURE_TYPE)    # Beinhaltet das KEyword
                        \s+         # mind. 1 bis n Leerzeichen
                        .*&#34;&#34;&#34;
    


    &#39;&#39;&#39;
    # ALT: Bis Version 0.1.1:
    regex_end_pattern = r&#34;&#34;&#34;.*?     # Start mit beliebigen Zeichen
                        (?:End)    # Beinhaltet das KEyword
                        \s+        # mind. 1 bis n Leerzeichen
                        (?:PLACEHOLDER_PROCEDURE_TYPE)?    # Beinhaltet das KEyword
                        .*&#34;&#34;&#34;
    &#39;&#39;&#39;






    # Zum späteren Prüfen bzgl. Auskommentierung extra Regex:
    __regex_ausschlus_kommentar_pattern = r&#34;&#34;&#34;&#39;    # KommentarApostroph
                                        .?       # Beliebiges Zeichen
                                        &#34;&#34;&#34;

    # Hier ist keine weitere Konkretisierung durch Subklassen erforderlich, daher direkt kompiliert:
    regex_ausschluss_kommentar = re.compile(__regex_ausschlus_kommentar_pattern, re.VERBOSE | re.IGNORECASE)



    @classmethod
    def initialize_input_code(cls, input_path:str):
        &#34;&#34;&#34;
        Liesst den zu analysierenden und zu dokumentierenden Input-Quellcode ein und speichert ihn innerhalb dder Superklasse als immer verfuegbare Liste einzelner Zeileninhalte ab.

        ### TODO: Später sollte hier auch noch eine einfache GUI erstellt werden zur Auswahl!
        ggf. sollte diese GUI aber losgelöst von dieser Klasse sein (Wiederholfunktion!). Daher als Kapselung mit übergebenen input-path!
        &#34;&#34;&#34;

        with open(input_path, &#34;r&#34;) as file:
            cls.raw_source_code = file.readlines()






    @classmethod
    def detail_analyse_procedures(cls):
        &#34;&#34;&#34;
        Detail-Auswertung aller zuvor identifizierten Prozeduren (unabhängig ihrer Art).
        Die einzelnen Komponenten werden dabei in Objekte der Subklassen gespeichert
        &#34;&#34;&#34;

        for procedure_type_cls in [Sub, Function]:

            for line_begin, line_end in procedure_type_cls.matches_line_ixs:

                # db(line_begin, line_end)
                
                # TODO: Bug ausmisten!
                # BUG: sofern nach ein End {procedure_type} in der allerletzten Zeile des Quellcodes steht undn KEINE LEERZEILE FOLGT, isst line_end = None . Das raised einen TypeError: unsupported operand type(s) for +: &#39;NoneType&#39; and &#39;int&#39;
                lines = cls.raw_source_code[line_begin:line_end + 1]

                sub = procedure_type_cls(tuple(lines))



    @classmethod
    # def identify_procedures(cls, list_of_code_lines:list[str]):
    def identify_procedures(cls):
        &#34;&#34;&#34;
        Identifizieren  aller Prozeduren (Methoden und Funktione) auf Klassenebene und Speichern der Zeilennummern der Deklarations- und End-Zeilen innerhalb der jeweiligen Klassenvariablen.

        Durchsucht werden die einzelnen Strings der als Liste übergebenen Zeileninhalte des Quellcodes.

        Args:
            raws (list[str]): Liste mit einem Eintrag pro Zeile des Quellcodes

        &#34;&#34;&#34;

        for ix, text in enumerate(cls.raw_source_code):

            # db(text)

            if cls.search_for_begin:

                if Sub.check_and_get_match(text, ix):
                    current_procedure_type_cls = Sub
                    continue

                if Function.check_and_get_match(text, ix):
                    current_procedure_type_cls = Function


            else:
                # Suche nach dem entsprechend passenden Ende
                current_procedure_type_cls.search_end_of_procedure(text, ix)



            













    @classmethod
    def check_and_get_match(cls, text:str, line_no:int) -&gt; bool:
        &#34;&#34;&#34;
        Prüft eine einzelne Zeile eines Codes (den übergebenen text), ob es sich um ein Match einer Deklarationszeile handelt, und auch, ob diese NICHT-auskommentiert ist. Sofern dies der Fall ist, wird dieses MAtch in die Liste der MAtsches aufgenommen.

        Args:
            text (str): Zu prüfender Text ausschnitt
            line_no (int) : Zeilennummer der Liste an gesamt zu untersuchenden Zeilen

        Returns:
            bool: True falls das match aufgenommen wurde
        &#34;&#34;&#34;

        if cls.regex_begin.match(text):
            if not cls.regex_ausschluss_kommentar.match(text):
                # Dann aufnehmen in die Liste der MAtches! inkl. Platzhalter für Endzeilennummer:
                cls.matches_line_ixs.append([line_no, None])
                Procedure.search_for_begin = False

                return True
        
        return False






    @classmethod
    def search_end_of_procedure(cls, text:str, line_no:int) -&gt; bool:
        &#34;&#34;&#34;
        Prüft eine einzelne Zeile eines Codes (den übergebenen text), ob es sich um ein Match einer Deklarations-END-zeile handelt, und auch, ob diese NICHT-auskommentiert ist. Sofern dies der Fall ist, wird dieses MAtch in die Liste der MAtsches aufgenommen.

        Args:
            text (str): Zu prüfender Text ausschnitt
            line_no (int) : Zeilennummer der Liste an gesamt zu untersuchenden Zeilen

        Returns:
            bool: True falls das match aufgenommen wurde
        &#34;&#34;&#34;

        
        # BUG: Durch die Regex wird aber auch etwas wie End sub  gefunden obwohl es um end function geht! Daher wurde der PRogrammablauf im main angepasst, um sicherzustellen, dass immer nach der richtigen Klassen-Beendigung gesucht wird... Falls Langeweile: Später mal schauen warum...
        if cls.regex_end.match(text):
            if not cls.regex_ausschluss_kommentar.match(text):
                # Dann aufnehmen in die Liste der MAtches!
                cls.matches_line_ixs[-1][-1] = line_no

                Procedure.search_for_begin = True

                return True
        
        return False


    


    @classmethod
    def initialize_page_top_text(cls):
        &#34;&#34;&#34;
        Initialisiert den Text für den Markdown-Text des  Headers der Seite und speichert es in der Klassenvariable cls.head. 
        Zugriff erfolgt über die Superklasse Procedure. 

        
        &#34;&#34;&#34;

        page_top_text = cls.__read_template(&#34;templates/sec_head.md&#34;)

        # Gesamtanzahl an verfügbaren prozeduren je Art einsetzen:
        placeholder_replacer = {
            &#34;@PLACEHOLDER_INPUT_FILE@&#34; : MetaData.get_input_filename(),
            &#34;@PLACEHOLDER_TIMESTAMP_NOW@&#34; : MetaData.date_of_process,
            &#34;@PLACEHOLDER_TIMESTAMP_SOURCEFILE@&#34; : MetaData.input_file__date_of_change,
        }


        for placeholder, replacer in placeholder_replacer.items():
            page_top_text = page_top_text.replace(placeholder, str(replacer))

        cls.page_top_text = page_top_text
        




    @classmethod
    def initialize_toc(cls):
        &#34;&#34;&#34;
        Initialisiert den Text für den Markdown-Text des  Table of content und speichert es in der Klassenvariable cls.toc. Zugriff erfolgt über die Superklasse Procedure. 
        Innerhalb des resultierenden Textes sind weiterhin jeweils 1 Platzhalter fuer jede Prozedur-Art vorhanden. Diese werden spaeter gesondert ersetzt.
        &#34;&#34;&#34;

        toc = cls.__read_template(&#34;templates/sec_toc.md&#34;)

        # Gesamtanzahl an verfügbaren prozeduren je Art einsetzen:
        placeholder_replacer = {
            &#34;@PLACEHOLDER_SUBS_COUNTS@&#34; : len(Sub.instances),
            &#34;@PLACEHOLDER_FUNCTIONS_COUNTS@&#34; : len(Function.instances),
        }


        for placeholder, replacer in placeholder_replacer.items():
            toc = toc.replace(placeholder, str(replacer))

        cls.toc = toc
        






    @classmethod
    def generate_toc_entries(cls, subklasse):
        &#34;&#34;&#34;
        
        Generiert die Einzelnen Eintraege aller Prozeduren der uebergebenen subklasse und fuegt diese in die Klassenvariable cls.toc ein, indem Platzhalter verwendet werden.
        
        Zugriff auf Superklassen-Ebene


        Args:
            subklasse (Sub | Function): Klasse, die aktuell gelistet werden soll
        &#34;&#34;&#34;


        toc = cls.toc # shortcut

        keyword_type = subklasse.KEYWORD_TYPE.upper()
        platzhalter = f&#34;@PLACEHOLDER_ENTRIES_{keyword_type}S@&#34;
        

        for (prozedur_obj, prozedur_name, prozedur_initialisierungszeile) in subklasse.all_procedures_final:

            # Iterieren ueber jede Instanz:

            # TODO: Vorgehen wenn es KEINE instanz gibt???! - sollte kein Problem sein, dadurch dass nach jedem Einfügen immer wieder der Ausgangszustand bzgl. des Platzhalters wiederhergestellt wird un dieser am Ende gelöscht wird??!

            # Aufbau des Markdown.-Codes fuer diesen TOC-Eintrag:
            new_entry = &#34;* [```{temp_prozedur_name}```](#{temp_prozedur_name}) &lt;small&gt;(Zeile {temp_prozedur_zeile})&lt;/small&gt;&#34;.format(temp_prozedur_name=prozedur_name, temp_prozedur_zeile=prozedur_initialisierungszeile)

            # Append the placeholder to have this flag for insert further entries:
            new_entry = new_entry + &#34;\n  &#34; + platzhalter
            # ACHTUNG: Leerzeichen vorweg sind relevant fuer korrekte Einrueckung im MArkdown!


            toc = toc.replace(platzhalter, new_entry)


        # After all procedures of 1 type: Delete the leaving placeholder in the toc for this type of procedures.
        toc = toc.replace(platzhalter, &#34;&#34;)

        # store into class-variable:
        cls.toc = toc

        













    @classmethod
    def analyse_references(cls):
        &#34;&#34;&#34;
        Zugriff erfolgt über die Superklasse Procedure. Innerhalb der Methode wird ueber jedes Objekt jeder Subklasse iterriert.

        Zur Vereinfachung wird eine neue Klassenvariable auf Superklassen-Ebene erstellt, in der alle Elemente der beiden gleichnamigen Listen der einzelnen Subklassen Sub und Function.all_procedures_final enthalten sind. Diese Liste ist sortiert nach aufsteigender Zeilennummer.

        Es wird dann nach Referenzierungen (Aufrufen) jeder Einzelnen Prozedur im gesamten Quelltext gesucht. Bei einem gefundenen Match wird weiter identifiziert, innerhalb welcher uebergeordneten Prozedur dieser Aufruf erfolgte. 
        Fuer jedes Objekt wird eine Objektvariable (Liste) references erstellt, die initial leer ist und bei gefundenen Matches jeweils mit einem Tuple der folgenden Form erweitert wird: (line_no, bezeichnung_uebergeordnete_prozedur, zeilentext_des_aufrufes)

        &#34;&#34;&#34;

        # ERstellung der gemeinsamen Liste auf Superklassen-Ebene:
        all_procedures = Sub.all_procedures_final + Function.all_procedures_final


        # Sortierung der neuen Liste: Basierend auf der Zeilen-Nummer der Deklarationszeile
        cls.all_procedures_final = sorted(all_procedures, key=lambda stored_tuple: stored_tuple[2])


        for (prozedur_obj, prozedur_name, prozedur_initialisierungszeile) in cls.all_procedures_final:

            # Erstellen einer Objektvariable: Liste fuer alle noch zu findenen Referenzierungen:
            prozedur_obj.references = []
            
            &#34;&#34;&#34;
            # DEBUG:
            # BEISPIELERGEBNIS:
                # prozedur_obj = &lt;__main__.Function object at 0x0000018180C603A0&gt;
                # prozedur_name = &#34;addieren&#34;
                # prozedur_initialisierungszeile = 24

            &#34;&#34;&#34;
            
            # ACHTUNG: Die folgende regex matcht zwar NICHT etwas wie &#39; Prozedurname, aber ohne das Leerzeichen (&#39;Prozedurname) wird fälschlicherweise immer noch gematcht! Daher nach dem matschen einfach nochmal prüfen, ob VOR dem ProcName noch ein &#39; steht... dann entnehme das Matsch wieder (ähnliches Vorgehensweise wie bei der Identifizierung von Procedures-Deklarationen...). 
            # regex_ansatz = re.compile(r&#34;(?&lt;!(&#39;.*))(\W{___PROC_NAME___}\W)&#34;.format(___PROC_NAME___=prozedur_name))
            # ACHTUNG: Durch diese Einschränkung brauche ich EH diese Kontrolle, daher wird jetzt doch eine regex verwendet, die das Auskommentieren GAR NICHT berücksichtigt, somit werden auch alle auskommentierten Aufrufe gematcht... Dafür wird stattdessen direkt mit berücksichtigt, dass Deklarationszeilen NICHT gematcht werden sollen! Eine einzelne Abfrage hierzu ist also nicht mehr erforderlich!
            # regex = re.compile(r&#34;(?&lt;!(Function|Sub))\W{___PROC_NAME___}\W&#34;.format(___PROC_NAME___=prozedur_name))
            # regex = re.compile(r&#34;\b(!Function|Sub\b)\W{___PROC_NAME___}\W&#34;.format(___PROC_NAME___=prozedur_name))
            
            
            
            regex_call = re.compile(r&#34;\bcall\s+{___PROC_NAME___}\b&#34;.format(___PROC_NAME___=prozedur_name))



            # Folgende macht leider einen erroer .  im &#34;normalen &#34; regex geht es, in python.re nicht:
            # regex_brackets = re.compile(r&#34;(?&lt;!((Function|Sub).*))({___PROC_NAME___}\()&#34;.format(___PROC_NAME___=prozedur_name))

            # ACHTUNG: es wird hiermit DOCH NICHT ABGEFANGEN, dass die Deklarationszeile nicht gematcht wird! die muss also später noch raus kommen!
            regex_brackets = re.compile(r&#34;\b{___PROC_NAME___}\(&#34;.format(___PROC_NAME___=prozedur_name))



            # Durchsuche den GESAMTEN QUELLTEXT nach einem Aufruf dieser Prozedur:
            for line_no, line_text in enumerate(cls.raw_source_code, 1):



                # db(&#34;gesuchte Methode:&#34;, prozedur_name, &#34;Line-Nr = &#34;, line_no, &#34;  :  &#34;, line_text)


                if line_no == prozedur_initialisierungszeile:
                    # Dann ist dies die  Deklarationszeile der Funktion, zu der die Aufrufe gefunden werden sollen - also ignorieren!
                    continue



                if not (match:=regex_brackets.search(line_text)):
                    # Kein Aufruf mittels ...PROZEDURNAME(...
                    if not (match:=regex_call.search(line_text)):
                        # Kein Aufruf mittels ...Call PROZEDURNAME...

                        continue
                
                
                # TODO: Backreference auf die Gruppe mit dem Sub-Namen (kenie backref nötig, da es ja EH nur nach dieser gesucht wird!)
                ziel_prozedur_name = prozedur_name
                # db(match)
                    


                # An dieser Stelle ist match IMMER != None:
                # db(match)

                # Check wheather there is a comment-symbol before the procedure name:
                __prozedur_name_start_pos = match.span()[0]
                if (cls.regex_ausschluss_kommentar.search(line_text[0:__prozedur_name_start_pos])):
                    # Dann kommentar
                    continue


                # Hier ist eine tatsächlicher Aufruf gefunden worden, der jetzt dokumentiert werden muss:
                # JEtzt muss der Aufruf dokumentiert werdn!
                


                # ACHTUNG:  WICHTIG:  Der folgende Schritt / die Logik und Anwendung war mir neu  -  nochmal recherchieren! sowohl mit dem filtern / nach eigenem Key, als auch, dass das Ergebnis nicht DIE EINZELNE ZAHL  ist, sondern tatsächlich direkt das TUPLE, IN DEM DIESE EINZELNE ZAHL GESPEICHERT IST!  Extrem praktich!!!!

                
                # Logik zum Finden der aufrufenden Prozedur: Die Deklarationszeilennummer muss &lt; line_no sein. Die nächste dran ist die Zeilennummer der Deklarationszeile
                aufrufende_prozedur_tuple_relevant = [tpl for tpl in cls.all_procedures_final if tpl[2] &lt; line_no]

                # Das relevante Tuple der Liste cls.all_procedures_final wird in der selben Form gespeichert in der folgenden Variable:
                aufrufende_prozedur_tuple = min(aufrufende_prozedur_tuple_relevant, key=lambda x_tuple: abs(x_tuple[2] - line_no))


                # prozedur_obj.references.append((line_no, aufrufende_prozedur_tuple[1], line_text))

                #Erweiterung um den Prozedurnamen, der aufgerufen wird:
                # ziel_prozedur_name = &#34;&#34;

                prozedur_obj.references.append((line_no, aufrufende_prozedur_tuple[1], line_text, ziel_prozedur_name))



                
                &#34;&#34;&#34;
                # _BUGFIX: Fehlerhafte Zuordnung! ERLEDIGT + OK IN V. &gt;= 0.2.0

                Aktuelle Parameter im scope:
                    line_no = 68
                    aufrufende_prozedur_tuple[1] = &#34;bauer&#34; # _BUGFIX: SOLLTE MAIN SEIN!!!!!


                &#34;&#34;&#34;

                # db(prozedur_obj.references)





    @classmethod
    def finilize(cls, output_file_path:str):
        &#34;&#34;&#34;
        ### TODO: Ob wirklich alles hier in die Klasse gehört ist fraglich! 
        
        Zugriff erfolgt über die Superklasse Procedure. Innerhalb der MEthode wird wiederum in Schleifen itteriert ueber die Subklassen.
        
        Bereitet die finale Ausgabe vor und ruft weitere MEthoden zum Schreiben dieser Ausgabe / der Markdown-Datei auf.
        Zu dieser Vorbereitung gehört:
         
            • Sortierung der einzelnen Prozeduren innerhalb der verschiedenen Prozedur-Arten gemaess der alphabetischen Reihenfolge ihrer Bezeichner (Namen)
            
            • Konfigurieren / Initilalisierung der Zwischenüberschriften / Header-Texte unterhalb der einzelnen Section-Überschriften (gespeichert in Klassenvariable cls.header)


        Args:
            output_file_path (str): Dateipfad der zu erstellenden Markdown-Datei
        &#34;&#34;&#34;





        cls.initialize_page_top_text()


        # =============================================================================
        #### # Extrahiere den Modulweiten Docstring (sofern es einen gibt): ####
        # =============================================================================
        
        # Beginne erst ab Zeile 1 wegen der Codierungszeichen!
        __modul_docstring = cls.identify_docstring(cls.raw_source_code[1:], trim_empty_rows=True, return_alternativ_text=True)
        __template_docstring = cls.__read_template(&#34;templates/sec_modulinfos.md&#34;)
        # Ersetze Platzhalter in der Template durch gefundenen Docstring:
        cls.modul_docstring = __template_docstring.replace(&#34;@PLACEHOLDER_MODUL_DOCSTRING@&#34;, __modul_docstring)

        
        






        # Vorbereitung des TOCS:
        cls.initialize_toc()




        for procedure_type_cls in [Sub, Function]: 



            # Initialisieren des Headers unterhalb der Section-Überschrift  (aus gesonderter Template) und in Klassenvariable speichern:
            content = cls.__read_template(procedure_type_cls.TEMPLATE_SECTION_HEAD)

            cls.header = content





            # Instanzen der Prozeduren  Alphabetisch  sortieren nach den Namen! und in Klassenvariable speichern:
            procedure_type_cls.sort_procedures_by_names()


            # Ergänze einen einzigen Eintrag für eine Methode! und haenge sie dem TOC an
            # WICHTIG: Auf Superklassen-Ebene!
            cls.generate_toc_entries(procedure_type_cls)

        
        # Durchsuche gesamten Quelltext nach allen Referenzierungen für jeweils alle gefundenen Prozeduren und speichere sie in den jeweiligen Objekten der einzelnen Prozeduren:
        cls.analyse_references()

        # JULIA: Diese Referenzierungen müssen jetzt noch in die Template prozedur.md eingebaut werden! Aktuell erfolgt das alles inkl. der Auswertung in der Methode write_to_file

        # TODO: Diese Referenzierungen müssen jetzt noch in die Template prozedur.md eingebaut werden! Aktuell erfolgt das alles inkl. der Auswertung in der Methode write_to_file










        # Aufruf der Methode zum tatsächlichen Schreiben der Textdatei:
        cls.write_to_file(output_file_path)



    
    def generate_calling_entries(self) -&gt; None:
        &#34;&#34;&#34;
        # TODO: # JULIA                                         
        mitten in dev.

        ansatz vorhanden



        Generiert die Dokumentatoin der Abrufsequenzen / Abruffolgen.
        Speichert das Ergebnis in der bereits existierenden Objektvariable procedure_obj.documentation
        &#34;&#34;&#34;


        # TODO                                                                      
        # JULIA                                                                     
        &#34;&#34;&#34;
        
        MÖGLICHE HERANGEHENSWEISEN


        - Vorgehensweise A:
            - Durchsuche gesamten Code DIESER Prozedur nach einem Aufruf einre Prozedur, die hier bereits bekannt ist (via regex)

        - Vorgehensweise B:
            -  Durchsuche alle OBJEKT-INSTANZEN aller Prozeduren beim key=References und schaue, ob eine zeilennummer der referenzierung innerhalb der zeilennummer dieser prozedur hier liegt.
            - scheint mir der entwicklungs-technisch schnellere weg zu sein...
            - bei langen programmen mit vielen prozeduren ist es besonders ineffizient, je kürzer die HIER TATSÄCHLICH GERADE zu dokumentierende funktion ist, aber das ist mir mal egal....
            - Vorteil: keine regex entwicklung / duplikat wie bei references!


        &#34;&#34;&#34;

        &#34;&#34;&#34;
        # Referenzierungs-zeile muss hierzwischen liegen:
        self.line_begin
        self.line_end







        &#34;&#34;&#34;

        # TODO: Extrahiere alle Referenzierungen dazwischen:
        db(&#34;...&#34;)

        self.calling_sequences = []

        # bei hauptfunc1 --&gt; soll 2 einträge: unterfunkntionA + B
        
        Procedure.all_procedures_final
        # liste mit exemplarischen einzel-Eintrag: 
        # (procedure_obj, procedure_name, procedure_line )



        for (procedure_obj, uebergeordnete_prozedur_name, procedure_declaration_line_no) in Procedure.all_procedures_final:

            &#34;&#34;&#34;
            # iterater = 6 # schleifenzähler pro prozedur
            # einzelprozedur = Procedure.all_procedures_final[iterater][0]
            # ENTSPRICHT JETZT:
            procedure_obj

            procedure_obj.references
            # liste mit exemplarischen einzel-Eintrag: 
            # (line_nr_aufruf, &#34;uebergeordnetes_sub&#34;, code)
            &#34;&#34;&#34;
            
            # SCHNELLERER ANSATZ:
            # Filtern der liste, so dass uebergeordnetes_sub == name
            # dann fertig!

            relevante_references = [_ for _ in procedure_obj.references if uebergeordnete_prozedur_name == self.name]

            for (line_no_reference, uebergeordnetes_sub, code, ziel_prozedur_name) in relevante_references:

                self.calling_sequences.append((line_no_reference, uebergeordnetes_sub, code, ziel_prozedur_name)) # relevant ist nur der name aus der regex im cod
                # TODO: ??? ggf doch nicht nötig? Bei erstellung dieses tupels bei analyse der referenzen --&gt; speichere auch das ziel, aleso den subname
            

            &#34;&#34;&#34;
            # ALTER ALTERNATIVER ANSATZ:

            # ist line_nr zwischen self.line.begin + self.line.end der ZU DOKUMENTIERENDEN Prozedur??
            for (line_no_reference, uebergeordnetes_sub, code) in procedure_obj.references:
                if line_no_reference &lt; self.line_begin:
                    continue
                if line_no_reference &gt; self.line_end:
                    continue
                # SONST: liegt es darin!!! AUFNEHMEN IN LISTE!!!!

                self.calling_sequences.append((line_no_reference, uebergeordnetes_sub, code))
            &#34;&#34;&#34;



                # TODO:  Am Ende vor der dokumentation die liste noch sortieren aufsteigend nach line_no_reference konzeptionell identisch wie im index/toc

                # JULIA: LOGIK FALSCH????
            db(self.calling_sequences)


            _PLACEHOLDER_REFERENCE = &#34;@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@&#34;

            # TODO: ersetze im doc:
            doc = self.documentation

    


            # Initialisierung und  Parametrisierung  des Einleitungssatzes:
            einleitungssatz = &#34;Keine weiteren Aufrufe zu hier dokumentierten Prozeduren gefunden.&#34; # default

            if len(self.calling_sequences) &gt; 0:

                einleitungssatz = &#34;Innehalb der Prozedur werden die folgenden, untergeordneten Prozeduren aufgerufen:&#34;

            for (line_no_reference, uebergeordnetes_sub, line_code, target_procedure_name) in self.calling_sequences:


                # TODO:
                # HACK:
                target_procedure_name = &#34;main&#34;



                replacer_placeholder_reference = f&#34;&lt;small&gt;  Zeile {line_no_reference} &lt;/small&gt; : ```{line_code}``` ODER: {target_procedure_name}&#34;
                # replacer_placeholder_reference = f&#34;* [```{code}```](#{target_procedure}) : &lt;small&gt;  Zeile {line_no_reference} : ```{line_code}``` &lt;/small&gt;&#34;

                replacer_placeholder_reference = replacer_placeholder_reference  + f&#34;\n{_PLACEHOLDER_REFERENCE}&#34;
                    
                # Ersetzen:
                doc = doc.replace(_PLACEHOLDER_REFERENCE, replacer_placeholder_reference)

                    
            # Loeschen des verbliebenen Platzhalters zum Einfuegen einzelner Referenzen:
            doc = doc.replace(_PLACEHOLDER_REFERENCE, &#34;&#34;)



            # Einsetzen des Einleitungssatzes:
            doc = doc.replace(&#34;@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@&#34;, einleitungssatz)


            # shortcut / resubstitution:
            self.documentation = doc




    
    # @classmethod # eigentlich bezieht sich das auf ein einzelnes Objekt!!!
    def generate_reference_entries(self) -&gt; None:
    # def generate_reference_entries(cls, procedure_obj) -&gt; None:
        &#34;&#34;&#34;
        Generiert von dem Objekt der Subklasse Function oder Sub die Dokumentation der Referenzierungen.
        Speichert das Ergebnis in der bereits existierenden Objektvariable procedure_obj.documentation
        &#34;&#34;&#34;



        # TODO: Struktur...? das gehört zu den references... ist eig. statisch, müsste nicht jedes mal beim funktionsaufruf neu gemacht werden, aber so ist es zusammen...
        _PLACEHOLDER_REFERENCE = &#34;@PLACEHOLDER_PROCEDURE_REFERENCES_ENTRY@&#34; 



        # shortcut:
        doc:str = self.documentation 

        # Alle Referenzierungen sind in der Objektvariablen  procedure_obj.references gespeichert:
        count_of_references = len(self.references)

        # ERsetzen des Platzhalters für die Anzahl der Referenzierungen in der bisherigen Dokumentation:
        doc = doc.replace(&#34;@PLACEHOLDER_PROCEDURE_COUNT_OF_REFERENCES@&#34;, str(count_of_references))
        

        # Initialisierung und  Parametrisierung  des Einleitungssatzes:
        einleitungssatz = &#34;Kein Aufruf gefunden.&#34; # default

        if count_of_references &gt; 0:

            einleitungssatz = &#34;Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:&#34;

            
            # Iterrieren ueber jede Referenzierung, um diese zu dokumentieren:
            for (line_no, calling_procedure_name, line_code, target_procedure_name) in self.references:

                # Zusammenbau des Ersatzwertes für den Platzhalter inkl. Anhängen des Platzhalters für weitere Ersetzungen:
                
                # Um MArkdown nicht zu zerschiessen muss der letzte Zeilenumbruch des line_codes entfernt werrden:
                line_code:str = line_code.rstrip(&#34;\n&#34;)

                replacer_placeholder_reference = f&#34;* [```{calling_procedure_name}```](#{calling_procedure_name}) : &lt;small&gt;  Zeile {line_no} : ```{line_code}``` &lt;/small&gt;&#34;


                # # AUSBLICK: weitere collapse details : funktioniert technisch, allerdings steht das collapsable immer in neuer Zeile und daher wird es groß - vielleicht später in schön machen...
                # __replacer_placeholder_reference = f&#34;*   [```{calling_procedure_name}```](#{calling_procedure_name})  &lt;details&gt; &lt;summary&gt;: &lt;small&gt;Zeile {line_no}&lt;/small&gt; &lt;/summary&gt; ```{line_code}``` &lt;/details&gt;&#34;



                replacer_placeholder_reference = replacer_placeholder_reference  + f&#34;\n{_PLACEHOLDER_REFERENCE}&#34;
                
                # Ersetzen:
                doc = doc.replace(_PLACEHOLDER_REFERENCE, replacer_placeholder_reference)


        # Loeschen des verbliebenen Platzhalters zum Einfuegen einzelner Referenzen:
        doc = doc.replace(_PLACEHOLDER_REFERENCE, &#34;&#34;)



        # Einsetzen des Einleitungssatzes:
        doc = doc.replace(&#34;@PLACEHOLDER_PROCEDURE_REFERENCES_INTRODUCTION@&#34;, einleitungssatz)


        # shortcut / resubstitution:
        self.documentation = doc
        
        # TODO: Auslagern in eigene Funktion!     ENDE                       








    @classmethod
    def write_to_file(cls, output_file_path:str):
        &#34;&#34;&#34;
        Schreibt die Dokumentation aller Prozeduren (aller Art) in die als Dateipfad übergebene Zieldatei(pfad).
        &#34;&#34;&#34;



        # initialize_toc



        with open(output_file_path, &#34;w&#34;, ) as file:

            ## TODO: Dies gehört eigentlich nicht mehr in die Klasse Procedure, aber aktuell trotzdem hierher, um alles zusammen zu haben. Ggf.s später refactoring...
            # Initialisiere die Seite mit Titel und organisatorischen Hinweisen:
            content = cls.__read_template(&#34;templates/sec_head.md&#34;)


                                
            # # TEST                                                                                                              
            # # Extrahiere Daten von der Version DIESES DOKUMENTIER-TOOLS:
            # content = MetaData.gitinfo 
            # content = content + &#34;\n&#34;*3 + &#34;Datum der Umwandlung: &#34; + MetaData.date_of_process
                          


            # TODO: Hier muss noch Placeholders ersetzt werden!!&#39;
            file.write(cls.page_top_text)


            #Einfügen des Index / TOCs /  Inhaltsverzeichnis:
            file.write(cls.toc)


            # schreiben der Modulinfos / Docstrings:
            file.write(cls.modul_docstring)





            # # TODO: Struktur...? das gehört zu den references...
            # _PLACEHOLDER_REFERENCE = &#34;@PLACEHOLDER_PROCEDURE_REFERENCES_ENTRY@&#34; 


            for procedure_type_cls in [Sub, Function]: # Reihenfolge wichtig fuer die Reihenfolge der Dokumentierten Sections!


                # Überschrift der Section einfügen (aus gesonderter Template):
                file.write(procedure_type_cls.header)



                # Dokumentieren aller einzelnen Prozeduren:
                for procedur_infos in procedure_type_cls.all_procedures_final:
                # for (procedure_obj, procedure_name, procedure_line) in procedure_type_cls.all_procedures_final:

                    procedure_obj:Procedure = procedur_infos[0]





                    procedure_obj.generate_reference_entries()

                    &#34;&#34;&#34;
                    # TODO: Auslagern in eigene Funktion!     START                        erledigt ab V. 0.2.2

                    # shortcut:
                    doc:str = procedure_obj.documentation 

                    # Alle Referenzierungen sind in der Objektvariablen  procedure_obj.references gespeichert:
                    count_of_references = len(procedure_obj.references)

                    # ERsetzen des Platzhalters für die Anzahl der Referenzierungen in der bisherigen Dokumentation:
                    doc = doc.replace(&#34;@PLACEHOLDER_PROCEDURE_COUNT_OF_REFERENCES@&#34;, str(count_of_references))
                    

                    # Initialisierung und  Parametrisierung  des Einleitungssatzes:
                    einleitungssatz = &#34;Kein Aufruf gefunden.&#34; # default

                    if count_of_references &gt; 0:

                        einleitungssatz = &#34;Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:&#34;

                        
                        # Iterrieren ueber jede Referenzierung, um diese zu dokumentieren:
                        for (line_no, calling_procedure_name, line_code) in procedure_obj.references:

                            # Zusammenbau des Ersatzwertes für den Platzhalter inkl. Anhängen des Platzhalters für weitere Ersetzungen:
                            
                            # Um MArkdown nicht zu zerschiessen muss der letzte Zeilenumbruch des line_codes entfernt werrden:
                            line_code:str = line_code.rstrip(&#34;\n&#34;)

                            replacer_placeholder_reference = f&#34;* [```{calling_procedure_name}```](#{calling_procedure_name}) : &lt;small&gt;  Zeile {line_no} : ```{line_code}``` &lt;/small&gt;&#34;


                            # # AUSBLICK: weitere collapse details : funktioniert technisch, allerdings steht das collapsable immer in neuer Zeile und daher wird es groß - vielleicht später in schön machen...
                            # __replacer_placeholder_reference = f&#34;*   [```{calling_procedure_name}```](#{calling_procedure_name})  &lt;details&gt; &lt;summary&gt;: &lt;small&gt;Zeile {line_no}&lt;/small&gt; &lt;/summary&gt; ```{line_code}``` &lt;/details&gt;&#34;



                            replacer_placeholder_reference = replacer_placeholder_reference  + f&#34;\n{_PLACEHOLDER_REFERENCE}&#34;
                            
                            # Ersetzen:
                            doc = doc.replace(_PLACEHOLDER_REFERENCE, replacer_placeholder_reference)


                    # Loeschen des verbliebenen Platzhalters zum Einfuegen einzelner Referenzen:
                    doc = doc.replace(_PLACEHOLDER_REFERENCE, &#34;&#34;)



                    # Einsetzen des Einleitungssatzes:
                    doc = doc.replace(&#34;@PLACEHOLDER_PROCEDURE_REFERENCES_INTRODUCTION@&#34;, einleitungssatz)


                    # shortcut / resubstitution:
                    procedure_obj.documentation = doc
                    
                    # TODO: Auslagern in eigene Funktion!     ENDE                       


                    &#34;&#34;&#34;


                    # JULIA: Versuche Wiederherstollung des Tails!!!!
                    # procedure_obj.generate_calling_entries()

                    file.write(procedure_obj.documentation)


                # Ausgabe der Zusammenfassung pro Section:
                print(&#34;Es wurden {} {}s identifiziert und dokumentiert.&#34;.format(len(procedure_type_cls.instances), procedure_type_cls.KEYWORD_TYPE))



            ## TODO: Dies gehört eigentlich nicht mehr in die Klasse Procedure, aber aktuell trotzdem hierher, um alles zusammen zu haben. Ggf.s später refactoring...
            # Finalisiere die Seite mit Schlusbemerkungen:
            content = cls.__read_template(&#34;templates/sec_tail.md&#34;)
            # HACK: Nur fuer ENtwicklungsstadium!
            content = content.replace(&#34;@PLACEHOLDER_TIMESTAMP_NOW@&#34;, MetaData.date_of_process)
            content = content.replace(&#34;@PLACEHOLDER_DOC_PYTHON@&#34;, __doc__.replace(&#34;\n&#34;, &#34;&lt;br&gt;&#34;))
            content = content.replace(&#34;@PLACEHOLDER_DOCUMENTER_VERSION__AUTHOR@&#34;, MetaData.documenter_version__author.rstrip(&#34; &lt;_&gt;&#34;))
            content = content.replace(&#34;@PLACEHOLDER_DOCUMENTER_VERSION__COMMIT@&#34;, MetaData.documenter_version__commit)
            content = content.replace(&#34;@PLACEHOLDER_DOCUMENTER_VERSION__DATE@&#34;, MetaData.documenter_version__author_date)

            file.write(content)






    @classmethod
    def sort_procedures_by_names(cls):
        &#34;&#34;&#34;
        Füllen der Klassenvariable der **SUBKLASSE** cls.all_procedures_final mit einem Tupel pro Prozedur, in dem sowohl das einzelne Objekt, als auch seine Bezeichnung und die Zeilennummer der Deklaratrion enthalten ist in der Form [(object:Procedure, object.name:str, object.line_begin)]. 
        Diese Liste wird nach Fertigstellung sortiert basierend auf den alphabetischen Bezeichnern, sodass der Zusammenhang zwischen den Objekten und den Namen weiterhin gegeben ist, gleichzeitig aber die Objekte in der alphabetischen Reihenfolge ihrer Namen dokumentiert werden können.

        &#34;&#34;&#34;

        all_procedures = [] 


        for procedure_obj in cls.instances:
            
            all_procedures.append((procedure_obj, procedure_obj.name, procedure_obj.line_begin))



        # Nach dem Füllen: Sortieren basierend auf den Bezeichner-Namen:
        cls.all_procedures_final = sorted(all_procedures, key=lambda stored_tuple: stored_tuple[1])



        
            













    @staticmethod
    def __read_template(template_file_path) -&gt; str:
        &#34;&#34;&#34;
        Ließt die uebergebene Template-MArkdown Datei ein und gibt den Inhalt als String zurück.
        
        Args:
            template (str) : Dateipfad zur Template

        Return:
            str : Textinhalt der Template
        &#34;&#34;&#34;
        with open(template_file_path, &#34;r&#34;) as file:
            content = file.read()
            return content





    def read_template(self, template=&#34;einzelprozedur&#34;) -&gt; str:
        &#34;&#34;&#34;
        Ließt die relevante Template-MArkdown Datei ein und gibt den Inhalt als String zurück. 
        Sofern es sich um die Default-Template für eine beliebige Prozedur handelt
        wird außerdem auch das Attribut self.documentation mit diesem Text initialisiert.

        Args:
            template (str) : Dateipfad zur Template - Ausnahme: Falls die in der Klasse gespeicherte 
                            Standardtemplate self.TEMPLATE fuer eine Prozedur verwendet werden soll, 
                            dann muss das Stichwort &#34;einzelprozedur&#34; übergeben werden. 
                            Dies ist default der Fall --&gt; keine Angabe erforderlich.

        Return:
            str : Inhalt der Template
        &#34;&#34;&#34;


        if template == &#34;einzelprozedur&#34;:
        
            # Auslesen und Speichern in Objektvariable
            self.documentation = self.__read_template(self.TEMPLATE)
            return self.documentation


        # Bei NICHT-Standard-Prozedur-Template: Auslesen dieser Template und Rückgabe des Textinhaltes:
        content = self.__read_template(template)
        return content





    def generate_documentation(self):
        &#34;&#34;&#34;
        Dokumentiert die gefundenen Parameter unter Nutzung einer Template-Markdown-Textdatei und speichert den zu schreibenden Text im Attribut self.documentation
        &#34;&#34;&#34;

        self.read_template()

        placeholder_replacer = {
            &#34;@PLACEHOLDER_PROCEDURE_TYPE@&#34; : self.KEYWORD_TYPE,
            &#34;@PLACEHOLDER_PROCEDURE_MODIFIER@&#34; : self.modifier,
            &#34;@PLACEHOLDER_PROCEDURE_NAME@&#34; : self.name,
            &#34;@PLACEHOLDER_PROCEDURE_LINE_BEGIN@&#34; : self.line_begin,
            &#34;@PLACEHOLDER_PROCEDURE_DOCSTRING@&#34; : self.docstring,
            &#34;@PLACEHOLDER_PROCEDURE_SOURCE_CODE@&#34; : self.source_code,

            # # TODO:  Kommen die References extra??! Wahrscheinlich schon stand jetzt (Version&gt; 0.1.3)
            # &#34;@PLACEHOLDER_PROCEDURE_REFERENCES@&#34; : self.references,
            # &#34;@PLACEHOLDER_PROCEDURE_COUNT_OF_REFERENCES@&#34; : self.count_of_references,
        }


        for placeholder, replacer in placeholder_replacer.items():
            self.documentation = self.documentation.replace(placeholder, str(replacer))













    def extract_source_code(self):
        &#34;&#34;&#34;
        Ließt den source_code aus und speichert diesen im Attribut self.source_code
        &#34;&#34;&#34;

        source_code = &#34;&#34;
        for line in self.lines:
            source_code = source_code + line

        self.source_code = source_code





    def extract_modifier(self):
        &#34;&#34;&#34;
        Ließt den Modifier aus und speichert diesen im Attribut self.modifier
        &#34;&#34;&#34;
        # Wiederverwendung der Deklarationszeilen-Regex:
        match = self.regex_begin.match(self.lines[0])

        # Entnehme den String bis vor den NAmen:
        pos_name = match.string.find(self.name + &#34;(&#34;)
        potentieller_modifier = match.string[0:pos_name]

        # Identifiziere hieraus den modifier:
        
        # # Eigentlich sollte es schon auf Grundlage der eigentlichen regex gehen, funktioniert aber nicht! Es wird immer was leres zurückgegeben, daher, neue regex! (Bei Zeit mal schauen warum!)
        # # Extraktion der Gruppe mit dem Name: (eigentlicher Ansatz)
        # db(match.groups())
        # modifier = match.group(1)
        
        
        regex_modifier = re.compile(r&#34;((?:Private|Public|Friend)?)&#34;)
        match = regex_modifier.match(potentieller_modifier)
        modifier = match.group(1)


        if modifier == &#34;&#34;:
            modifier = &#34;Public&#34;

        # db(modifier)

        self.modifier = modifier




    def extract_name(self):
        &#34;&#34;&#34;
        Ließt den Bezeichnungsnamen aus und speichert diesen im Attribut self.name
        &#34;&#34;&#34;
        # Wiederverwendung der Deklarationszeilen-Regex:
        
        
        match = self.regex_begin.match(self.lines[0])

        # db(match.groups())
        # Extraktion der Gruppe mit dem Name:
        name = match.group(1)

        # db(name)

        self.name = name



    def extract_line_numbers(self):
        &#34;&#34;&#34;
        Ließt die relevanten Start- und End-Zeilennummern aus und speichert diesen im Attribut self.line_begin und self.line_end
        &#34;&#34;&#34;
        # Hole Index der Instanzenliste, dieser ist gleich dem Index der matches_line_ixs Liste:
        ix = self.instances.index(self) 

        match_lines_ix = self.matches_line_ixs[ix]
        
        self.line_begin = match_lines_ix[0] + 1
        self.line_end = match_lines_ix[1] + 1




    @staticmethod
    def identify_docstring(text_lines:tuple[str], trim_empty_rows=False, return_alternativ_text=False) -&gt; str:
        &#34;&#34;&#34;
        ### ACHTUNG: Entstanden aus der Methode extract_docstring(self), die auf Objektebene anzuwenden ist. 
        Um die gleiche Logik aber auch fuer den modulweiten Docstring nutzen zu koennen, wird dieses Konstrukt eingefuehrt.


        Ließt den ersten Block-KOmmentar / docstring aus und gibt ihn zurueck.
        Als Docstring wird jede Kommentarzeile gewertet, die DIREKT UND OHNE VORHERIGE LEERZEEILE UNTERHALB DER ERSTEN UEBERGEBENEN ZEILE steht. 
        Sobald eine Leerzeile folgt, wird der Docstring als beendet angesehen.

        Beispiel:
                &#39; Dies ist ein Kommentar direkt unter der Deklarationszeile. Somit wird es als Docstring gewertet.
                &#39; Dies auch
                &#39;
                &#39; Da die vorherige Zeile AUCH einen Kommentar (einen leeren) enthält, ist dies hier immer noch Bestandteil des Docstrings.

                &#39; Vor dieser Zeile war ein NICHT-Kommentar, daher gehört das hier nicht mehr zum Docstring
                MsgBox(&#34;Das gehört zum Programm&#34;)
            End Sub

            
        Args:
            text_lines (tuple[str]): Tuple mit den einzelnen Textzeilen, die zu der relevaten  Prozedur gehoeren.
            trim_empty_rows (bool) : False, sofern der Algorithmus direkt bei einer Leerzeile abgebrochen werden soll ( = DEFAULT), 
                                        oder True, falls der Algorithmus bei vorangehenden Leerzeilen solange weiterlaufen soll, bis dass KEINE Leerzeile mehr vorliegt oder eine andere Abbruchsbedingung erreicht ist.
            return_alternativ_text (bool | str) : Default = False. Dann wird beim Nicht-Finden ein leerer String zurückgegeben. 
                                                    Bei True wird in solchen Fällen der in der MEthode definierte Alternativ-ERsatztext zurückgegeben. 
                                                    Bei Übergabe eines Strings wird in diesen Fällen dieser String zurückgegeben.
        Returns:
            str : Docstring / Blockkommentar
        &#34;&#34;&#34;


        docstring  = &#34;&#34;


        for line in text_lines:
            # line:str
            content = line.lstrip(&#34; &#34;)

            if(content[0]) == &#34;&#39;&#34;:
               # gehört zum Docstring
                docstring = docstring + content.lstrip(&#34;&#39;&#34;)
                continue # nächste Zeile


            if trim_empty_rows == False:

                break

            # ELSE: Dann trimme die leere Reihe
            if docstring != &#34;&#34;:
                # Dann gibt es bereits einen Docstring -&gt; Abbruch
                break


            if re.match(r&#34;^\s*\n?$&#34;, content):
                # Dann besteht die Zeile nur aus Whitespaces --&gt; Trimmen!
                # Rekursiver Aufruf dieser Methode mit jeweils einer vordersten Zeile weniger!
                docstring = Procedure.identify_docstring(text_lines[1:], trim_empty_rows=True, return_alternativ_text=False) 
                # TODO: Fehlervermeidung / Grenzfall:  IndexOutOfRange (Ende angekommen, --&gt; docstring vorhanden --&gt; Wird Error geben!
                break



        # =============================================================================
        #### #  Alternativtext bei leeren Docstrings: ####
        # =============================================================================
        
        if return_alternativ_text == True:

            if docstring == &#34;&#34;:
                docstring = &#34;*No information availible. For more information expand source code.*&#34; #  Die Sternchen bewirken im MArkdown ein Kursivdruck

        elif isinstance(return_alternativ_text, str):
            if docstring == &#34;&#34;:
                docstring = return_alternativ_text


        return docstring
  




    def extract_docstring(self):
        &#34;&#34;&#34;
        # CHANGELOG: 2023-12-30 - 03:17:04 Bis V. 0.0.5 war diese Funktion &#39;alleinherschend&#39;. 
        Erst danach  wurde die Durchschleusung zur static method identify_docstring eingeführt,
        um damit auch modulweite Docstrings finden zu koennen.


        Ließt den docstring aus und speichert diesen im Attribut self.docstring
        Sofern kein Docstring im Code identifiziert wurde, wird eine entsprechende Info in den Text geschrieben.

        Als Docstring wird jede Kommentarzeile gewertet, die DIREKT UND OHNE VORHERIGE LEERZEEILE UNTERHALB DER DEKLARIERUNGSZEILE der Prozedur steht. Sobald eine Leerzeile folgt, wird der Docstring als beendet angesehen.

        Beispiel:
            Private Sub beispielProgramm() &#39; Deklarationszeile
                &#39; Dies ist ein Kommentar direkt unter der Deklarationszeile. Somit wird es als Docstring gewertet.
                &#39; Dies auch
                &#39;
                &#39; Da die vorherige Zeile AUCH einen Kommentar (einen leeren) enthält, ist dies hier immer noch Bestandteil des Docstrings.

                &#39; Vor dieser Zeile war ein NICHT-Kommentar, daher gehört das hier nicht mehr zum Docstring
                MsgBox(&#34;Das gehört zum Programm&#34;)
            End Sub
        &#34;&#34;&#34;


        # Docstring ueber generalisierte Methode herausfiltern:
        docstring = self.identify_docstring(self.lines[1:], return_alternativ_text=True)

        # Speichern im Objekt:
        self.docstring = docstring







    def extract_references(self):
        &#34;&#34;&#34;
        ### TODO: Wird aktuell (Version &gt; 0.1.2) ganz wo anders erledigt, ist dort noch nicht optimal - aber um Redundanzen und Verewchslungen vorzubeugen, wird diese Methode erst mal platt gemacht und nicht mehr aufgerufen!

        Später wäre es shcön...
        
        ### ALT: 
        Durchsucht den gesamten Quelltext nach Referenzierungen (Aufrufen) dieser Prozedur und speichert diese im Attribut self.references
        # TODO ALLES
        &#34;&#34;&#34;
        # self.references = &#34; # TODO ... self.references&#34;
        # self.count_of_references = &#34; # TODO ... self.count_of_references&#34;
        pass



    def __init__(self, text_lines:tuple[str]) -&gt; None:
        &#34;&#34;&#34;
        Erstellt ein Prozedur-Objekt, wodurch die einzelnen Komponenten des Codes gesucht und gespeichert werden.
        Uebergeben muss ein beliebig grosses Tuple, wobei jedes Element davon den String einre einzelnen Zeile dieser Prozedur enthaelt.

        Args:
            text_lines (tuple[str]): Tuple mit den einzelnen Textzeilen, die zu der relevaten  Prozedur gehoeren.
        &#34;&#34;&#34;

        # TODO: Ist  dies notwendig???! Eigentlich nicht! Dies ist schon die superklasse!
        super().__init__()

        # Merken der instanc zum späteren Iterieren: Klassenzuweisung dynamisch!
        type(self).instances.append(self)
        
        # Speichern aller Textzeilen:
        self.lines = text_lines




        # =============================================================================
        #### # HErausfiltern einzelner KOmponenten: ####
        # =============================================================================
        
        self.extract_line_numbers()
        self.extract_source_code()
        self.extract_name()
        self.extract_modifier()
        
        self.extract_docstring()




        # TODO:        Muss noch irgendwoghin!                                     
        # self.extract_references()



        # =============================================================================
        #### Zusammenfassen und Schreiben der Dokumentation: ####
        # =============================================================================
        
        self.generate_documentation()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="code_documenter.Function" href="#code_documenter.Function">Function</a></li>
<li><a title="code_documenter.Sub" href="#code_documenter.Sub">Sub</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="code_documenter.Procedure.TEMPLATE"><code class="name">var <span class="ident">TEMPLATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="code_documenter.Procedure.regex_ausschluss_kommentar"><code class="name">var <span class="ident">regex_ausschluss_kommentar</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="code_documenter.Procedure.regex_begin_pattern"><code class="name">var <span class="ident">regex_begin_pattern</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="code_documenter.Procedure.regex_end_pattern"><code class="name">var <span class="ident">regex_end_pattern</span></code></dt>
<dd>
<div class="desc"><h1 id="alt-bis-version-011">ALT: Bis Version 0.1.1:</h1>
<p>regex_end_pattern = r""".<em>?
# Start mit beliebigen Zeichen
(?:End)
# Beinhaltet das KEyword
\s+
# mind. 1 bis n Leerzeichen
(?:PLACEHOLDER_PROCEDURE_TYPE)?
# Beinhaltet das KEyword
.</em>"""</p></div>
</dd>
<dt id="code_documenter.Procedure.search_for_begin"><code class="name">var <span class="ident">search_for_begin</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="code_documenter.Procedure.analyse_references"><code class="name flex">
<span>def <span class="ident">analyse_references</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Zugriff erfolgt über die Superklasse Procedure. Innerhalb der Methode wird ueber jedes Objekt jeder Subklasse iterriert.</p>
<p>Zur Vereinfachung wird eine neue Klassenvariable auf Superklassen-Ebene erstellt, in der alle Elemente der beiden gleichnamigen Listen der einzelnen Subklassen Sub und Function.all_procedures_final enthalten sind. Diese Liste ist sortiert nach aufsteigender Zeilennummer.</p>
<p>Es wird dann nach Referenzierungen (Aufrufen) jeder Einzelnen Prozedur im gesamten Quelltext gesucht. Bei einem gefundenen Match wird weiter identifiziert, innerhalb welcher uebergeordneten Prozedur dieser Aufruf erfolgte.
Fuer jedes Objekt wird eine Objektvariable (Liste) references erstellt, die initial leer ist und bei gefundenen Matches jeweils mit einem Tuple der folgenden Form erweitert wird: (line_no, bezeichnung_uebergeordnete_prozedur, zeilentext_des_aufrufes)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def analyse_references(cls):
    &#34;&#34;&#34;
    Zugriff erfolgt über die Superklasse Procedure. Innerhalb der Methode wird ueber jedes Objekt jeder Subklasse iterriert.

    Zur Vereinfachung wird eine neue Klassenvariable auf Superklassen-Ebene erstellt, in der alle Elemente der beiden gleichnamigen Listen der einzelnen Subklassen Sub und Function.all_procedures_final enthalten sind. Diese Liste ist sortiert nach aufsteigender Zeilennummer.

    Es wird dann nach Referenzierungen (Aufrufen) jeder Einzelnen Prozedur im gesamten Quelltext gesucht. Bei einem gefundenen Match wird weiter identifiziert, innerhalb welcher uebergeordneten Prozedur dieser Aufruf erfolgte. 
    Fuer jedes Objekt wird eine Objektvariable (Liste) references erstellt, die initial leer ist und bei gefundenen Matches jeweils mit einem Tuple der folgenden Form erweitert wird: (line_no, bezeichnung_uebergeordnete_prozedur, zeilentext_des_aufrufes)

    &#34;&#34;&#34;

    # ERstellung der gemeinsamen Liste auf Superklassen-Ebene:
    all_procedures = Sub.all_procedures_final + Function.all_procedures_final


    # Sortierung der neuen Liste: Basierend auf der Zeilen-Nummer der Deklarationszeile
    cls.all_procedures_final = sorted(all_procedures, key=lambda stored_tuple: stored_tuple[2])


    for (prozedur_obj, prozedur_name, prozedur_initialisierungszeile) in cls.all_procedures_final:

        # Erstellen einer Objektvariable: Liste fuer alle noch zu findenen Referenzierungen:
        prozedur_obj.references = []
        
        &#34;&#34;&#34;
        # DEBUG:
        # BEISPIELERGEBNIS:
            # prozedur_obj = &lt;__main__.Function object at 0x0000018180C603A0&gt;
            # prozedur_name = &#34;addieren&#34;
            # prozedur_initialisierungszeile = 24

        &#34;&#34;&#34;
        
        # ACHTUNG: Die folgende regex matcht zwar NICHT etwas wie &#39; Prozedurname, aber ohne das Leerzeichen (&#39;Prozedurname) wird fälschlicherweise immer noch gematcht! Daher nach dem matschen einfach nochmal prüfen, ob VOR dem ProcName noch ein &#39; steht... dann entnehme das Matsch wieder (ähnliches Vorgehensweise wie bei der Identifizierung von Procedures-Deklarationen...). 
        # regex_ansatz = re.compile(r&#34;(?&lt;!(&#39;.*))(\W{___PROC_NAME___}\W)&#34;.format(___PROC_NAME___=prozedur_name))
        # ACHTUNG: Durch diese Einschränkung brauche ich EH diese Kontrolle, daher wird jetzt doch eine regex verwendet, die das Auskommentieren GAR NICHT berücksichtigt, somit werden auch alle auskommentierten Aufrufe gematcht... Dafür wird stattdessen direkt mit berücksichtigt, dass Deklarationszeilen NICHT gematcht werden sollen! Eine einzelne Abfrage hierzu ist also nicht mehr erforderlich!
        # regex = re.compile(r&#34;(?&lt;!(Function|Sub))\W{___PROC_NAME___}\W&#34;.format(___PROC_NAME___=prozedur_name))
        # regex = re.compile(r&#34;\b(!Function|Sub\b)\W{___PROC_NAME___}\W&#34;.format(___PROC_NAME___=prozedur_name))
        
        
        
        regex_call = re.compile(r&#34;\bcall\s+{___PROC_NAME___}\b&#34;.format(___PROC_NAME___=prozedur_name))



        # Folgende macht leider einen erroer .  im &#34;normalen &#34; regex geht es, in python.re nicht:
        # regex_brackets = re.compile(r&#34;(?&lt;!((Function|Sub).*))({___PROC_NAME___}\()&#34;.format(___PROC_NAME___=prozedur_name))

        # ACHTUNG: es wird hiermit DOCH NICHT ABGEFANGEN, dass die Deklarationszeile nicht gematcht wird! die muss also später noch raus kommen!
        regex_brackets = re.compile(r&#34;\b{___PROC_NAME___}\(&#34;.format(___PROC_NAME___=prozedur_name))



        # Durchsuche den GESAMTEN QUELLTEXT nach einem Aufruf dieser Prozedur:
        for line_no, line_text in enumerate(cls.raw_source_code, 1):



            # db(&#34;gesuchte Methode:&#34;, prozedur_name, &#34;Line-Nr = &#34;, line_no, &#34;  :  &#34;, line_text)


            if line_no == prozedur_initialisierungszeile:
                # Dann ist dies die  Deklarationszeile der Funktion, zu der die Aufrufe gefunden werden sollen - also ignorieren!
                continue



            if not (match:=regex_brackets.search(line_text)):
                # Kein Aufruf mittels ...PROZEDURNAME(...
                if not (match:=regex_call.search(line_text)):
                    # Kein Aufruf mittels ...Call PROZEDURNAME...

                    continue
            
            
            # TODO: Backreference auf die Gruppe mit dem Sub-Namen (kenie backref nötig, da es ja EH nur nach dieser gesucht wird!)
            ziel_prozedur_name = prozedur_name
            # db(match)
                


            # An dieser Stelle ist match IMMER != None:
            # db(match)

            # Check wheather there is a comment-symbol before the procedure name:
            __prozedur_name_start_pos = match.span()[0]
            if (cls.regex_ausschluss_kommentar.search(line_text[0:__prozedur_name_start_pos])):
                # Dann kommentar
                continue


            # Hier ist eine tatsächlicher Aufruf gefunden worden, der jetzt dokumentiert werden muss:
            # JEtzt muss der Aufruf dokumentiert werdn!
            


            # ACHTUNG:  WICHTIG:  Der folgende Schritt / die Logik und Anwendung war mir neu  -  nochmal recherchieren! sowohl mit dem filtern / nach eigenem Key, als auch, dass das Ergebnis nicht DIE EINZELNE ZAHL  ist, sondern tatsächlich direkt das TUPLE, IN DEM DIESE EINZELNE ZAHL GESPEICHERT IST!  Extrem praktich!!!!

            
            # Logik zum Finden der aufrufenden Prozedur: Die Deklarationszeilennummer muss &lt; line_no sein. Die nächste dran ist die Zeilennummer der Deklarationszeile
            aufrufende_prozedur_tuple_relevant = [tpl for tpl in cls.all_procedures_final if tpl[2] &lt; line_no]

            # Das relevante Tuple der Liste cls.all_procedures_final wird in der selben Form gespeichert in der folgenden Variable:
            aufrufende_prozedur_tuple = min(aufrufende_prozedur_tuple_relevant, key=lambda x_tuple: abs(x_tuple[2] - line_no))


            # prozedur_obj.references.append((line_no, aufrufende_prozedur_tuple[1], line_text))

            #Erweiterung um den Prozedurnamen, der aufgerufen wird:
            # ziel_prozedur_name = &#34;&#34;

            prozedur_obj.references.append((line_no, aufrufende_prozedur_tuple[1], line_text, ziel_prozedur_name))



            
            &#34;&#34;&#34;
            # _BUGFIX: Fehlerhafte Zuordnung! ERLEDIGT + OK IN V. &gt;= 0.2.0

            Aktuelle Parameter im scope:
                line_no = 68
                aufrufende_prozedur_tuple[1] = &#34;bauer&#34; # _BUGFIX: SOLLTE MAIN SEIN!!!!!


            &#34;&#34;&#34;

            # db(prozedur_obj.references)</code></pre>
</details>
</dd>
<dt id="code_documenter.Procedure.check_and_get_match"><code class="name flex">
<span>def <span class="ident">check_and_get_match</span></span>(<span>text: str, line_no: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Prüft eine einzelne Zeile eines Codes (den übergebenen text), ob es sich um ein Match einer Deklarationszeile handelt, und auch, ob diese NICHT-auskommentiert ist. Sofern dies der Fall ist, wird dieses MAtch in die Liste der MAtsches aufgenommen.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>Zu prüfender Text ausschnitt</dd>
</dl>
<p>line_no (int) : Zeilennummer der Liste an gesamt zu untersuchenden Zeilen</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True falls das match aufgenommen wurde</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def check_and_get_match(cls, text:str, line_no:int) -&gt; bool:
    &#34;&#34;&#34;
    Prüft eine einzelne Zeile eines Codes (den übergebenen text), ob es sich um ein Match einer Deklarationszeile handelt, und auch, ob diese NICHT-auskommentiert ist. Sofern dies der Fall ist, wird dieses MAtch in die Liste der MAtsches aufgenommen.

    Args:
        text (str): Zu prüfender Text ausschnitt
        line_no (int) : Zeilennummer der Liste an gesamt zu untersuchenden Zeilen

    Returns:
        bool: True falls das match aufgenommen wurde
    &#34;&#34;&#34;

    if cls.regex_begin.match(text):
        if not cls.regex_ausschluss_kommentar.match(text):
            # Dann aufnehmen in die Liste der MAtches! inkl. Platzhalter für Endzeilennummer:
            cls.matches_line_ixs.append([line_no, None])
            Procedure.search_for_begin = False

            return True
    
    return False</code></pre>
</details>
</dd>
<dt id="code_documenter.Procedure.detail_analyse_procedures"><code class="name flex">
<span>def <span class="ident">detail_analyse_procedures</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Detail-Auswertung aller zuvor identifizierten Prozeduren (unabhängig ihrer Art).
Die einzelnen Komponenten werden dabei in Objekte der Subklassen gespeichert</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def detail_analyse_procedures(cls):
    &#34;&#34;&#34;
    Detail-Auswertung aller zuvor identifizierten Prozeduren (unabhängig ihrer Art).
    Die einzelnen Komponenten werden dabei in Objekte der Subklassen gespeichert
    &#34;&#34;&#34;

    for procedure_type_cls in [Sub, Function]:

        for line_begin, line_end in procedure_type_cls.matches_line_ixs:

            # db(line_begin, line_end)
            
            # TODO: Bug ausmisten!
            # BUG: sofern nach ein End {procedure_type} in der allerletzten Zeile des Quellcodes steht undn KEINE LEERZEILE FOLGT, isst line_end = None . Das raised einen TypeError: unsupported operand type(s) for +: &#39;NoneType&#39; and &#39;int&#39;
            lines = cls.raw_source_code[line_begin:line_end + 1]

            sub = procedure_type_cls(tuple(lines))</code></pre>
</details>
</dd>
<dt id="code_documenter.Procedure.finilize"><code class="name flex">
<span>def <span class="ident">finilize</span></span>(<span>output_file_path: str)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="todo-ob-wirklich-alles-hier-in-die-klasse-gehort-ist-fraglich">TODO: Ob wirklich alles hier in die Klasse gehört ist fraglich!</h3>
<p>Zugriff erfolgt über die Superklasse Procedure. Innerhalb der MEthode wird wiederum in Schleifen itteriert ueber die Subklassen.</p>
<p>Bereitet die finale Ausgabe vor und ruft weitere MEthoden zum Schreiben dieser Ausgabe / der Markdown-Datei auf.
Zu dieser Vorbereitung gehört:</p>
<pre><code>• Sortierung der einzelnen Prozeduren innerhalb der verschiedenen Prozedur-Arten gemaess der alphabetischen Reihenfolge ihrer Bezeichner (Namen)

• Konfigurieren / Initilalisierung der Zwischenüberschriften / Header-Texte unterhalb der einzelnen Section-Überschriften (gespeichert in Klassenvariable cls.header)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>output_file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>Dateipfad der zu erstellenden Markdown-Datei</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def finilize(cls, output_file_path:str):
    &#34;&#34;&#34;
    ### TODO: Ob wirklich alles hier in die Klasse gehört ist fraglich! 
    
    Zugriff erfolgt über die Superklasse Procedure. Innerhalb der MEthode wird wiederum in Schleifen itteriert ueber die Subklassen.
    
    Bereitet die finale Ausgabe vor und ruft weitere MEthoden zum Schreiben dieser Ausgabe / der Markdown-Datei auf.
    Zu dieser Vorbereitung gehört:
     
        • Sortierung der einzelnen Prozeduren innerhalb der verschiedenen Prozedur-Arten gemaess der alphabetischen Reihenfolge ihrer Bezeichner (Namen)
        
        • Konfigurieren / Initilalisierung der Zwischenüberschriften / Header-Texte unterhalb der einzelnen Section-Überschriften (gespeichert in Klassenvariable cls.header)


    Args:
        output_file_path (str): Dateipfad der zu erstellenden Markdown-Datei
    &#34;&#34;&#34;





    cls.initialize_page_top_text()


    # =============================================================================
    #### # Extrahiere den Modulweiten Docstring (sofern es einen gibt): ####
    # =============================================================================
    
    # Beginne erst ab Zeile 1 wegen der Codierungszeichen!
    __modul_docstring = cls.identify_docstring(cls.raw_source_code[1:], trim_empty_rows=True, return_alternativ_text=True)
    __template_docstring = cls.__read_template(&#34;templates/sec_modulinfos.md&#34;)
    # Ersetze Platzhalter in der Template durch gefundenen Docstring:
    cls.modul_docstring = __template_docstring.replace(&#34;@PLACEHOLDER_MODUL_DOCSTRING@&#34;, __modul_docstring)

    
    






    # Vorbereitung des TOCS:
    cls.initialize_toc()




    for procedure_type_cls in [Sub, Function]: 



        # Initialisieren des Headers unterhalb der Section-Überschrift  (aus gesonderter Template) und in Klassenvariable speichern:
        content = cls.__read_template(procedure_type_cls.TEMPLATE_SECTION_HEAD)

        cls.header = content





        # Instanzen der Prozeduren  Alphabetisch  sortieren nach den Namen! und in Klassenvariable speichern:
        procedure_type_cls.sort_procedures_by_names()


        # Ergänze einen einzigen Eintrag für eine Methode! und haenge sie dem TOC an
        # WICHTIG: Auf Superklassen-Ebene!
        cls.generate_toc_entries(procedure_type_cls)

    
    # Durchsuche gesamten Quelltext nach allen Referenzierungen für jeweils alle gefundenen Prozeduren und speichere sie in den jeweiligen Objekten der einzelnen Prozeduren:
    cls.analyse_references()

    # JULIA: Diese Referenzierungen müssen jetzt noch in die Template prozedur.md eingebaut werden! Aktuell erfolgt das alles inkl. der Auswertung in der Methode write_to_file

    # TODO: Diese Referenzierungen müssen jetzt noch in die Template prozedur.md eingebaut werden! Aktuell erfolgt das alles inkl. der Auswertung in der Methode write_to_file










    # Aufruf der Methode zum tatsächlichen Schreiben der Textdatei:
    cls.write_to_file(output_file_path)</code></pre>
</details>
</dd>
<dt id="code_documenter.Procedure.generate_toc_entries"><code class="name flex">
<span>def <span class="ident">generate_toc_entries</span></span>(<span>subklasse)</span>
</code></dt>
<dd>
<div class="desc"><p>Generiert die Einzelnen Eintraege aller Prozeduren der uebergebenen subklasse und fuegt diese in die Klassenvariable cls.toc ein, indem Platzhalter verwendet werden.</p>
<p>Zugriff auf Superklassen-Ebene</p>
<h2 id="args">Args</h2>
<p>subklasse (Sub | Function): Klasse, die aktuell gelistet werden soll</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def generate_toc_entries(cls, subklasse):
    &#34;&#34;&#34;
    
    Generiert die Einzelnen Eintraege aller Prozeduren der uebergebenen subklasse und fuegt diese in die Klassenvariable cls.toc ein, indem Platzhalter verwendet werden.
    
    Zugriff auf Superklassen-Ebene


    Args:
        subklasse (Sub | Function): Klasse, die aktuell gelistet werden soll
    &#34;&#34;&#34;


    toc = cls.toc # shortcut

    keyword_type = subklasse.KEYWORD_TYPE.upper()
    platzhalter = f&#34;@PLACEHOLDER_ENTRIES_{keyword_type}S@&#34;
    

    for (prozedur_obj, prozedur_name, prozedur_initialisierungszeile) in subklasse.all_procedures_final:

        # Iterieren ueber jede Instanz:

        # TODO: Vorgehen wenn es KEINE instanz gibt???! - sollte kein Problem sein, dadurch dass nach jedem Einfügen immer wieder der Ausgangszustand bzgl. des Platzhalters wiederhergestellt wird un dieser am Ende gelöscht wird??!

        # Aufbau des Markdown.-Codes fuer diesen TOC-Eintrag:
        new_entry = &#34;* [```{temp_prozedur_name}```](#{temp_prozedur_name}) &lt;small&gt;(Zeile {temp_prozedur_zeile})&lt;/small&gt;&#34;.format(temp_prozedur_name=prozedur_name, temp_prozedur_zeile=prozedur_initialisierungszeile)

        # Append the placeholder to have this flag for insert further entries:
        new_entry = new_entry + &#34;\n  &#34; + platzhalter
        # ACHTUNG: Leerzeichen vorweg sind relevant fuer korrekte Einrueckung im MArkdown!


        toc = toc.replace(platzhalter, new_entry)


    # After all procedures of 1 type: Delete the leaving placeholder in the toc for this type of procedures.
    toc = toc.replace(platzhalter, &#34;&#34;)

    # store into class-variable:
    cls.toc = toc</code></pre>
</details>
</dd>
<dt id="code_documenter.Procedure.identify_docstring"><code class="name flex">
<span>def <span class="ident">identify_docstring</span></span>(<span>text_lines: tuple[str], trim_empty_rows=False, return_alternativ_text=False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><h3 id="achtung-entstanden-aus-der-methode-extract_docstringself-die-auf-objektebene-anzuwenden-ist">ACHTUNG: Entstanden aus der Methode extract_docstring(self), die auf Objektebene anzuwenden ist.</h3>
<p>Um die gleiche Logik aber auch fuer den modulweiten Docstring nutzen zu koennen, wird dieses Konstrukt eingefuehrt.</p>
<p>Ließt den ersten Block-KOmmentar / docstring aus und gibt ihn zurueck.
Als Docstring wird jede Kommentarzeile gewertet, die DIREKT UND OHNE VORHERIGE LEERZEEILE UNTERHALB DER ERSTEN UEBERGEBENEN ZEILE steht.
Sobald eine Leerzeile folgt, wird der Docstring als beendet angesehen.</p>
<h2 id="beispiel">Beispiel</h2>
<pre><code>' Dies ist ein Kommentar direkt unter der Deklarationszeile. Somit wird es als Docstring gewertet.
' Dies auch
'
' Da die vorherige Zeile AUCH einen Kommentar (einen leeren) enthält, ist dies hier immer noch Bestandteil des Docstrings.

' Vor dieser Zeile war ein NICHT-Kommentar, daher gehört das hier nicht mehr zum Docstring
MsgBox("Das gehört zum Programm")
</code></pre>
<p>End Sub</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text_lines</code></strong> :&ensp;<code>tuple[str]</code></dt>
<dd>Tuple mit den einzelnen Textzeilen, die zu der relevaten
Prozedur gehoeren.</dd>
</dl>
<p>trim_empty_rows (bool) : False, sofern der Algorithmus direkt bei einer Leerzeile abgebrochen werden soll ( = DEFAULT),
oder True, falls der Algorithmus bei vorangehenden Leerzeilen solange weiterlaufen soll, bis dass KEINE Leerzeile mehr vorliegt oder eine andere Abbruchsbedingung erreicht ist.
return_alternativ_text (bool | str) : Default = False. Dann wird beim Nicht-Finden ein leerer String zurückgegeben.
Bei True wird in solchen Fällen der in der MEthode definierte Alternativ-ERsatztext zurückgegeben.
Bei Übergabe eines Strings wird in diesen Fällen dieser String zurückgegeben.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str </code></dt>
<dd>Docstring / Blockkommentar</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def identify_docstring(text_lines:tuple[str], trim_empty_rows=False, return_alternativ_text=False) -&gt; str:
    &#34;&#34;&#34;
    ### ACHTUNG: Entstanden aus der Methode extract_docstring(self), die auf Objektebene anzuwenden ist. 
    Um die gleiche Logik aber auch fuer den modulweiten Docstring nutzen zu koennen, wird dieses Konstrukt eingefuehrt.


    Ließt den ersten Block-KOmmentar / docstring aus und gibt ihn zurueck.
    Als Docstring wird jede Kommentarzeile gewertet, die DIREKT UND OHNE VORHERIGE LEERZEEILE UNTERHALB DER ERSTEN UEBERGEBENEN ZEILE steht. 
    Sobald eine Leerzeile folgt, wird der Docstring als beendet angesehen.

    Beispiel:
            &#39; Dies ist ein Kommentar direkt unter der Deklarationszeile. Somit wird es als Docstring gewertet.
            &#39; Dies auch
            &#39;
            &#39; Da die vorherige Zeile AUCH einen Kommentar (einen leeren) enthält, ist dies hier immer noch Bestandteil des Docstrings.

            &#39; Vor dieser Zeile war ein NICHT-Kommentar, daher gehört das hier nicht mehr zum Docstring
            MsgBox(&#34;Das gehört zum Programm&#34;)
        End Sub

        
    Args:
        text_lines (tuple[str]): Tuple mit den einzelnen Textzeilen, die zu der relevaten  Prozedur gehoeren.
        trim_empty_rows (bool) : False, sofern der Algorithmus direkt bei einer Leerzeile abgebrochen werden soll ( = DEFAULT), 
                                    oder True, falls der Algorithmus bei vorangehenden Leerzeilen solange weiterlaufen soll, bis dass KEINE Leerzeile mehr vorliegt oder eine andere Abbruchsbedingung erreicht ist.
        return_alternativ_text (bool | str) : Default = False. Dann wird beim Nicht-Finden ein leerer String zurückgegeben. 
                                                Bei True wird in solchen Fällen der in der MEthode definierte Alternativ-ERsatztext zurückgegeben. 
                                                Bei Übergabe eines Strings wird in diesen Fällen dieser String zurückgegeben.
    Returns:
        str : Docstring / Blockkommentar
    &#34;&#34;&#34;


    docstring  = &#34;&#34;


    for line in text_lines:
        # line:str
        content = line.lstrip(&#34; &#34;)

        if(content[0]) == &#34;&#39;&#34;:
           # gehört zum Docstring
            docstring = docstring + content.lstrip(&#34;&#39;&#34;)
            continue # nächste Zeile


        if trim_empty_rows == False:

            break

        # ELSE: Dann trimme die leere Reihe
        if docstring != &#34;&#34;:
            # Dann gibt es bereits einen Docstring -&gt; Abbruch
            break


        if re.match(r&#34;^\s*\n?$&#34;, content):
            # Dann besteht die Zeile nur aus Whitespaces --&gt; Trimmen!
            # Rekursiver Aufruf dieser Methode mit jeweils einer vordersten Zeile weniger!
            docstring = Procedure.identify_docstring(text_lines[1:], trim_empty_rows=True, return_alternativ_text=False) 
            # TODO: Fehlervermeidung / Grenzfall:  IndexOutOfRange (Ende angekommen, --&gt; docstring vorhanden --&gt; Wird Error geben!
            break



    # =============================================================================
    #### #  Alternativtext bei leeren Docstrings: ####
    # =============================================================================
    
    if return_alternativ_text == True:

        if docstring == &#34;&#34;:
            docstring = &#34;*No information availible. For more information expand source code.*&#34; #  Die Sternchen bewirken im MArkdown ein Kursivdruck

    elif isinstance(return_alternativ_text, str):
        if docstring == &#34;&#34;:
            docstring = return_alternativ_text


    return docstring</code></pre>
</details>
</dd>
<dt id="code_documenter.Procedure.identify_procedures"><code class="name flex">
<span>def <span class="ident">identify_procedures</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Identifizieren
aller Prozeduren (Methoden und Funktione) auf Klassenebene und Speichern der Zeilennummern der Deklarations- und End-Zeilen innerhalb der jeweiligen Klassenvariablen.</p>
<p>Durchsucht werden die einzelnen Strings der als Liste übergebenen Zeileninhalte des Quellcodes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raws</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>Liste mit einem Eintrag pro Zeile des Quellcodes</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
# def identify_procedures(cls, list_of_code_lines:list[str]):
def identify_procedures(cls):
    &#34;&#34;&#34;
    Identifizieren  aller Prozeduren (Methoden und Funktione) auf Klassenebene und Speichern der Zeilennummern der Deklarations- und End-Zeilen innerhalb der jeweiligen Klassenvariablen.

    Durchsucht werden die einzelnen Strings der als Liste übergebenen Zeileninhalte des Quellcodes.

    Args:
        raws (list[str]): Liste mit einem Eintrag pro Zeile des Quellcodes

    &#34;&#34;&#34;

    for ix, text in enumerate(cls.raw_source_code):

        # db(text)

        if cls.search_for_begin:

            if Sub.check_and_get_match(text, ix):
                current_procedure_type_cls = Sub
                continue

            if Function.check_and_get_match(text, ix):
                current_procedure_type_cls = Function


        else:
            # Suche nach dem entsprechend passenden Ende
            current_procedure_type_cls.search_end_of_procedure(text, ix)</code></pre>
</details>
</dd>
<dt id="code_documenter.Procedure.initialize_input_code"><code class="name flex">
<span>def <span class="ident">initialize_input_code</span></span>(<span>input_path: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Liesst den zu analysierenden und zu dokumentierenden Input-Quellcode ein und speichert ihn innerhalb dder Superklasse als immer verfuegbare Liste einzelner Zeileninhalte ab.</p>
<h3 id="todo-spater-sollte-hier-auch-noch-eine-einfache-gui-erstellt-werden-zur-auswahl">TODO: Später sollte hier auch noch eine einfache GUI erstellt werden zur Auswahl!</h3>
<p>ggf. sollte diese GUI aber losgelöst von dieser Klasse sein (Wiederholfunktion!). Daher als Kapselung mit übergebenen input-path!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def initialize_input_code(cls, input_path:str):
    &#34;&#34;&#34;
    Liesst den zu analysierenden und zu dokumentierenden Input-Quellcode ein und speichert ihn innerhalb dder Superklasse als immer verfuegbare Liste einzelner Zeileninhalte ab.

    ### TODO: Später sollte hier auch noch eine einfache GUI erstellt werden zur Auswahl!
    ggf. sollte diese GUI aber losgelöst von dieser Klasse sein (Wiederholfunktion!). Daher als Kapselung mit übergebenen input-path!
    &#34;&#34;&#34;

    with open(input_path, &#34;r&#34;) as file:
        cls.raw_source_code = file.readlines()</code></pre>
</details>
</dd>
<dt id="code_documenter.Procedure.initialize_page_top_text"><code class="name flex">
<span>def <span class="ident">initialize_page_top_text</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialisiert den Text für den Markdown-Text des
Headers der Seite und speichert es in der Klassenvariable cls.head.
Zugriff erfolgt über die Superklasse Procedure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def initialize_page_top_text(cls):
    &#34;&#34;&#34;
    Initialisiert den Text für den Markdown-Text des  Headers der Seite und speichert es in der Klassenvariable cls.head. 
    Zugriff erfolgt über die Superklasse Procedure. 

    
    &#34;&#34;&#34;

    page_top_text = cls.__read_template(&#34;templates/sec_head.md&#34;)

    # Gesamtanzahl an verfügbaren prozeduren je Art einsetzen:
    placeholder_replacer = {
        &#34;@PLACEHOLDER_INPUT_FILE@&#34; : MetaData.get_input_filename(),
        &#34;@PLACEHOLDER_TIMESTAMP_NOW@&#34; : MetaData.date_of_process,
        &#34;@PLACEHOLDER_TIMESTAMP_SOURCEFILE@&#34; : MetaData.input_file__date_of_change,
    }


    for placeholder, replacer in placeholder_replacer.items():
        page_top_text = page_top_text.replace(placeholder, str(replacer))

    cls.page_top_text = page_top_text</code></pre>
</details>
</dd>
<dt id="code_documenter.Procedure.initialize_toc"><code class="name flex">
<span>def <span class="ident">initialize_toc</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialisiert den Text für den Markdown-Text des
Table of content und speichert es in der Klassenvariable cls.toc. Zugriff erfolgt über die Superklasse Procedure.
Innerhalb des resultierenden Textes sind weiterhin jeweils 1 Platzhalter fuer jede Prozedur-Art vorhanden. Diese werden spaeter gesondert ersetzt.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def initialize_toc(cls):
    &#34;&#34;&#34;
    Initialisiert den Text für den Markdown-Text des  Table of content und speichert es in der Klassenvariable cls.toc. Zugriff erfolgt über die Superklasse Procedure. 
    Innerhalb des resultierenden Textes sind weiterhin jeweils 1 Platzhalter fuer jede Prozedur-Art vorhanden. Diese werden spaeter gesondert ersetzt.
    &#34;&#34;&#34;

    toc = cls.__read_template(&#34;templates/sec_toc.md&#34;)

    # Gesamtanzahl an verfügbaren prozeduren je Art einsetzen:
    placeholder_replacer = {
        &#34;@PLACEHOLDER_SUBS_COUNTS@&#34; : len(Sub.instances),
        &#34;@PLACEHOLDER_FUNCTIONS_COUNTS@&#34; : len(Function.instances),
    }


    for placeholder, replacer in placeholder_replacer.items():
        toc = toc.replace(placeholder, str(replacer))

    cls.toc = toc</code></pre>
</details>
</dd>
<dt id="code_documenter.Procedure.search_end_of_procedure"><code class="name flex">
<span>def <span class="ident">search_end_of_procedure</span></span>(<span>text: str, line_no: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Prüft eine einzelne Zeile eines Codes (den übergebenen text), ob es sich um ein Match einer Deklarations-END-zeile handelt, und auch, ob diese NICHT-auskommentiert ist. Sofern dies der Fall ist, wird dieses MAtch in die Liste der MAtsches aufgenommen.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>Zu prüfender Text ausschnitt</dd>
</dl>
<p>line_no (int) : Zeilennummer der Liste an gesamt zu untersuchenden Zeilen</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True falls das match aufgenommen wurde</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def search_end_of_procedure(cls, text:str, line_no:int) -&gt; bool:
    &#34;&#34;&#34;
    Prüft eine einzelne Zeile eines Codes (den übergebenen text), ob es sich um ein Match einer Deklarations-END-zeile handelt, und auch, ob diese NICHT-auskommentiert ist. Sofern dies der Fall ist, wird dieses MAtch in die Liste der MAtsches aufgenommen.

    Args:
        text (str): Zu prüfender Text ausschnitt
        line_no (int) : Zeilennummer der Liste an gesamt zu untersuchenden Zeilen

    Returns:
        bool: True falls das match aufgenommen wurde
    &#34;&#34;&#34;

    
    # BUG: Durch die Regex wird aber auch etwas wie End sub  gefunden obwohl es um end function geht! Daher wurde der PRogrammablauf im main angepasst, um sicherzustellen, dass immer nach der richtigen Klassen-Beendigung gesucht wird... Falls Langeweile: Später mal schauen warum...
    if cls.regex_end.match(text):
        if not cls.regex_ausschluss_kommentar.match(text):
            # Dann aufnehmen in die Liste der MAtches!
            cls.matches_line_ixs[-1][-1] = line_no

            Procedure.search_for_begin = True

            return True
    
    return False</code></pre>
</details>
</dd>
<dt id="code_documenter.Procedure.sort_procedures_by_names"><code class="name flex">
<span>def <span class="ident">sort_procedures_by_names</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Füllen der Klassenvariable der <strong>SUBKLASSE</strong> cls.all_procedures_final mit einem Tupel pro Prozedur, in dem sowohl das einzelne Objekt, als auch seine Bezeichnung und die Zeilennummer der Deklaratrion enthalten ist in der Form [(object:Procedure, object.name:str, object.line_begin)].
Diese Liste wird nach Fertigstellung sortiert basierend auf den alphabetischen Bezeichnern, sodass der Zusammenhang zwischen den Objekten und den Namen weiterhin gegeben ist, gleichzeitig aber die Objekte in der alphabetischen Reihenfolge ihrer Namen dokumentiert werden können.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def sort_procedures_by_names(cls):
    &#34;&#34;&#34;
    Füllen der Klassenvariable der **SUBKLASSE** cls.all_procedures_final mit einem Tupel pro Prozedur, in dem sowohl das einzelne Objekt, als auch seine Bezeichnung und die Zeilennummer der Deklaratrion enthalten ist in der Form [(object:Procedure, object.name:str, object.line_begin)]. 
    Diese Liste wird nach Fertigstellung sortiert basierend auf den alphabetischen Bezeichnern, sodass der Zusammenhang zwischen den Objekten und den Namen weiterhin gegeben ist, gleichzeitig aber die Objekte in der alphabetischen Reihenfolge ihrer Namen dokumentiert werden können.

    &#34;&#34;&#34;

    all_procedures = [] 


    for procedure_obj in cls.instances:
        
        all_procedures.append((procedure_obj, procedure_obj.name, procedure_obj.line_begin))



    # Nach dem Füllen: Sortieren basierend auf den Bezeichner-Namen:
    cls.all_procedures_final = sorted(all_procedures, key=lambda stored_tuple: stored_tuple[1])</code></pre>
</details>
</dd>
<dt id="code_documenter.Procedure.write_to_file"><code class="name flex">
<span>def <span class="ident">write_to_file</span></span>(<span>output_file_path: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Schreibt die Dokumentation aller Prozeduren (aller Art) in die als Dateipfad übergebene Zieldatei(pfad).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def write_to_file(cls, output_file_path:str):
    &#34;&#34;&#34;
    Schreibt die Dokumentation aller Prozeduren (aller Art) in die als Dateipfad übergebene Zieldatei(pfad).
    &#34;&#34;&#34;



    # initialize_toc



    with open(output_file_path, &#34;w&#34;, ) as file:

        ## TODO: Dies gehört eigentlich nicht mehr in die Klasse Procedure, aber aktuell trotzdem hierher, um alles zusammen zu haben. Ggf.s später refactoring...
        # Initialisiere die Seite mit Titel und organisatorischen Hinweisen:
        content = cls.__read_template(&#34;templates/sec_head.md&#34;)


                            
        # # TEST                                                                                                              
        # # Extrahiere Daten von der Version DIESES DOKUMENTIER-TOOLS:
        # content = MetaData.gitinfo 
        # content = content + &#34;\n&#34;*3 + &#34;Datum der Umwandlung: &#34; + MetaData.date_of_process
                      


        # TODO: Hier muss noch Placeholders ersetzt werden!!&#39;
        file.write(cls.page_top_text)


        #Einfügen des Index / TOCs /  Inhaltsverzeichnis:
        file.write(cls.toc)


        # schreiben der Modulinfos / Docstrings:
        file.write(cls.modul_docstring)





        # # TODO: Struktur...? das gehört zu den references...
        # _PLACEHOLDER_REFERENCE = &#34;@PLACEHOLDER_PROCEDURE_REFERENCES_ENTRY@&#34; 


        for procedure_type_cls in [Sub, Function]: # Reihenfolge wichtig fuer die Reihenfolge der Dokumentierten Sections!


            # Überschrift der Section einfügen (aus gesonderter Template):
            file.write(procedure_type_cls.header)



            # Dokumentieren aller einzelnen Prozeduren:
            for procedur_infos in procedure_type_cls.all_procedures_final:
            # for (procedure_obj, procedure_name, procedure_line) in procedure_type_cls.all_procedures_final:

                procedure_obj:Procedure = procedur_infos[0]





                procedure_obj.generate_reference_entries()

                &#34;&#34;&#34;
                # TODO: Auslagern in eigene Funktion!     START                        erledigt ab V. 0.2.2

                # shortcut:
                doc:str = procedure_obj.documentation 

                # Alle Referenzierungen sind in der Objektvariablen  procedure_obj.references gespeichert:
                count_of_references = len(procedure_obj.references)

                # ERsetzen des Platzhalters für die Anzahl der Referenzierungen in der bisherigen Dokumentation:
                doc = doc.replace(&#34;@PLACEHOLDER_PROCEDURE_COUNT_OF_REFERENCES@&#34;, str(count_of_references))
                

                # Initialisierung und  Parametrisierung  des Einleitungssatzes:
                einleitungssatz = &#34;Kein Aufruf gefunden.&#34; # default

                if count_of_references &gt; 0:

                    einleitungssatz = &#34;Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:&#34;

                    
                    # Iterrieren ueber jede Referenzierung, um diese zu dokumentieren:
                    for (line_no, calling_procedure_name, line_code) in procedure_obj.references:

                        # Zusammenbau des Ersatzwertes für den Platzhalter inkl. Anhängen des Platzhalters für weitere Ersetzungen:
                        
                        # Um MArkdown nicht zu zerschiessen muss der letzte Zeilenumbruch des line_codes entfernt werrden:
                        line_code:str = line_code.rstrip(&#34;\n&#34;)

                        replacer_placeholder_reference = f&#34;* [```{calling_procedure_name}```](#{calling_procedure_name}) : &lt;small&gt;  Zeile {line_no} : ```{line_code}``` &lt;/small&gt;&#34;


                        # # AUSBLICK: weitere collapse details : funktioniert technisch, allerdings steht das collapsable immer in neuer Zeile und daher wird es groß - vielleicht später in schön machen...
                        # __replacer_placeholder_reference = f&#34;*   [```{calling_procedure_name}```](#{calling_procedure_name})  &lt;details&gt; &lt;summary&gt;: &lt;small&gt;Zeile {line_no}&lt;/small&gt; &lt;/summary&gt; ```{line_code}``` &lt;/details&gt;&#34;



                        replacer_placeholder_reference = replacer_placeholder_reference  + f&#34;\n{_PLACEHOLDER_REFERENCE}&#34;
                        
                        # Ersetzen:
                        doc = doc.replace(_PLACEHOLDER_REFERENCE, replacer_placeholder_reference)


                # Loeschen des verbliebenen Platzhalters zum Einfuegen einzelner Referenzen:
                doc = doc.replace(_PLACEHOLDER_REFERENCE, &#34;&#34;)



                # Einsetzen des Einleitungssatzes:
                doc = doc.replace(&#34;@PLACEHOLDER_PROCEDURE_REFERENCES_INTRODUCTION@&#34;, einleitungssatz)


                # shortcut / resubstitution:
                procedure_obj.documentation = doc
                
                # TODO: Auslagern in eigene Funktion!     ENDE                       


                &#34;&#34;&#34;


                # JULIA: Versuche Wiederherstollung des Tails!!!!
                # procedure_obj.generate_calling_entries()

                file.write(procedure_obj.documentation)


            # Ausgabe der Zusammenfassung pro Section:
            print(&#34;Es wurden {} {}s identifiziert und dokumentiert.&#34;.format(len(procedure_type_cls.instances), procedure_type_cls.KEYWORD_TYPE))



        ## TODO: Dies gehört eigentlich nicht mehr in die Klasse Procedure, aber aktuell trotzdem hierher, um alles zusammen zu haben. Ggf.s später refactoring...
        # Finalisiere die Seite mit Schlusbemerkungen:
        content = cls.__read_template(&#34;templates/sec_tail.md&#34;)
        # HACK: Nur fuer ENtwicklungsstadium!
        content = content.replace(&#34;@PLACEHOLDER_TIMESTAMP_NOW@&#34;, MetaData.date_of_process)
        content = content.replace(&#34;@PLACEHOLDER_DOC_PYTHON@&#34;, __doc__.replace(&#34;\n&#34;, &#34;&lt;br&gt;&#34;))
        content = content.replace(&#34;@PLACEHOLDER_DOCUMENTER_VERSION__AUTHOR@&#34;, MetaData.documenter_version__author.rstrip(&#34; &lt;_&gt;&#34;))
        content = content.replace(&#34;@PLACEHOLDER_DOCUMENTER_VERSION__COMMIT@&#34;, MetaData.documenter_version__commit)
        content = content.replace(&#34;@PLACEHOLDER_DOCUMENTER_VERSION__DATE@&#34;, MetaData.documenter_version__author_date)

        file.write(content)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="code_documenter.Procedure.extract_docstring"><code class="name flex">
<span>def <span class="ident">extract_docstring</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="changelog-2023-12-30-031704-bis-v-005-war-diese-funktion-alleinherschend">CHANGELOG: 2023-12-30 - 03:17:04 Bis V. 0.0.5 war diese Funktion 'alleinherschend'.</h1>
<p>Erst danach
wurde die Durchschleusung zur static method identify_docstring eingeführt,
um damit auch modulweite Docstrings finden zu koennen.</p>
<p>Ließt den docstring aus und speichert diesen im Attribut self.docstring
Sofern kein Docstring im Code identifiziert wurde, wird eine entsprechende Info in den Text geschrieben.</p>
<p>Als Docstring wird jede Kommentarzeile gewertet, die DIREKT UND OHNE VORHERIGE LEERZEEILE UNTERHALB DER DEKLARIERUNGSZEILE der Prozedur steht. Sobald eine Leerzeile folgt, wird der Docstring als beendet angesehen.</p>
<h2 id="beispiel">Beispiel</h2>
<p>Private Sub beispielProgramm() ' Deklarationszeile
' Dies ist ein Kommentar direkt unter der Deklarationszeile. Somit wird es als Docstring gewertet.
' Dies auch
'
' Da die vorherige Zeile AUCH einen Kommentar (einen leeren) enthält, ist dies hier immer noch Bestandteil des Docstrings.</p>
<pre><code>' Vor dieser Zeile war ein NICHT-Kommentar, daher gehört das hier nicht mehr zum Docstring
MsgBox("Das gehört zum Programm")
</code></pre>
<p>End Sub</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_docstring(self):
    &#34;&#34;&#34;
    # CHANGELOG: 2023-12-30 - 03:17:04 Bis V. 0.0.5 war diese Funktion &#39;alleinherschend&#39;. 
    Erst danach  wurde die Durchschleusung zur static method identify_docstring eingeführt,
    um damit auch modulweite Docstrings finden zu koennen.


    Ließt den docstring aus und speichert diesen im Attribut self.docstring
    Sofern kein Docstring im Code identifiziert wurde, wird eine entsprechende Info in den Text geschrieben.

    Als Docstring wird jede Kommentarzeile gewertet, die DIREKT UND OHNE VORHERIGE LEERZEEILE UNTERHALB DER DEKLARIERUNGSZEILE der Prozedur steht. Sobald eine Leerzeile folgt, wird der Docstring als beendet angesehen.

    Beispiel:
        Private Sub beispielProgramm() &#39; Deklarationszeile
            &#39; Dies ist ein Kommentar direkt unter der Deklarationszeile. Somit wird es als Docstring gewertet.
            &#39; Dies auch
            &#39;
            &#39; Da die vorherige Zeile AUCH einen Kommentar (einen leeren) enthält, ist dies hier immer noch Bestandteil des Docstrings.

            &#39; Vor dieser Zeile war ein NICHT-Kommentar, daher gehört das hier nicht mehr zum Docstring
            MsgBox(&#34;Das gehört zum Programm&#34;)
        End Sub
    &#34;&#34;&#34;


    # Docstring ueber generalisierte Methode herausfiltern:
    docstring = self.identify_docstring(self.lines[1:], return_alternativ_text=True)

    # Speichern im Objekt:
    self.docstring = docstring</code></pre>
</details>
</dd>
<dt id="code_documenter.Procedure.extract_line_numbers"><code class="name flex">
<span>def <span class="ident">extract_line_numbers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Ließt die relevanten Start- und End-Zeilennummern aus und speichert diesen im Attribut self.line_begin und self.line_end</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_line_numbers(self):
    &#34;&#34;&#34;
    Ließt die relevanten Start- und End-Zeilennummern aus und speichert diesen im Attribut self.line_begin und self.line_end
    &#34;&#34;&#34;
    # Hole Index der Instanzenliste, dieser ist gleich dem Index der matches_line_ixs Liste:
    ix = self.instances.index(self) 

    match_lines_ix = self.matches_line_ixs[ix]
    
    self.line_begin = match_lines_ix[0] + 1
    self.line_end = match_lines_ix[1] + 1</code></pre>
</details>
</dd>
<dt id="code_documenter.Procedure.extract_modifier"><code class="name flex">
<span>def <span class="ident">extract_modifier</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Ließt den Modifier aus und speichert diesen im Attribut self.modifier</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_modifier(self):
    &#34;&#34;&#34;
    Ließt den Modifier aus und speichert diesen im Attribut self.modifier
    &#34;&#34;&#34;
    # Wiederverwendung der Deklarationszeilen-Regex:
    match = self.regex_begin.match(self.lines[0])

    # Entnehme den String bis vor den NAmen:
    pos_name = match.string.find(self.name + &#34;(&#34;)
    potentieller_modifier = match.string[0:pos_name]

    # Identifiziere hieraus den modifier:
    
    # # Eigentlich sollte es schon auf Grundlage der eigentlichen regex gehen, funktioniert aber nicht! Es wird immer was leres zurückgegeben, daher, neue regex! (Bei Zeit mal schauen warum!)
    # # Extraktion der Gruppe mit dem Name: (eigentlicher Ansatz)
    # db(match.groups())
    # modifier = match.group(1)
    
    
    regex_modifier = re.compile(r&#34;((?:Private|Public|Friend)?)&#34;)
    match = regex_modifier.match(potentieller_modifier)
    modifier = match.group(1)


    if modifier == &#34;&#34;:
        modifier = &#34;Public&#34;

    # db(modifier)

    self.modifier = modifier</code></pre>
</details>
</dd>
<dt id="code_documenter.Procedure.extract_name"><code class="name flex">
<span>def <span class="ident">extract_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Ließt den Bezeichnungsnamen aus und speichert diesen im Attribut self.name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_name(self):
    &#34;&#34;&#34;
    Ließt den Bezeichnungsnamen aus und speichert diesen im Attribut self.name
    &#34;&#34;&#34;
    # Wiederverwendung der Deklarationszeilen-Regex:
    
    
    match = self.regex_begin.match(self.lines[0])

    # db(match.groups())
    # Extraktion der Gruppe mit dem Name:
    name = match.group(1)

    # db(name)

    self.name = name</code></pre>
</details>
</dd>
<dt id="code_documenter.Procedure.extract_references"><code class="name flex">
<span>def <span class="ident">extract_references</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h3 id="todo-wird-aktuell-version-012-ganz-wo-anders-erledigt-ist-dort-noch-nicht-optimal-aber-um-redundanzen-und-verewchslungen-vorzubeugen-wird-diese-methode-erst-mal-platt-gemacht-und-nicht-mehr-aufgerufen">TODO: Wird aktuell (Version &gt; 0.1.2) ganz wo anders erledigt, ist dort noch nicht optimal - aber um Redundanzen und Verewchslungen vorzubeugen, wird diese Methode erst mal platt gemacht und nicht mehr aufgerufen!</h3>
<p>Später wäre es shcön&hellip;</p>
<h3 id="alt">ALT:</h3>
<p>Durchsucht den gesamten Quelltext nach Referenzierungen (Aufrufen) dieser Prozedur und speichert diese im Attribut self.references</p>
<h1 id="todo-alles">TODO ALLES</h1></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_references(self):
    &#34;&#34;&#34;
    ### TODO: Wird aktuell (Version &gt; 0.1.2) ganz wo anders erledigt, ist dort noch nicht optimal - aber um Redundanzen und Verewchslungen vorzubeugen, wird diese Methode erst mal platt gemacht und nicht mehr aufgerufen!

    Später wäre es shcön...
    
    ### ALT: 
    Durchsucht den gesamten Quelltext nach Referenzierungen (Aufrufen) dieser Prozedur und speichert diese im Attribut self.references
    # TODO ALLES
    &#34;&#34;&#34;
    # self.references = &#34; # TODO ... self.references&#34;
    # self.count_of_references = &#34; # TODO ... self.count_of_references&#34;
    pass</code></pre>
</details>
</dd>
<dt id="code_documenter.Procedure.extract_source_code"><code class="name flex">
<span>def <span class="ident">extract_source_code</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Ließt den source_code aus und speichert diesen im Attribut self.source_code</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_source_code(self):
    &#34;&#34;&#34;
    Ließt den source_code aus und speichert diesen im Attribut self.source_code
    &#34;&#34;&#34;

    source_code = &#34;&#34;
    for line in self.lines:
        source_code = source_code + line

    self.source_code = source_code</code></pre>
</details>
</dd>
<dt id="code_documenter.Procedure.generate_calling_entries"><code class="name flex">
<span>def <span class="ident">generate_calling_entries</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><h1 id="todo-julia">TODO: # JULIA</h1>
<p>mitten in dev.</p>
<p>ansatz vorhanden</p>
<p>Generiert die Dokumentatoin der Abrufsequenzen / Abruffolgen.
Speichert das Ergebnis in der bereits existierenden Objektvariable procedure_obj.documentation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_calling_entries(self) -&gt; None:
    &#34;&#34;&#34;
    # TODO: # JULIA                                         
    mitten in dev.

    ansatz vorhanden



    Generiert die Dokumentatoin der Abrufsequenzen / Abruffolgen.
    Speichert das Ergebnis in der bereits existierenden Objektvariable procedure_obj.documentation
    &#34;&#34;&#34;


    # TODO                                                                      
    # JULIA                                                                     
    &#34;&#34;&#34;
    
    MÖGLICHE HERANGEHENSWEISEN


    - Vorgehensweise A:
        - Durchsuche gesamten Code DIESER Prozedur nach einem Aufruf einre Prozedur, die hier bereits bekannt ist (via regex)

    - Vorgehensweise B:
        -  Durchsuche alle OBJEKT-INSTANZEN aller Prozeduren beim key=References und schaue, ob eine zeilennummer der referenzierung innerhalb der zeilennummer dieser prozedur hier liegt.
        - scheint mir der entwicklungs-technisch schnellere weg zu sein...
        - bei langen programmen mit vielen prozeduren ist es besonders ineffizient, je kürzer die HIER TATSÄCHLICH GERADE zu dokumentierende funktion ist, aber das ist mir mal egal....
        - Vorteil: keine regex entwicklung / duplikat wie bei references!


    &#34;&#34;&#34;

    &#34;&#34;&#34;
    # Referenzierungs-zeile muss hierzwischen liegen:
    self.line_begin
    self.line_end







    &#34;&#34;&#34;

    # TODO: Extrahiere alle Referenzierungen dazwischen:
    db(&#34;...&#34;)

    self.calling_sequences = []

    # bei hauptfunc1 --&gt; soll 2 einträge: unterfunkntionA + B
    
    Procedure.all_procedures_final
    # liste mit exemplarischen einzel-Eintrag: 
    # (procedure_obj, procedure_name, procedure_line )



    for (procedure_obj, uebergeordnete_prozedur_name, procedure_declaration_line_no) in Procedure.all_procedures_final:

        &#34;&#34;&#34;
        # iterater = 6 # schleifenzähler pro prozedur
        # einzelprozedur = Procedure.all_procedures_final[iterater][0]
        # ENTSPRICHT JETZT:
        procedure_obj

        procedure_obj.references
        # liste mit exemplarischen einzel-Eintrag: 
        # (line_nr_aufruf, &#34;uebergeordnetes_sub&#34;, code)
        &#34;&#34;&#34;
        
        # SCHNELLERER ANSATZ:
        # Filtern der liste, so dass uebergeordnetes_sub == name
        # dann fertig!

        relevante_references = [_ for _ in procedure_obj.references if uebergeordnete_prozedur_name == self.name]

        for (line_no_reference, uebergeordnetes_sub, code, ziel_prozedur_name) in relevante_references:

            self.calling_sequences.append((line_no_reference, uebergeordnetes_sub, code, ziel_prozedur_name)) # relevant ist nur der name aus der regex im cod
            # TODO: ??? ggf doch nicht nötig? Bei erstellung dieses tupels bei analyse der referenzen --&gt; speichere auch das ziel, aleso den subname
        

        &#34;&#34;&#34;
        # ALTER ALTERNATIVER ANSATZ:

        # ist line_nr zwischen self.line.begin + self.line.end der ZU DOKUMENTIERENDEN Prozedur??
        for (line_no_reference, uebergeordnetes_sub, code) in procedure_obj.references:
            if line_no_reference &lt; self.line_begin:
                continue
            if line_no_reference &gt; self.line_end:
                continue
            # SONST: liegt es darin!!! AUFNEHMEN IN LISTE!!!!

            self.calling_sequences.append((line_no_reference, uebergeordnetes_sub, code))
        &#34;&#34;&#34;



            # TODO:  Am Ende vor der dokumentation die liste noch sortieren aufsteigend nach line_no_reference konzeptionell identisch wie im index/toc

            # JULIA: LOGIK FALSCH????
        db(self.calling_sequences)


        _PLACEHOLDER_REFERENCE = &#34;@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@&#34;

        # TODO: ersetze im doc:
        doc = self.documentation




        # Initialisierung und  Parametrisierung  des Einleitungssatzes:
        einleitungssatz = &#34;Keine weiteren Aufrufe zu hier dokumentierten Prozeduren gefunden.&#34; # default

        if len(self.calling_sequences) &gt; 0:

            einleitungssatz = &#34;Innehalb der Prozedur werden die folgenden, untergeordneten Prozeduren aufgerufen:&#34;

        for (line_no_reference, uebergeordnetes_sub, line_code, target_procedure_name) in self.calling_sequences:


            # TODO:
            # HACK:
            target_procedure_name = &#34;main&#34;



            replacer_placeholder_reference = f&#34;&lt;small&gt;  Zeile {line_no_reference} &lt;/small&gt; : ```{line_code}``` ODER: {target_procedure_name}&#34;
            # replacer_placeholder_reference = f&#34;* [```{code}```](#{target_procedure}) : &lt;small&gt;  Zeile {line_no_reference} : ```{line_code}``` &lt;/small&gt;&#34;

            replacer_placeholder_reference = replacer_placeholder_reference  + f&#34;\n{_PLACEHOLDER_REFERENCE}&#34;
                
            # Ersetzen:
            doc = doc.replace(_PLACEHOLDER_REFERENCE, replacer_placeholder_reference)

                
        # Loeschen des verbliebenen Platzhalters zum Einfuegen einzelner Referenzen:
        doc = doc.replace(_PLACEHOLDER_REFERENCE, &#34;&#34;)



        # Einsetzen des Einleitungssatzes:
        doc = doc.replace(&#34;@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@&#34;, einleitungssatz)


        # shortcut / resubstitution:
        self.documentation = doc</code></pre>
</details>
</dd>
<dt id="code_documenter.Procedure.generate_documentation"><code class="name flex">
<span>def <span class="ident">generate_documentation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Dokumentiert die gefundenen Parameter unter Nutzung einer Template-Markdown-Textdatei und speichert den zu schreibenden Text im Attribut self.documentation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_documentation(self):
    &#34;&#34;&#34;
    Dokumentiert die gefundenen Parameter unter Nutzung einer Template-Markdown-Textdatei und speichert den zu schreibenden Text im Attribut self.documentation
    &#34;&#34;&#34;

    self.read_template()

    placeholder_replacer = {
        &#34;@PLACEHOLDER_PROCEDURE_TYPE@&#34; : self.KEYWORD_TYPE,
        &#34;@PLACEHOLDER_PROCEDURE_MODIFIER@&#34; : self.modifier,
        &#34;@PLACEHOLDER_PROCEDURE_NAME@&#34; : self.name,
        &#34;@PLACEHOLDER_PROCEDURE_LINE_BEGIN@&#34; : self.line_begin,
        &#34;@PLACEHOLDER_PROCEDURE_DOCSTRING@&#34; : self.docstring,
        &#34;@PLACEHOLDER_PROCEDURE_SOURCE_CODE@&#34; : self.source_code,

        # # TODO:  Kommen die References extra??! Wahrscheinlich schon stand jetzt (Version&gt; 0.1.3)
        # &#34;@PLACEHOLDER_PROCEDURE_REFERENCES@&#34; : self.references,
        # &#34;@PLACEHOLDER_PROCEDURE_COUNT_OF_REFERENCES@&#34; : self.count_of_references,
    }


    for placeholder, replacer in placeholder_replacer.items():
        self.documentation = self.documentation.replace(placeholder, str(replacer))</code></pre>
</details>
</dd>
<dt id="code_documenter.Procedure.generate_reference_entries"><code class="name flex">
<span>def <span class="ident">generate_reference_entries</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Generiert von dem Objekt der Subklasse Function oder Sub die Dokumentation der Referenzierungen.
Speichert das Ergebnis in der bereits existierenden Objektvariable procedure_obj.documentation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_reference_entries(self) -&gt; None:
# def generate_reference_entries(cls, procedure_obj) -&gt; None:
    &#34;&#34;&#34;
    Generiert von dem Objekt der Subklasse Function oder Sub die Dokumentation der Referenzierungen.
    Speichert das Ergebnis in der bereits existierenden Objektvariable procedure_obj.documentation
    &#34;&#34;&#34;



    # TODO: Struktur...? das gehört zu den references... ist eig. statisch, müsste nicht jedes mal beim funktionsaufruf neu gemacht werden, aber so ist es zusammen...
    _PLACEHOLDER_REFERENCE = &#34;@PLACEHOLDER_PROCEDURE_REFERENCES_ENTRY@&#34; 



    # shortcut:
    doc:str = self.documentation 

    # Alle Referenzierungen sind in der Objektvariablen  procedure_obj.references gespeichert:
    count_of_references = len(self.references)

    # ERsetzen des Platzhalters für die Anzahl der Referenzierungen in der bisherigen Dokumentation:
    doc = doc.replace(&#34;@PLACEHOLDER_PROCEDURE_COUNT_OF_REFERENCES@&#34;, str(count_of_references))
    

    # Initialisierung und  Parametrisierung  des Einleitungssatzes:
    einleitungssatz = &#34;Kein Aufruf gefunden.&#34; # default

    if count_of_references &gt; 0:

        einleitungssatz = &#34;Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:&#34;

        
        # Iterrieren ueber jede Referenzierung, um diese zu dokumentieren:
        for (line_no, calling_procedure_name, line_code, target_procedure_name) in self.references:

            # Zusammenbau des Ersatzwertes für den Platzhalter inkl. Anhängen des Platzhalters für weitere Ersetzungen:
            
            # Um MArkdown nicht zu zerschiessen muss der letzte Zeilenumbruch des line_codes entfernt werrden:
            line_code:str = line_code.rstrip(&#34;\n&#34;)

            replacer_placeholder_reference = f&#34;* [```{calling_procedure_name}```](#{calling_procedure_name}) : &lt;small&gt;  Zeile {line_no} : ```{line_code}``` &lt;/small&gt;&#34;


            # # AUSBLICK: weitere collapse details : funktioniert technisch, allerdings steht das collapsable immer in neuer Zeile und daher wird es groß - vielleicht später in schön machen...
            # __replacer_placeholder_reference = f&#34;*   [```{calling_procedure_name}```](#{calling_procedure_name})  &lt;details&gt; &lt;summary&gt;: &lt;small&gt;Zeile {line_no}&lt;/small&gt; &lt;/summary&gt; ```{line_code}``` &lt;/details&gt;&#34;



            replacer_placeholder_reference = replacer_placeholder_reference  + f&#34;\n{_PLACEHOLDER_REFERENCE}&#34;
            
            # Ersetzen:
            doc = doc.replace(_PLACEHOLDER_REFERENCE, replacer_placeholder_reference)


    # Loeschen des verbliebenen Platzhalters zum Einfuegen einzelner Referenzen:
    doc = doc.replace(_PLACEHOLDER_REFERENCE, &#34;&#34;)



    # Einsetzen des Einleitungssatzes:
    doc = doc.replace(&#34;@PLACEHOLDER_PROCEDURE_REFERENCES_INTRODUCTION@&#34;, einleitungssatz)


    # shortcut / resubstitution:
    self.documentation = doc
    
    # TODO: Auslagern in eigene Funktion!     ENDE                       </code></pre>
</details>
</dd>
<dt id="code_documenter.Procedure.read_template"><code class="name flex">
<span>def <span class="ident">read_template</span></span>(<span>self, template='einzelprozedur') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Ließt die relevante Template-MArkdown Datei ein und gibt den Inhalt als String zurück.
Sofern es sich um die Default-Template für eine beliebige Prozedur handelt
wird außerdem auch das Attribut self.documentation mit diesem Text initialisiert.</p>
<h2 id="args">Args</h2>
<p>template (str) : Dateipfad zur Template - Ausnahme: Falls die in der Klasse gespeicherte
Standardtemplate self.TEMPLATE fuer eine Prozedur verwendet werden soll,
dann muss das Stichwort "einzelprozedur" übergeben werden.
Dies ist default der Fall &ndash;&gt; keine Angabe erforderlich.</p>
<h2 id="return">Return</h2>
<p>str : Inhalt der Template</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_template(self, template=&#34;einzelprozedur&#34;) -&gt; str:
    &#34;&#34;&#34;
    Ließt die relevante Template-MArkdown Datei ein und gibt den Inhalt als String zurück. 
    Sofern es sich um die Default-Template für eine beliebige Prozedur handelt
    wird außerdem auch das Attribut self.documentation mit diesem Text initialisiert.

    Args:
        template (str) : Dateipfad zur Template - Ausnahme: Falls die in der Klasse gespeicherte 
                        Standardtemplate self.TEMPLATE fuer eine Prozedur verwendet werden soll, 
                        dann muss das Stichwort &#34;einzelprozedur&#34; übergeben werden. 
                        Dies ist default der Fall --&gt; keine Angabe erforderlich.

    Return:
        str : Inhalt der Template
    &#34;&#34;&#34;


    if template == &#34;einzelprozedur&#34;:
    
        # Auslesen und Speichern in Objektvariable
        self.documentation = self.__read_template(self.TEMPLATE)
        return self.documentation


    # Bei NICHT-Standard-Prozedur-Template: Auslesen dieser Template und Rückgabe des Textinhaltes:
    content = self.__read_template(template)
    return content</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="code_documenter.Sub"><code class="flex name class">
<span>class <span class="ident">Sub</span></span>
<span>(</span><span>text_lines: tuple[str])</span>
</code></dt>
<dd>
<div class="desc"><p>Subklasse für eine VBA-Sub-Prozedur.
U.a. wird hier auch der von der Superklasse vor-initialisierte Regex-Ausdruck konkretisiert und kompiliert, der im VBA-Syntax für den Beginn und das Ende der Prozedurart erforderlich ist.</p>
<p>Die meisten Methoden sind in der übergeordneten Superklasse gelagert, da sie vom Ablauf fuer VBA-Subs und VBA-Methoden identisch sind.</p>
<p>Erstellt ein Prozedur-Objekt, wodurch die einzelnen Komponenten des Codes gesucht und gespeichert werden.
Uebergeben muss ein beliebig grosses Tuple, wobei jedes Element davon den String einre einzelnen Zeile dieser Prozedur enthaelt.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text_lines</code></strong> :&ensp;<code>tuple[str]</code></dt>
<dd>Tuple mit den einzelnen Textzeilen, die zu der relevaten
Prozedur gehoeren.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sub(Procedure):
    &#34;&#34;&#34;
    Subklasse für eine VBA-Sub-Prozedur.
    U.a. wird hier auch der von der Superklasse vor-initialisierte Regex-Ausdruck konkretisiert und kompiliert, der im VBA-Syntax für den Beginn und das Ende der Prozedurart erforderlich ist.

    Die meisten Methoden sind in der übergeordneten Superklasse gelagert, da sie vom Ablauf fuer VBA-Subs und VBA-Methoden identisch sind.

    &#34;&#34;&#34;

    matches_line_ixs = []
    instances = []

    all_procedures_final = [] # Liste wird erst nach Identifizierung aller Prozeduren erstellt. Sie dient der Sortierung  der Instanzen basierend auf der alphabetischen Reihenfolge ihrer Prozedur-Bezeichnungen

    
    KEYWORD_TYPE = &#34;Sub&#34; 

    TEMPLATE_SECTION_HEAD = &#34;templates/sec_subs.md&#34;
    

    # Konkretisierung und Kompilierung der Regex-Ausdrücke:

    regex_begin = re.compile(Procedure.regex_begin_pattern.replace(&#34;PLACEHOLDER_PROCEDURE_TYPE&#34;, KEYWORD_TYPE), re.VERBOSE | re.IGNORECASE)


    regex_end = re.compile(Procedure.regex_end_pattern.replace(&#34;PLACEHOLDER_PROCEDURE_TYPE&#34;, KEYWORD_TYPE), re.VERBOSE | re.IGNORECASE)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="code_documenter.Procedure" href="#code_documenter.Procedure">Procedure</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="code_documenter.Sub.KEYWORD_TYPE"><code class="name">var <span class="ident">KEYWORD_TYPE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="code_documenter.Sub.TEMPLATE_SECTION_HEAD"><code class="name">var <span class="ident">TEMPLATE_SECTION_HEAD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="code_documenter.Sub.all_procedures_final"><code class="name">var <span class="ident">all_procedures_final</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="code_documenter.Sub.instances"><code class="name">var <span class="ident">instances</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="code_documenter.Sub.matches_line_ixs"><code class="name">var <span class="ident">matches_line_ixs</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="code_documenter.Sub.regex_begin"><code class="name">var <span class="ident">regex_begin</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="code_documenter.Sub.regex_end"><code class="name">var <span class="ident">regex_end</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="code_documenter.Procedure" href="#code_documenter.Procedure">Procedure</a></b></code>:
<ul class="hlist">
<li><code><a title="code_documenter.Procedure.analyse_references" href="#code_documenter.Procedure.analyse_references">analyse_references</a></code></li>
<li><code><a title="code_documenter.Procedure.check_and_get_match" href="#code_documenter.Procedure.check_and_get_match">check_and_get_match</a></code></li>
<li><code><a title="code_documenter.Procedure.detail_analyse_procedures" href="#code_documenter.Procedure.detail_analyse_procedures">detail_analyse_procedures</a></code></li>
<li><code><a title="code_documenter.Procedure.extract_docstring" href="#code_documenter.Procedure.extract_docstring">extract_docstring</a></code></li>
<li><code><a title="code_documenter.Procedure.extract_line_numbers" href="#code_documenter.Procedure.extract_line_numbers">extract_line_numbers</a></code></li>
<li><code><a title="code_documenter.Procedure.extract_modifier" href="#code_documenter.Procedure.extract_modifier">extract_modifier</a></code></li>
<li><code><a title="code_documenter.Procedure.extract_name" href="#code_documenter.Procedure.extract_name">extract_name</a></code></li>
<li><code><a title="code_documenter.Procedure.extract_references" href="#code_documenter.Procedure.extract_references">extract_references</a></code></li>
<li><code><a title="code_documenter.Procedure.extract_source_code" href="#code_documenter.Procedure.extract_source_code">extract_source_code</a></code></li>
<li><code><a title="code_documenter.Procedure.finilize" href="#code_documenter.Procedure.finilize">finilize</a></code></li>
<li><code><a title="code_documenter.Procedure.generate_calling_entries" href="#code_documenter.Procedure.generate_calling_entries">generate_calling_entries</a></code></li>
<li><code><a title="code_documenter.Procedure.generate_documentation" href="#code_documenter.Procedure.generate_documentation">generate_documentation</a></code></li>
<li><code><a title="code_documenter.Procedure.generate_reference_entries" href="#code_documenter.Procedure.generate_reference_entries">generate_reference_entries</a></code></li>
<li><code><a title="code_documenter.Procedure.generate_toc_entries" href="#code_documenter.Procedure.generate_toc_entries">generate_toc_entries</a></code></li>
<li><code><a title="code_documenter.Procedure.identify_docstring" href="#code_documenter.Procedure.identify_docstring">identify_docstring</a></code></li>
<li><code><a title="code_documenter.Procedure.identify_procedures" href="#code_documenter.Procedure.identify_procedures">identify_procedures</a></code></li>
<li><code><a title="code_documenter.Procedure.initialize_input_code" href="#code_documenter.Procedure.initialize_input_code">initialize_input_code</a></code></li>
<li><code><a title="code_documenter.Procedure.initialize_page_top_text" href="#code_documenter.Procedure.initialize_page_top_text">initialize_page_top_text</a></code></li>
<li><code><a title="code_documenter.Procedure.initialize_toc" href="#code_documenter.Procedure.initialize_toc">initialize_toc</a></code></li>
<li><code><a title="code_documenter.Procedure.read_template" href="#code_documenter.Procedure.read_template">read_template</a></code></li>
<li><code><a title="code_documenter.Procedure.regex_end_pattern" href="#code_documenter.Procedure.regex_end_pattern">regex_end_pattern</a></code></li>
<li><code><a title="code_documenter.Procedure.search_end_of_procedure" href="#code_documenter.Procedure.search_end_of_procedure">search_end_of_procedure</a></code></li>
<li><code><a title="code_documenter.Procedure.sort_procedures_by_names" href="#code_documenter.Procedure.sort_procedures_by_names">sort_procedures_by_names</a></code></li>
<li><code><a title="code_documenter.Procedure.write_to_file" href="#code_documenter.Procedure.write_to_file">write_to_file</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#fertig-implementiert">Fertig implementiert:</a></li>
<li><a href="#todo-groere-todos">TODO: Größere TODOS:</a></li>
<li><a href="#ausblick-fur-spater-und-in-schon">AUSBLICK für später und in schön:</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="code_documenter.db" href="#code_documenter.db">db</a></code></li>
<li><code><a title="code_documenter.main" href="#code_documenter.main">main</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="code_documenter.AutoCallMeta" href="#code_documenter.AutoCallMeta">AutoCallMeta</a></code></h4>
<ul class="">
<li><code><a title="code_documenter.AutoCallMeta.class_name_to_call_implicit" href="#code_documenter.AutoCallMeta.class_name_to_call_implicit">class_name_to_call_implicit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="code_documenter.Function" href="#code_documenter.Function">Function</a></code></h4>
<ul class="">
<li><code><a title="code_documenter.Function.KEYWORD_TYPE" href="#code_documenter.Function.KEYWORD_TYPE">KEYWORD_TYPE</a></code></li>
<li><code><a title="code_documenter.Function.TEMPLATE_SECTION_HEAD" href="#code_documenter.Function.TEMPLATE_SECTION_HEAD">TEMPLATE_SECTION_HEAD</a></code></li>
<li><code><a title="code_documenter.Function.all_procedures_final" href="#code_documenter.Function.all_procedures_final">all_procedures_final</a></code></li>
<li><code><a title="code_documenter.Function.instances" href="#code_documenter.Function.instances">instances</a></code></li>
<li><code><a title="code_documenter.Function.matches_line_ixs" href="#code_documenter.Function.matches_line_ixs">matches_line_ixs</a></code></li>
<li><code><a title="code_documenter.Function.regex_begin" href="#code_documenter.Function.regex_begin">regex_begin</a></code></li>
<li><code><a title="code_documenter.Function.regex_end" href="#code_documenter.Function.regex_end">regex_end</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="code_documenter.MetaData" href="#code_documenter.MetaData">MetaData</a></code></h4>
<ul class="">
<li><code><a title="code_documenter.MetaData.date_of_process" href="#code_documenter.MetaData.date_of_process">date_of_process</a></code></li>
<li><code><a title="code_documenter.MetaData.documenter_version__author" href="#code_documenter.MetaData.documenter_version__author">documenter_version__author</a></code></li>
<li><code><a title="code_documenter.MetaData.documenter_version__author_date" href="#code_documenter.MetaData.documenter_version__author_date">documenter_version__author_date</a></code></li>
<li><code><a title="code_documenter.MetaData.documenter_version__commit" href="#code_documenter.MetaData.documenter_version__commit">documenter_version__commit</a></code></li>
<li><code><a title="code_documenter.MetaData.documenter_version__gitdir" href="#code_documenter.MetaData.documenter_version__gitdir">documenter_version__gitdir</a></code></li>
<li><code><a title="code_documenter.MetaData.documenter_version__message" href="#code_documenter.MetaData.documenter_version__message">documenter_version__message</a></code></li>
<li><code><a title="code_documenter.MetaData.documenter_version__parent" href="#code_documenter.MetaData.documenter_version__parent">documenter_version__parent</a></code></li>
<li><code><a title="code_documenter.MetaData.documenter_version__refs" href="#code_documenter.MetaData.documenter_version__refs">documenter_version__refs</a></code></li>
<li><code><a title="code_documenter.MetaData.documenter_version__tree" href="#code_documenter.MetaData.documenter_version__tree">documenter_version__tree</a></code></li>
<li><code><a title="code_documenter.MetaData.extract_date_of_change" href="#code_documenter.MetaData.extract_date_of_change">extract_date_of_change</a></code></li>
<li><code><a title="code_documenter.MetaData.extract_git_info" href="#code_documenter.MetaData.extract_git_info">extract_git_info</a></code></li>
<li><code><a title="code_documenter.MetaData.get_count_of_commits" href="#code_documenter.MetaData.get_count_of_commits">get_count_of_commits</a></code></li>
<li><code><a title="code_documenter.MetaData.get_input_filename" href="#code_documenter.MetaData.get_input_filename">get_input_filename</a></code></li>
<li><code><a title="code_documenter.MetaData.get_input_path" href="#code_documenter.MetaData.get_input_path">get_input_path</a></code></li>
<li><code><a title="code_documenter.MetaData.get_last_modified_timestamp" href="#code_documenter.MetaData.get_last_modified_timestamp">get_last_modified_timestamp</a></code></li>
<li><code><a title="code_documenter.MetaData.get_output_filename" href="#code_documenter.MetaData.get_output_filename">get_output_filename</a></code></li>
<li><code><a title="code_documenter.MetaData.get_output_path" href="#code_documenter.MetaData.get_output_path">get_output_path</a></code></li>
<li><code><a title="code_documenter.MetaData.initialize_class" href="#code_documenter.MetaData.initialize_class">initialize_class</a></code></li>
<li><code><a title="code_documenter.MetaData.input_file__date_of_change" href="#code_documenter.MetaData.input_file__date_of_change">input_file__date_of_change</a></code></li>
<li><code><a title="code_documenter.MetaData.make_output_filename" href="#code_documenter.MetaData.make_output_filename">make_output_filename</a></code></li>
<li><code><a title="code_documenter.MetaData.save_current_timestamp" href="#code_documenter.MetaData.save_current_timestamp">save_current_timestamp</a></code></li>
<li><code><a title="code_documenter.MetaData.set_input_path" href="#code_documenter.MetaData.set_input_path">set_input_path</a></code></li>
<li><code><a title="code_documenter.MetaData.set_output_dir" href="#code_documenter.MetaData.set_output_dir">set_output_dir</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="code_documenter.Procedure" href="#code_documenter.Procedure">Procedure</a></code></h4>
<ul class="">
<li><code><a title="code_documenter.Procedure.TEMPLATE" href="#code_documenter.Procedure.TEMPLATE">TEMPLATE</a></code></li>
<li><code><a title="code_documenter.Procedure.analyse_references" href="#code_documenter.Procedure.analyse_references">analyse_references</a></code></li>
<li><code><a title="code_documenter.Procedure.check_and_get_match" href="#code_documenter.Procedure.check_and_get_match">check_and_get_match</a></code></li>
<li><code><a title="code_documenter.Procedure.detail_analyse_procedures" href="#code_documenter.Procedure.detail_analyse_procedures">detail_analyse_procedures</a></code></li>
<li><code><a title="code_documenter.Procedure.extract_docstring" href="#code_documenter.Procedure.extract_docstring">extract_docstring</a></code></li>
<li><code><a title="code_documenter.Procedure.extract_line_numbers" href="#code_documenter.Procedure.extract_line_numbers">extract_line_numbers</a></code></li>
<li><code><a title="code_documenter.Procedure.extract_modifier" href="#code_documenter.Procedure.extract_modifier">extract_modifier</a></code></li>
<li><code><a title="code_documenter.Procedure.extract_name" href="#code_documenter.Procedure.extract_name">extract_name</a></code></li>
<li><code><a title="code_documenter.Procedure.extract_references" href="#code_documenter.Procedure.extract_references">extract_references</a></code></li>
<li><code><a title="code_documenter.Procedure.extract_source_code" href="#code_documenter.Procedure.extract_source_code">extract_source_code</a></code></li>
<li><code><a title="code_documenter.Procedure.finilize" href="#code_documenter.Procedure.finilize">finilize</a></code></li>
<li><code><a title="code_documenter.Procedure.generate_calling_entries" href="#code_documenter.Procedure.generate_calling_entries">generate_calling_entries</a></code></li>
<li><code><a title="code_documenter.Procedure.generate_documentation" href="#code_documenter.Procedure.generate_documentation">generate_documentation</a></code></li>
<li><code><a title="code_documenter.Procedure.generate_reference_entries" href="#code_documenter.Procedure.generate_reference_entries">generate_reference_entries</a></code></li>
<li><code><a title="code_documenter.Procedure.generate_toc_entries" href="#code_documenter.Procedure.generate_toc_entries">generate_toc_entries</a></code></li>
<li><code><a title="code_documenter.Procedure.identify_docstring" href="#code_documenter.Procedure.identify_docstring">identify_docstring</a></code></li>
<li><code><a title="code_documenter.Procedure.identify_procedures" href="#code_documenter.Procedure.identify_procedures">identify_procedures</a></code></li>
<li><code><a title="code_documenter.Procedure.initialize_input_code" href="#code_documenter.Procedure.initialize_input_code">initialize_input_code</a></code></li>
<li><code><a title="code_documenter.Procedure.initialize_page_top_text" href="#code_documenter.Procedure.initialize_page_top_text">initialize_page_top_text</a></code></li>
<li><code><a title="code_documenter.Procedure.initialize_toc" href="#code_documenter.Procedure.initialize_toc">initialize_toc</a></code></li>
<li><code><a title="code_documenter.Procedure.read_template" href="#code_documenter.Procedure.read_template">read_template</a></code></li>
<li><code><a title="code_documenter.Procedure.regex_ausschluss_kommentar" href="#code_documenter.Procedure.regex_ausschluss_kommentar">regex_ausschluss_kommentar</a></code></li>
<li><code><a title="code_documenter.Procedure.regex_begin_pattern" href="#code_documenter.Procedure.regex_begin_pattern">regex_begin_pattern</a></code></li>
<li><code><a title="code_documenter.Procedure.regex_end_pattern" href="#code_documenter.Procedure.regex_end_pattern">regex_end_pattern</a></code></li>
<li><code><a title="code_documenter.Procedure.search_end_of_procedure" href="#code_documenter.Procedure.search_end_of_procedure">search_end_of_procedure</a></code></li>
<li><code><a title="code_documenter.Procedure.search_for_begin" href="#code_documenter.Procedure.search_for_begin">search_for_begin</a></code></li>
<li><code><a title="code_documenter.Procedure.sort_procedures_by_names" href="#code_documenter.Procedure.sort_procedures_by_names">sort_procedures_by_names</a></code></li>
<li><code><a title="code_documenter.Procedure.write_to_file" href="#code_documenter.Procedure.write_to_file">write_to_file</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="code_documenter.Sub" href="#code_documenter.Sub">Sub</a></code></h4>
<ul class="">
<li><code><a title="code_documenter.Sub.KEYWORD_TYPE" href="#code_documenter.Sub.KEYWORD_TYPE">KEYWORD_TYPE</a></code></li>
<li><code><a title="code_documenter.Sub.TEMPLATE_SECTION_HEAD" href="#code_documenter.Sub.TEMPLATE_SECTION_HEAD">TEMPLATE_SECTION_HEAD</a></code></li>
<li><code><a title="code_documenter.Sub.all_procedures_final" href="#code_documenter.Sub.all_procedures_final">all_procedures_final</a></code></li>
<li><code><a title="code_documenter.Sub.instances" href="#code_documenter.Sub.instances">instances</a></code></li>
<li><code><a title="code_documenter.Sub.matches_line_ixs" href="#code_documenter.Sub.matches_line_ixs">matches_line_ixs</a></code></li>
<li><code><a title="code_documenter.Sub.regex_begin" href="#code_documenter.Sub.regex_begin">regex_begin</a></code></li>
<li><code><a title="code_documenter.Sub.regex_end" href="#code_documenter.Sub.regex_end">regex_end</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a> on 2024-01-03 05:01:10.</p>
</footer>
</body>
</html>