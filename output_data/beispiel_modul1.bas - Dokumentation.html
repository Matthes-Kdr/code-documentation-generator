<h1>Code-Dokumentation: Modul '@PLACEHOLDER_INPUT_FILE@'</h1>
<!-- TODO: Platzhalter ersetzen! -->

<p><strong>TODO:</strong> Organisatorische Hinweise zur Verwendeten bzw. dokumentierten Datei.</p>
<p>Erstellungsdatum dieser Dokumentation: @PLACEHOLDER_TIMESTAMP_NOW@</p>
<!-- TODO: Platzhalter ersetzen! -->
<p>(DAS KOMMT IN DEN TAIL!!! SIEHE FUSSZEILE!)</p>
<p>Die hier dokumentierte Quelldatei wurde vor dieser automatischen Dokumentationserstellung zuletzt modifiziert am @PLACEHOLDER_TIMESTAMP_SOURCEFILE@</p>
<!-- TODO: Platzhalter ersetzen! -->

<blockquote>
<p><strong>ACHTUNG.</strong> 
Das Tool für die automatisierte Erstellung der Dokumentation ist noch nicht fertig! 
Für weitere Infos: Siehe Schlussbemerkungen!</p>
</blockquote>
<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- Index / TOC -->
<!-- --------------------------------------------------------------- -->

<h2>Index / Table Of Content</h2>
<p>Alphabetische und verlinkte Auflistung aller Subs und Functions, die in diesem Modul verwendet werden:</p>
<ul>
<li><a href="#sec_modulinfos"><strong>Modulinformationen / Modulkopf</strong></a></li>
</ul>
<!-- ---------- SUBS: --------------- -->

<ul>
<li>
<p><a href="#sec_subs"><strong>Subs</strong></a> (16)</p>
</li>
<li>
<p><a href="#InsertImageFromFileToCell"><code>InsertImageFromFileToCell</code></a> <small>(Zeile 833)</small></p>
</li>
<li><a href="#SeitenformatNextPosition"><code>SeitenformatNextPosition</code></a> <small>(Zeile 775)</small></li>
<li><a href="#THIS_VERSION__1_17"><code>THIS_VERSION__1_17</code></a> <small>(Zeile 1220)</small></li>
<li><a href="#applyLayoutPrintArea"><code>applyLayoutPrintArea</code></a> <small>(Zeile 247)</small></li>
<li><a href="#applyLayoutToAllPages"><code>applyLayoutToAllPages</code></a> <small>(Zeile 136)</small></li>
<li><a href="#applyLayoutToSinglePage"><code>applyLayoutToSinglePage</code></a> <small>(Zeile 161)</small></li>
<li><a href="#erstelleKonvertierteSeite"><code>erstelleKonvertierteSeite</code></a> <small>(Zeile 655)</small></li>
<li><a href="#init"><code>init</code></a> <small>(Zeile 119)</small></li>
<li><a href="#insertFrameLineBelow"><code>insertFrameLineBelow</code></a> <small>(Zeile 1011)</small></li>
<li><a href="#insertSheet"><code>insertSheet</code></a> <small>(Zeile 274)</small></li>
<li><a href="#mergeCells"><code>mergeCells</code></a> <small>(Zeile 320)</small></li>
<li><a href="#modifyReplacerIfSonderzeichen"><code>modifyReplacerIfSonderzeichen</code></a> <small>(Zeile 535)</small></li>
<li><a href="#modifyReplacerIfTaktwechsel"><code>modifyReplacerIfTaktwechsel</code></a> <small>(Zeile 578)</small></li>
<li><a href="#notengriffeErzeugen"><code>notengriffeErzeugen</code></a> <small>(Zeile 1169)</small></li>
<li><a href="#printLastSheetsAsPdf"><code>printLastSheetsAsPdf</code></a> <small>(Zeile 1081)</small></li>
<li><a href="#resetWorkbook"><code>resetWorkbook</code></a> <small>(Zeile 87)</small></li>
</ul>
<!-- ---------- FUNCTIONS: --------------- -->

<ul>
<li>
<p><a href="#sec_functions"><strong>Functions</strong></a> (17)</p>
</li>
<li>
<p><a href="#addSeitenformat"><code>addSeitenformat</code></a> <small>(Zeile 964)</small></p>
</li>
<li><a href="#areaEmpty"><code>areaEmpty</code></a> <small>(Zeile 800)</small></li>
<li><a href="#existsSheetname"><code>existsSheetname</code></a> <small>(Zeile 300)</small></li>
<li><a href="#getCountsOfColumnsToPrint"><code>getCountsOfColumnsToPrint</code></a> <small>(Zeile 235)</small></li>
<li><a href="#getFilePath"><code>getFilePath</code></a> <small>(Zeile 338)</small></li>
<li><a href="#getModifiedKeyIfTaktwechsel"><code>getModifiedKeyIfTaktwechsel</code></a> <small>(Zeile 622)</small></li>
<li><a href="#getProjectTitle"><code>getProjectTitle</code></a> <small>(Zeile 79)</small></li>
<li><a href="#getReplacerCount"><code>getReplacerCount</code></a> <small>(Zeile 482)</small></li>
<li><a href="#getReplacerEmpty"><code>getReplacerEmpty</code></a> <small>(Zeile 516)</small></li>
<li><a href="#getReplacerNote"><code>getReplacerNote</code></a> <small>(Zeile 451)</small></li>
<li><a href="#getReplacerPost"><code>getReplacerPost</code></a> <small>(Zeile 500)</small></li>
<li><a href="#getReplacerPre1"><code>getReplacerPre1</code></a> <small>(Zeile 378)</small></li>
<li><a href="#getReplacerPre2"><code>getReplacerPre2</code></a> <small>(Zeile 441)</small></li>
<li><a href="#getTypeOfFollowingSeperatorLine"><code>getTypeOfFollowingSeperatorLine</code></a> <small>(Zeile 1044)</small></li>
<li><a href="#identifyLastRow"><code>identifyLastRow</code></a> <small>(Zeile 867)</small></li>
<li><a href="#konvertiereZeile"><code>konvertiereZeile</code></a> <small>(Zeile 696)</small></li>
<li><a href="#newSeitenformat"><code>newSeitenformat</code></a> <small>(Zeile 896)</small></li>
</ul>
<!-- ---------- TAIL: --------------- -->

<ul>
<li><a href="#sec_tail"><strong>Schlussbemerkungen</strong> (inkl. Angaben zum Entwicklungszustand des Code-Dokumenter-Tools)</a></li>
</ul>
<p>﻿</p>
<p><a name="sec_modulinfos"></a></p>
<h2>Modulbeschreibung</h2>
<p>@author: Matthias Kader</p>
<p>﻿</p>
<!-- -------------------------------------------------- -->
<!-- SECTION-START : FUNCTIONS -->
<!-- -------------------------------------------------- -->

<p><a name="sec_functions"></a></p>
<h2>Functions</h2>
<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="InsertImageFromFileToCell"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Sub InsertImageFromFileToCell</code></span><small>(Zeile 833)</small></p>
<div style="padding-left:2em;">

>  Private Sub InsertImageFromFileToCell(zeile As Integer, spalte As Integer, image_path As String)




<details>

<summary> Referenzierungen dieser Prozedur (1)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```konvertiereZeile```](#konvertiereZeile) : <small>  Zeile 744 : ```                Call InsertImageFromFileToCell(oSeite.excelZeilenNr, zielspalte, pathImage, oReplacer.cellFitTo)``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Sub InsertImageFromFileToCell(zeile As Integer, spalte As Integer, image_path As String, Optional fitTo As String = "Width")
' Private Sub InsertImageFromFileToCell(zeile As Integer, spalte As Integer, image_path As String)

    'Dim image_path As Variant
    Dim oPic As Shape
    Dim img As Variant
    wsResult.Cells(zeile, spalte).Select  ' Zielzelle markieren
    Set img = wsResult.Shapes.AddPicture(Filename:=image_path, LinkToFile:=msoFalse, SaveWithDocument:=msoTrue, Left:=Selection.Left, Top:=Selection.Top, Width:=-1, Height:=-1)



    ' Groesse zu Zelle ziehen
    With img
        .LockAspectRatio = msoTrue

        If fitTo = "Width" Then
            .Width = .TopLeftCell.Width ' Breite der Bild-Zelle
        Else
            .Height = .TopLeftCell.Height ' Breite der Bild-Zelle
        End If

        .Placement = xlMoveAndSize ' weiss nicht genau wofuer?
    End With




End Sub

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="SeitenformatNextPosition"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Sub SeitenformatNextPosition</code></span><small>(Zeile 775)</small></p>
<div style="padding-left:2em;">

>  Modifiziert die Attribute des Objektes so, dass die naechste Position in den Attributen gespeichert wird




<details>

<summary> Referenzierungen dieser Prozedur (1)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```konvertiereZeile```](#konvertiereZeile) : <small>  Zeile 767 : ```    Call SeitenformatNextPosition(oSeite)``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Sub SeitenformatNextPosition(oSeite As Seitenformat)
' Modifiziert die Attribute des Objektes so, dass die naechste Position in den Attributen gespeichert wird

    If oSeite.zeilengruppe + 1 > oSeite.anzahlZeilen Then
        ' Reset zeilen fuer neue Spalte
        oSeite.zeilengruppe = 1
        oSeite.spaltengruppe = oSeite.spaltengruppe + 1

        If oSeite.spaltengruppe > oSeite.anzahlSpalten Then
            oSeite.finished = True
        End If
    Else
        oSeite.zeilengruppe = oSeite.zeilengruppe + 1
    End If

    oSeite.excelZeilenNr = oSeite.zeilengruppe + oSeite.excelStartZeilenNr - 1

End Sub

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="THIS_VERSION__1_17"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Sub THIS_VERSION__1_17</code></span><small>(Zeile 1220)</small></p>
<div style="padding-left:2em;">

>  Dummy-Methode, um Versionsnummer in MacroList anzeigen zu lassen...




<details>

<summary> Referenzierungen dieser Prozedur (0)</summary>

<div style="padding-left:1em;">



Kein Aufruf gefunden.







</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Sub THIS_VERSION__1_17()
' Dummy-Methode, um Versionsnummer in MacroList anzeigen zu lassen...

End Sub

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="applyLayoutPrintArea"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Sub applyLayoutPrintArea</code></span><small>(Zeile 247)</small></p>
<div style="padding-left:2em;">

>  Legt den Druckbereich der einzelnen Seite fest, in Abhängigkeit der tatsaechlich vorhandenen Anzahl von Spalten:




<details>

<summary> Referenzierungen dieser Prozedur (1)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```notengriffeErzeugen```](#notengriffeErzeugen) : <small>  Zeile 1192 : ```        Call applyLayoutPrintArea(oSeite)``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Sub applyLayoutPrintArea(oSeite As Seitenformat)
    ' Legt den Druckbereich der einzelnen Seite fest, in Abhängigkeit der tatsaechlich vorhandenen Anzahl von Spalten:


    Dim anzahlColumnsToPrint As Integer
    Dim lastRowToPrint As Integer

    anzahlColumnsToPrint = getCountsOfColumnsToPrint(oSeite)
    lastRowToPrint = oSeite.excelStartZeilenNr + oSeite.maxAnzahlZeilen - 1

    With wsResult.PageSetup

        If oSeite.ausrichtung = "Querformat" Then
            .Orientation = xlLandscape
        Else
            .Orientation = xlPortrait
        End If

        .PrintArea = Range(Cells(1, 1), Cells(lastRowToPrint, anzahlColumnsToPrint)).Address

    End With

End Sub

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="applyLayoutToAllPages"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Sub applyLayoutToAllPages</code></span><small>(Zeile 136)</small></p>
<div style="padding-left:2em;">

>  Durchlaeuft alle erstellten Tabellenblaetter und schleust durch zu einer Anwendungsfunktion, die wiederum  den Titel und andere Dinge in diese Blaetter  ein. Als oSeite wird das zuletzt-verwendete Objekt verwendet - benoetigt werden neben den ALLGEMEINEN UND KONSTANTEN Attributen nur die Angabe der pageNum als Gesamtseitenzahl.
 Zusaetzlich wird AUSSERHALB DES DRUCKBEREICHES auch ein Hyperlink zur Steuertabelle eingefuegt...




<details>

<summary> Referenzierungen dieser Prozedur (1)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```notengriffeErzeugen```](#notengriffeErzeugen) : <small>  Zeile 1201 : ```    Call applyLayoutToAllPages(oSeite)``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Sub applyLayoutToAllPages(oSeite As Seitenformat)
    ' Durchlaeuft alle erstellten Tabellenblaetter und schleust durch zu einer Anwendungsfunktion, die wiederum  den Titel und andere Dinge in diese Blaetter  ein. Als oSeite wird das zuletzt-verwendete Objekt verwendet - benoetigt werden neben den ALLGEMEINEN UND KONSTANTEN Attributen nur die Angabe der pageNum als Gesamtseitenzahl.
    ' Zusaetzlich wird AUSSERHALB DES DRUCKBEREICHES auch ein Hyperlink zur Steuertabelle eingefuegt...

    Dim page As Integer
    Dim pagesTotal As Integer
    Dim ws As Worksheet

    pagesTotal = pageNum ' Abgreifen aus dem letzten Durchlauf.

    For page = 1 To pagesTotal

        Set ws = Sheets(Sheets.Count - pagesTotal + page)
        ' Anwenden der Layout-Methode, in der auch die Positionierung der Elemente definiert ist:
        Call applyLayoutToSinglePage(ws, page, oSeite)

    Next page

End Sub

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="applyLayoutToSinglePage"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Sub applyLayoutToSinglePage</code></span><small>(Zeile 161)</small></p>
<div style="padding-left:2em;">

>  Zusaetzlich wird AUSSERHALB DES DRUCKBEREICHES auch ein Hyperlink zur Steuertabelle eingefuegt...




<details>

<summary> Referenzierungen dieser Prozedur (1)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```applyLayoutToAllPages```](#applyLayoutToAllPages) : <small>  Zeile 150 : ```        Call applyLayoutToSinglePage(ws, page, oSeite)``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Sub applyLayoutToSinglePage(wsResult As Worksheet, thisPageNum As Integer, oSeite As Seitenformat)
    ' Zusaetzlich wird AUSSERHALB DES DRUCKBEREICHES auch ein Hyperlink zur Steuertabelle eingefuegt...

    Dim zielspalteHyperlink As Integer

    zielspalteHyperlink = oSeite.excelStartSpaltenNr + oSeite.maxAnzahlSpalten * oSeite.anzahlSubSpaltenProSpalte + 2

    ' Eintragung des Hyperlinkes zur Steuertabelle - ausserhalb des Sdruckbereiches:
    wsResult.Hyperlinks.Add Anchor:=wsResult.Cells(1, zielspalteHyperlink), Address:="", SubAddress:= _
        "STEUERTABELLE!A1", TextToDisplay:="<-- Zurueck zur Steuertabelle..."


    Dim pagesTotal As Integer
    pagesTotal = pageNum

    ' Berechnung der Gesamtspalten, ueber die zentrierte Texte verbunden + zentriert werden soll:
    Dim anzahlColumnsToMerge As Integer
    ' Die letzte "luft"-Spalte wird abgezogen, weil nach der letzten Spalte keine Luft notwendigt ist! (Blattrand!)
    anzahlColumnsToMerge = getCountsOfColumnsToPrint(oSeite)


    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' TITEL EINTRAGEN:
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Der Titel soll in ZEile 1 mittig ueber dem Blatt stehen.
    ' Um genau mittig zu sein, wird der Text in Zelle A1 eingetragen und alle Zellen der ersten Spalte anschliessend verbunden werden.
    Dim titelZeile As Integer, titelSpalte As Integer, titel As String

    titelZeile = 1
    titelSpalte = 1
    titel = oSeite.titel

    wsResult.Cells(titelZeile, titelSpalte) = titel

    Call mergeCells(wsResult, titelZeile, titelSpalte, titelZeile, anzahlColumnsToMerge)


    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' SEITE EINTRAGEN:
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Die Seitenzahl soll in Zeile 2 mittig ueber dem Blatt stehen.
    ' Um genau mittig zu sein, wird der Text in Zelle A2 eingetragen und alle Zellen der ersten Spalte anschliessend verbunden werden.
    Dim seitenangabeZeile As Integer, seitenangabeSpalte As Integer, seitenangabe As String

    seitenangabeZeile = 2
    seitenangabeSpalte = 1
    seitenangabe = "Seite " & thisPageNum & " von " & pagesTotal

    wsResult.Cells(seitenangabeZeile, seitenangabeSpalte) = seitenangabe

    Call mergeCells(wsResult, seitenangabeZeile, seitenangabeSpalte, seitenangabeZeile, anzahlColumnsToMerge)


    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' ZUSATZTEXT EINTRAGEN:
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Der Zusatztext soll in Zeile 3 linksbuendig
    Dim zusatztextZeile As Integer, zusatztextSpalte As Integer, zusatztext As String
    zusatztext = oSeite.zusatztext

    zusatztextZeile = 3
    zusatztextSpalte = 1
    zusatztext = oSeite.zusatztext

    wsResult.Cells(zusatztextZeile, zusatztextSpalte) = zusatztext

End Sub

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="erstelleKonvertierteSeite"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Sub erstelleKonvertierteSeite</code></span><small>(Zeile 655)</small></p>
<div style="padding-left:2em;">

>  Erstelle neues TBB und wende Atrriubte an




<details>

<summary> Referenzierungen dieser Prozedur (1)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```notengriffeErzeugen```](#notengriffeErzeugen) : <small>  Zeile 1191 : ```        Call erstelleKonvertierteSeite(startzeileSteuertabelle, oSeite)``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Sub erstelleKonvertierteSeite(startzeileSteuertabelle As Integer, oSeite As Seitenformat)
    ' Erstelle neues TBB und wende Atrriubte an

    Dim zeileSteuertabelle As Integer
    'Dim ignoreLine  As Integer

        pageNum = pageNum + 1
        Call insertSheet(oSeite.blattname & pageNum)

        ' '  BUGFIX: In VBA werden die Bedingungen einer For-Schleife immer nur einmalig beim Beginn der Schleife ausgewertet! Somit wird nicht reagiert, sofern der "BIS-Wert" sich veraendert!
        ' ' BUGFIX: Daher ForSchleife in While-Schleife umgewandelt:
        'For zeileSteuertabelle = startzeileSteuertabelle To startzeileSteuertabelle + oSeite.maxAnzahlEintraege + countOfSkippedLinesTodo
        zeileSteuertabelle = startzeileSteuertabelle
        Do While zeileSteuertabelle <= startzeileSteuertabelle + oSeite.maxAnzahlEintraege + oSeite.countOfSkippedLinesTodo

            If oSeite.finished = True Then

                Exit Sub ' springe zurueck in die Loop des mains: noengriffeErzeugen"

            End If


            If konvertiereZeile(zeileSteuertabelle, oSeite) = False Then

                ' dann ist naechste Zeile ist leer, daher wird die Laufvariable zusaetzlich um eins erhoeht, ehe sie ohnehin durch den Schleifendurchlauf inkrementiert wird
                zeileSteuertabelle = zeileSteuertabelle + 1

            End If

            zeileSteuertabelle = zeileSteuertabelle + 1

        'Next zeileSteuertabelle ' BUGFIX: Siehe oben...
        Loop


End Sub

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="init"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Sub init</code></span><small>(Zeile 119)</small></p>
<div style="padding-left:2em;">

>  Parameter fuer modulweite Variablen laden




<details>

<summary> Referenzierungen dieser Prozedur (0)</summary>

<div style="padding-left:1em;">



Kein Aufruf gefunden.







</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Sub init()
    ' Parameter fuer modulweite Variablen laden

    ' Vorlage fuer Format:
    Set wsTemplate = Worksheets("TEMPLATE_LAYOUT")


    ' TODO-Tabellenblatt:
    Set wsTodo = Worksheets("STEUERTABELLE")

    ' Seitenzahl:
    pageNum = 0

End Sub

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="insertFrameLineBelow"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Sub insertFrameLineBelow</code></span><small>(Zeile 1011)</small></p>
<div style="padding-left:2em;">

>  Fuegt die unteren Rahmenlinien aller Zellen dieser Zeile im Subspaltenbereich ein




<details>

<summary> Referenzierungen dieser Prozedur (1)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```konvertiereZeile```](#konvertiereZeile) : <small>  Zeile 762 : ```        Call insertFrameLineBelow(zeileSteuertabelle, oSeite, CBool(followingLineStyle - 1))``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Sub insertFrameLineBelow(rowAbove As Integer, oSeite As Seitenformat, dashed As Boolean)
    ' Fuegt die unteren Rahmenlinien aller Zellen dieser Zeile im Subspaltenbereich ein

    Dim column As Integer
    Dim columnStart As Integer
    columnStart = (oSeite.spaltengruppe - 1) * oSeite.anzahlSubSpaltenProSpalte + 1

    For column = columnStart To columnStart + oSeite.anzahlSubSpaltenProSpalte - 2

        With wsResult.Cells(oSeite.excelZeilenNr, column).Borders(xlEdgeBottom)

            .ColorIndex = 0
            .TintAndShade = 0
            .Weight = xlThin
            .LineStyle = xlContinuous ' durchgezogen
            If dashed = True Then
                ' .LineStyle = xlDot ' gestrichelt
                .LineStyle = xlDashDotDot ' Strich-Punkt-Punkt
            End If

        End With

    Next column


End Sub

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="insertSheet"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Sub insertSheet</code></span><small>(Zeile 274)</small></p>
<div style="padding-left:2em;">

>  Fuegt ein neues Tabellenblatt hinzu mit dem uebergebenen Namen und modifiziert den Tabellenblattnamen, sofern dieser bereits existiert




<details>

<summary> Referenzierungen dieser Prozedur (1)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```erstelleKonvertierteSeite```](#erstelleKonvertierteSeite) : <small>  Zeile 662 : ```        Call insertSheet(oSeite.blattname & pageNum)``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Sub insertSheet(sheetname As String)
    ' Fuegt ein neues Tabellenblatt hinzu mit dem uebergebenen Namen und modifiziert den Tabellenblattnamen, sofern dieser bereits existiert

    wsTemplate.Copy After:=Sheets(Sheets.Count)
    Set wsResult = Sheets(Sheets.Count)

    Dim i As Integer
    i = 1
    Do
        If existsSheetname(sheetname) = False Then
            Exit Do
        End If

        sheetname = sheetname & i
        i = i + 1

    Loop

    ' # AUSBLICK: Fehlervermeidung bzgl. Sonderzeichen und max. Zeichenanzahl
    wsResult.name = sheetname

End Sub

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="mergeCells"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Sub mergeCells</code></span><small>(Zeile 320)</small></p>
<div style="padding-left:2em;">

>  Verbindet den uebergebenen Zellbereich




<details>

<summary> Referenzierungen dieser Prozedur (2)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```applyLayoutToSinglePage```](#applyLayoutToSinglePage) : <small>  Zeile 195 : ```    Call mergeCells(wsResult, titelZeile, titelSpalte, titelZeile, anzahlColumnsToMerge)``` </small>
* [```applyLayoutToSinglePage```](#applyLayoutToSinglePage) : <small>  Zeile 211 : ```    Call mergeCells(wsResult, seitenangabeZeile, seitenangabeSpalte, seitenangabeZeile, anzahlColumnsToMerge)``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Sub mergeCells(ws As Worksheet, lineFrom As Integer, columnFrom As Integer, lineTo As Integer, columnTo As Integer)
    ' Verbindet den uebergebenen Zellbereich

    Dim cellTopLeft As Range
    Dim cellBottomRight As Range

    Set cellTopLeft = ws.Cells(lineFrom, columnFrom)
    Set cellBottomRight = ws.Cells(lineTo, columnTo)

    ' Verbinden der Zellen:
    Range(cellTopLeft, cellBottomRight).Merge

End Sub

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="modifyReplacerIfSonderzeichen"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Sub modifyReplacerIfSonderzeichen</code></span><small>(Zeile 535)</small></p>
<div style="padding-left:2em;">

>  Prueft, ob das Stichwort einem definierten Sonderzeichen entspricht.
 Jedes definierte Sonderzeichen erhaelt ein expliziten Bild-Dateiname als Verknuepfung (ohne Dateiendung hier.)
 ACHTUNG: Die keys sind case-INSENSITIV , es gelten also immer gross und kleinscheibung fuer die keys!




<details>

<summary> Referenzierungen dieser Prozedur (1)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```getReplacerPre1```](#getReplacerPre1) : <small>  Zeile 419 : ```    Call modifyReplacerIfSonderzeichen(oErsatz)``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Sub modifyReplacerIfSonderzeichen(oReplacer As Replacer)
    ' Prueft, ob das Stichwort einem definierten Sonderzeichen entspricht.
    ' Jedes definierte Sonderzeichen erhaelt ein expliziten Bild-Dateiname als Verknuepfung (ohne Dateiendung hier.)
    ' ACHTUNG: Die keys sind case-INSENSITIV , es gelten also immer gross und kleinscheibung fuer die keys!


    ' modifyReplacerIfSonderzeichen = False 'default initial: Fuer den Fall dass es KEIN Sonderzeichen ist.

    Dim keysAndReplacers() As Variant
    ' Aufbau des Arrays: ("Key1", "imageNameForKey1, "key2", "imageNameForKey2", ...)

    keysAndReplacers = Array("X", "paukenschlag", _
        "signum", "signum", _
        "segno", "segno", _
        "coda", "coda")


    Dim i As Integer
    Dim stichwort As String
    stichwort = oReplacer.value
    For i = LBound(keysAndReplacers) To UBound(keysAndReplacers) Step 2

        If UCase(oReplacer.value) = UCase(keysAndReplacers(i)) Then
            ' Dann ersetze das Stichwot (oReplacer.value) durch das Ersatz-Stichwort:
            oReplacer.value = keysAndReplacers(i + 1)
            oReplacer.isImage = True

            ' modifyReplacerIfSonderzeichen = True
            ' Merker, dass es einen Taktartwechsel gegeben hat.
            Exit Sub
            ' Exit Function

        End If


    Next i

' End Function
End Sub

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="modifyReplacerIfTaktwechsel"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Sub modifyReplacerIfTaktwechsel</code></span><small>(Zeile 578)</small></p>
<div style="padding-left:2em;">

>  Prueft, ob das Stichwort einem Taktartwechsel entspricht.
 Je nach Taktart wird das uebergebene Replacer-Objekt inplace modifiziert und zurueckgegeben (mal wird ein Bild gewuenscht, mal nciht...)
 ALLE MOEGLICHEN Taktarten muessen EXPLIZIT IM ARRAY definiert sein (keysAndReplacers), damit sie als solche erkannt wird!




<details>

<summary> Referenzierungen dieser Prozedur (1)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```getReplacerPre1```](#getReplacerPre1) : <small>  Zeile 422 : ```    Call modifyReplacerIfTaktwechsel(oErsatz)``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Sub modifyReplacerIfTaktwechsel(oReplacer As Replacer)
    ' Prueft, ob das Stichwort einem Taktartwechsel entspricht.
    ' Je nach Taktart wird das uebergebene Replacer-Objekt inplace modifiziert und zurueckgegeben (mal wird ein Bild gewuenscht, mal nciht...)
    ' ALLE MOEGLICHEN Taktarten muessen EXPLIZIT IM ARRAY definiert sein (keysAndReplacers), damit sie als solche erkannt wird!


    Dim keysAndReplacers() As Variant
    ' Aufbau des Arrays: ("Key1", "IMG:ersatzString1, "key2", "IMG:ersatz2", ...) wobei immer wenn ein Bild eingefuegt werden soll ein "IMG:" davor steht, sonst nicht, dann wird ein Apostroph vorangestellt
    keysAndReplacers = Array("TC|", "IMG:allabreve", _
    "T3/4", "'3/4", _
        "T4/4", "'4/4", _
        "T6/8", "'6/8", _
        "T3/8", "'3/8", _
    "TC", "IMG:TC")

    Dim i As Integer
    Dim stichwort As String
    stichwort = oReplacer.value
    For i = LBound(keysAndReplacers) To UBound(keysAndReplacers) Step 2

        If stichwort = keysAndReplacers(i) Then
            ' Dann ersetze das Stichwot durch das Ersatz-Stichwort:
            stichwort = keysAndReplacers(i + 1)
            ' pruefe, ob bei diesem Ersatz-Stichwort ein Bild verwendet werden soll oder nicht:
            If Left(stichwort, 4) = "IMG:" Then
                oReplacer.isImage = True
                oReplacer.value = Right(stichwort, Len(stichwort) - 4)
            Else
                oReplacer.isImage = False
                oReplacer.value = stichwort
            End If

            ' modifyReplacerIfTaktwechsel = True
            ' Merker, dass es einen Taktartwechsel gegeben hat.
            Exit Sub

        End If

    Next i
End Sub

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="notengriffeErzeugen"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Public Sub notengriffeErzeugen</code></span><small>(Zeile 1169)</small></p>
<div style="padding-left:2em;">

> *No information availible. For more information expand source code.*



<details>

<summary> Referenzierungen dieser Prozedur (0)</summary>

<div style="padding-left:1em;">



Kein Aufruf gefunden.







</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Public Sub notengriffeErzeugen()

    ' Initialisieren der modulweiten Variablen (Worksheets usw...)
    Call init

    Dim oSeite As Seitenformat
    Dim startzeileSteuertabelle As Integer
    startzeileSteuertabelle = 30


    Do
        ' Endlosschleife, bis eine Seite generiert werden wuerde, auf der kein Eintrag zu finden ist.

        ' Erstelle eine neues Seitenformat-Objekts:
        oSeite = addSeitenformat(startzeileSteuertabelle)


        If oSeite.anzahlEintraege <= 0 Then
            Exit Do ' Ende der STB erreicht
        End If


        Call erstelleKonvertierteSeite(startzeileSteuertabelle, oSeite)
        Call applyLayoutPrintArea(oSeite)

        startzeileSteuertabelle = startzeileSteuertabelle + oSeite.maxAnzahlEintraege + oSeite.countOfSkippedLinesTodo
        ' BUGFIX ab Version 1.10: Die countOfSkippedLinesTodo wird nie zurueckgesetzt. Aber die startzeileSteuertabelle ist immer relativ PRO KONVERTIERTE ERGEBNISSEITE. Also muss die Variable immer beim Neuerschaffung einer neuen Seite zurueckgesetzt werden. Alternative: Speichern in oSeite-Objekt

    Loop

    ' Damit es nicht in mehreren Durchlaeufen passieren wird, wird der gesamte Text am Ende - nach Erstellen aller Seiten ergaenzt auf jede Seite. Damit ist die Gesamtanzahl der erstellten Seiten bereits bekannt und es muss nichts mehrfach definiert werden!
    ' call addPageNumbers()
    Call applyLayoutToAllPages(oSeite)

    wsResult.Activate

    ''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Abfrage zur PDF-Export-Funktion:
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''
    If wsTodo.Cells(1, 26) = True Then
        ' In dieser ZElle ist die Zellverknuepfung mit der Checkbox fuer die Export-Funktion.
        Call printLastSheetsAsPdf(pageNum)
    End If


    MsgBox "Herzlichen Glueckwunsch (nachtraeglich) zum Geburtstag ;-) <3." & vbCrLf & vbCrLf & "Umwandlung abgeschlossen." & vbCrLf & vbCrLf & "Sofern das Ergebnis (nochmals) als PDF exportiert werden sollte, muss die Checkbox in Zeile 1 der Steuertabelle aktiviert werden und die Umwandlung erneut durchgefuehrt werden. (Aktuell gibt es kein Automatismusm um bereits erstellte Tabellenblaetter automatisiert zu exportieren. Manuelle Version: Markieren aller relevanten Tabellenblaetter (mittels Strg + Anklicken), danach auf Drucken, unter den Einstellungen 'Aktive Blaetter drucken' auswaehlen und die Skalierung so stellen, dass alle SPALTEN auf einer Seite dargestellt werden...) --> oder eben abweichend nach Bedarf ;-)", vbOK, getProjectTitle()


End Sub

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="printLastSheetsAsPdf"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Public Sub printLastSheetsAsPdf</code></span><small>(Zeile 1081)</small></p>
<div style="padding-left:2em;">

>  Speichert die hintersten (ERgebnis-Tabellenblaetter) als PDF ab, inkl. Skalierung auf eine Seite der Spalten.




<details>

<summary> Referenzierungen dieser Prozedur (1)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```notengriffeErzeugen```](#notengriffeErzeugen) : <small>  Zeile 1210 : ```        Call printLastSheetsAsPdf(pageNum)``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Sub printLastSheetsAsPdf(anzahlSheets As Integer)
' Speichert die hintersten (ERgebnis-Tabellenblaetter) als PDF ab, inkl. Skalierung auf eine Seite der Spalten.

    Dim sheetnames() As Variant
    Dim i As Integer


    ReDim sheetnames(1 To anzahlSheets)

    For i = 1 To anzahlSheets

        sheetnames(i) = Sheets(Sheets.Count - anzahlSheets + i).name

    Next i

    Sheets(sheetnames).Select
    Sheets(Sheets.Count).Activate

    Application.PrintCommunication = False

    With ActiveSheet.PageSetup
        .LeftHeader = ""
        .CenterHeader = ""
        .RightHeader = ""
        .LeftFooter = ""
        .CenterFooter = ""
        .RightFooter = ""

        ' # HACK:  Sofer ein anderes Layout gewaehlt werden soll, muss es  hier umgestellt werden (oder mittels MAcroRekorder!)
        .LeftMargin = Application.InchesToPoints(0.7)
        .RightMargin = Application.InchesToPoints(0.7)
        .TopMargin = Application.InchesToPoints(0.787401575)
        .BottomMargin = Application.InchesToPoints(0.787401575)
        .HeaderMargin = Application.InchesToPoints(0.3)
        .FooterMargin = Application.InchesToPoints(0.3)


        .PrintHeadings = False
        .PrintGridlines = False
        .PrintComments = xlPrintNoComments
        .PrintQuality = 600
        .CenterHorizontally = False
        .CenterVertically = False
        ' .Orientation = xlLandscape ' auskommentiert, da vorher bereits gesettet, und hier wuerde es ueberschrieben werden
        .Draft = False
        .PaperSize = xlPaperA4
        .FirstPageNumber = xlAutomatic
        .Order = xlDownThenOver
        .BlackAndWhite = False
        .Zoom = False
        .FitToPagesWide = 1 ' Alternativwert = 0. Aber hier 1, da alle Spalten auf ein Seite angepasst werden sollen
        .FitToPagesTall = 1 ' Alternativwert = 0. Aber hier 1, da alle Zeilen auf ein Seite angepasst werden sollen
        .PrintErrors = xlPrintErrorsDisplayed
        .OddAndEvenPagesHeaderFooter = False
        .DifferentFirstPageHeaderFooter = False
        .ScaleWithDocHeaderFooter = True
        .AlignMarginsHeaderFooter = True
        .EvenPage.LeftHeader.Text = ""
        .EvenPage.CenterHeader.Text = ""
        .EvenPage.RightHeader.Text = ""
        .EvenPage.LeftFooter.Text = ""
        .EvenPage.CenterFooter.Text = ""
        .EvenPage.RightFooter.Text = ""
        .FirstPage.LeftHeader.Text = ""
        .FirstPage.CenterHeader.Text = ""
        .FirstPage.RightHeader.Text = ""
        .FirstPage.LeftFooter.Text = ""
        .FirstPage.CenterFooter.Text = ""
        .FirstPage.RightFooter.Text = ""

    End With

    Application.PrintCommunication = True
    ActiveWindow.SelectedSheets.PrintOut Copies:=1, Collate:=True, IgnorePrintAreas:=False

End Sub

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="resetWorkbook"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Public Sub resetWorkbook</code></span><small>(Zeile 87)</small></p>
<div style="padding-left:2em;">

> *No information availible. For more information expand source code.*



<details>

<summary> Referenzierungen dieser Prozedur (0)</summary>

<div style="padding-left:1em;">



Kein Aufruf gefunden.







</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Sub resetWorkbook()

    If InputBox("Sollen alle generierten Tabellenblaetter UNWIDERUFLICH ENTFERNT werden? (dann eingabe von: 'y', sonst was beliebiges anderes)", getProjectTitle()) <> "y" Then
        Exit Sub
    End If
    Application.DisplayAlerts = False


    Dim i As Integer

    Do Until Sheets.Count = 3
        ' Auffuehrung der Namen aller Tabellenbletter, die beim Reset NICHT entfernt werden sollen.
        If Sheets(Sheets.Count).name <> "TEMPLATE_LAYOUT" And _
           Sheets(Sheets.Count).name <> "steuertabelle" And _
           Sheets(Sheets.Count).name <> "INFOS und Legende" Then

               Sheets(Sheets.Count).Delete

        End If

    Loop

    Application.DisplayAlerts = True

    MsgBox "Alle generierten Tabellenblaetter wurden geloescht. Dieser Vorgang kann nicht rueckgaengig gemacht werden! (--> falls Falsch ginge ggf. schliessen ohne speichern, sofern alle relevanten Modifikationen vorab gespeichert wurden...)", vbOK, getProjectTitle()

End Sub

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- -------------------------------------------------- -->
<!-- SECTION-START : FUNCTIONS -->
<!-- -------------------------------------------------- -->

<p><a name="sec_functions"></a></p>
<h2>Functions</h2>
<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="addSeitenformat"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Function addSeitenformat</code></span><small>(Zeile 964)</small></p>
<div style="padding-left:2em;">

>  Erstellt ein Objekt des Typs Seitenformat und initialisiert die Konstanten Werte sowie zusaetzlich berechnete.
 Berechnet alle Attribute, das Obj wird zurück gegeben, auf Grundlage von diesem kann ein neues Blatt genereiert werden.




<details>

<summary> Referenzierungen dieser Prozedur (1)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```notengriffeErzeugen```](#notengriffeErzeugen) : <small>  Zeile 1183 : ```        oSeite = addSeitenformat(startzeileSteuertabelle)``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Function addSeitenformat(startzeileSteuertabelle As Integer) As Seitenformat
' Erstellt ein Objekt des Typs Seitenformat und initialisiert die Konstanten Werte sowie zusaetzlich berechnete.
' Berechnet alle Attribute, das Obj wird zurück gegeben, auf Grundlage von diesem kann ein neues Blatt genereiert werden.

    ' Iniitalisiere ein neues Seitenformat-Objekt:
    Dim oFormat As Seitenformat
    oFormat = newSeitenformat()





    ' Berechnen der tataechlich moeglichen Anzahl an Eintragungen auf die Seite - in Abhaengigkeit der ausstehenden Anzahl der in Steuertabelle verfuehgbaren Inputs:
    oFormat.maxAnzahlEintraege = oFormat.maxAnzahlZeilen * oFormat.maxAnzahlSpalten

    Dim letzteZeileSteuertabelle As Integer
    letzteZeileSteuertabelle = identifyLastRow(startzeileSteuertabelle, oFormat.maxAnzahlEintraege)


    ' Berechnnung der Zeilen pro verfuegbaren Blattbereich:
    oFormat.anzahlEintraege = letzteZeileSteuertabelle - startzeileSteuertabelle + 1

    ' Aufteilen der Eintraege auf die verfuegbaren Blattbereiche (Spalten:) - immer AUFGERUNDET auf naechste Ganzzahl (sodass die letzte Spalte nie mehr Zeilen als die erste Spalte hat)
    Dim tempAnzahlZeilen As Double

    tempAnzahlZeilen = oFormat.anzahlEintraege / oFormat.anzahlSpalten
    'oFormat.anzahlZeilen = oFormat.anzahlEintraege / oFormat.anzahlSpalten
    If tempAnzahlZeilen <> Int(tempAnzahlZeilen) Then
        tempAnzahlZeilen = Int(tempAnzahlZeilen) + 1
    End If

    If tempAnzahlZeilen > oFormat.maxAnzahlZeilen Then
        tempAnzahlZeilen = tempAnzahlZeilen - 1
    End If

    oFormat.anzahlZeilen = tempAnzahlZeilen

    addSeitenformat = oFormat


End Function

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="areaEmpty"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Function areaEmpty</code></span><small>(Zeile 800)</small></p>
<div style="padding-left:2em;">

>  Prueft einen Bereich auf leere Zellen.
 Rueckgabewerte:
 True falls ALLE Zellen im Bereich leer sind
 False falls NICHT ALLE ZEllen leer sind




<details>

<summary> Referenzierungen dieser Prozedur (1)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```identifyLastRow```](#identifyLastRow) : <small>  Zeile 882 : ```        If Not areaEmpty(wsTodo, zeile, tempObj.excelStartSpaltenNr, zeile, tempObj.excelStartSpaltenNr + tempObj.anzahlSubSpaltenProSpalte - 1) Then``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Function areaEmpty(ws As Worksheet, lineFrom As Integer, columnFrom As Integer, lineTo As Integer, columnTo As Integer)
    ' Prueft einen Bereich auf leere Zellen.
    ' Rueckgabewerte:
        ' True falls ALLE Zellen im Bereich leer sind
        ' False falls NICHT ALLE ZEllen leer sind

        Dim line As Integer
        Dim column As Integer

        For line = lineFrom To lineTo

            For column = columnFrom To columnTo

                If ws.Cells(line, column) <> "" Then

                    ' Funktion beenden mit False:
                    areaEmpty = False
                    Exit Function

                End If

            Next column

        Next line

        areaEmpty = True

    End Function

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="existsSheetname"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Function existsSheetname</code></span><small>(Zeile 300)</small></p>
<div style="padding-left:2em;">

> *No information availible. For more information expand source code.*



<details>

<summary> Referenzierungen dieser Prozedur (1)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```insertSheet```](#insertSheet) : <small>  Zeile 283 : ```        If existsSheetname(sheetname) = False Then``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Function existsSheetname(name As String) As Boolean

    Dim ws As Worksheet
    For Each ws In Sheets
        If ws.name = name Then

            existsSheetname = True
            Exit Function

        End If

    Next ws

    existsSheetname = False

End Function

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="getCountsOfColumnsToPrint"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Public Function getCountsOfColumnsToPrint</code></span><small>(Zeile 235)</small></p>
<div style="padding-left:2em;">

>  Berechnet die tatsaechliche Anzahl der zu druckenden Spalten
 Dafuer wird die letzte Spalte abgezogen, weil wg. Blattrand keine zusaetzliche Luft erforderlich ist:




<details>

<summary> Referenzierungen dieser Prozedur (2)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```applyLayoutToSinglePage```](#applyLayoutToSinglePage) : <small>  Zeile 179 : ```    anzahlColumnsToMerge = getCountsOfColumnsToPrint(oSeite)``` </small>
* [```applyLayoutPrintArea```](#applyLayoutPrintArea) : <small>  Zeile 254 : ```    anzahlColumnsToPrint = getCountsOfColumnsToPrint(oSeite)``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Function getCountsOfColumnsToPrint(oSeite As Seitenformat) As Integer
    ' Berechnet die tatsaechliche Anzahl der zu druckenden Spalten
    ' Dafuer wird die letzte Spalte abgezogen, weil wg. Blattrand keine zusaetzliche Luft erforderlich ist:

    getCountsOfColumnsToPrint = oSeite.anzahlSpalten * oSeite.anzahlSubSpaltenProSpalte - 1

End Function

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="getFilePath"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Function getFilePath</code></span><small>(Zeile 338)</small></p>
<div style="padding-left:2em;">

>  Generiert einen Path zur Bilddatei basierend auf einem Stichwort.
 Sofern es keine passende Datei gibt, wird ein Platzhalter-Bild referenziert, durch das ein FEHLER verdeutlcihet wird.




<details>

<summary> Referenzierungen dieser Prozedur (2)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```getFilePath```](#getFilePath) : <small>  Zeile 366 : ```    getFilePath = getFilePath(ERROR_FILENAME)``` </small>
* [```konvertiereZeile```](#konvertiereZeile) : <small>  Zeile 742 : ```                pathImage = getFilePath(oReplacer.value)``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Function getFilePath(stichwort As String)
    ' Generiert einen Path zur Bilddatei basierend auf einem Stichwort.
    ' Sofern es keine passende Datei gibt, wird ein Platzhalter-Bild referenziert, durch das ein FEHLER verdeutlcihet wird.

    Dim folderPath As String
    Dim imagePath As String
    Dim ERROR_FILENAME As String


    ' Einlesen des PFades aus der TodoTanbellenblattes:
    folderPath = wsTodo.Cells(2, 3)

    ' DEFAULT-Bildname:
    ERROR_FILENAME = "ERROR"

    ' Zusammenbau des Datepfades (als png-Dateien, da svg bei Franziska nicht funktionierte - bei mir schon):
    imagePath = folderPath & stichwort & ".png"

    ' Fehlervermeidung: Pruefe ob Datei existiert:
    If Dir(imagePath) <> "" Then

        ' Datei existiert.
        getFilePath = imagePath
        Exit Function
    End If


    ' Alternativ: Fehler-Bild default nehmen (rekursiv):
    getFilePath = getFilePath(ERROR_FILENAME)

End Function

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="getModifiedKeyIfTaktwechsel"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Function getModifiedKeyIfTaktwechsel</code></span><small>(Zeile 622)</small></p>
<div style="padding-left:2em;">

>  Prueft, ob das Stichwort einem Taktartwechsel entspricht.
 Dazu werden konkrete Stichworte geprueftund durch ein alternativ-stichwort fuer einen Dateinamen ersetzt zurueckgegeben.




<details>

<summary> Referenzierungen dieser Prozedur (0)</summary>

<div style="padding-left:1em;">



Kein Aufruf gefunden.







</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Function getModifiedKeyIfTaktwechsel(stichwort As String) As String
    ' Prueft, ob das Stichwort einem Taktartwechsel entspricht.
    ' Dazu werden konkrete Stichworte geprueftund durch ein alternativ-stichwort fuer einen Dateinamen ersetzt zurueckgegeben.

    getModifiedKeyIfTaktwechsel = "!" 'default initial:

    Dim keysAndReplacers() As Variant
    ' Aufbau des Arrays: ("Key1", "ersatzString1, "key2", "ersatz2", ...)
    keysAndReplacers = Array("TC|", "allabreve", _
    "T3/4", "T3-4", _
        "T4/4", "T4-4", _
        "T6/8", "T6-8", _
        "T3/8", "T3-8", _
    "TC", "TC")

    Dim i As Integer
    For i = LBound(keysAndReplacers) To UBound(keysAndReplacers)
        '# TODO: Eig. muesste hier step 2 noch rein! (pruefe nur die WErte mit ungeradem Index...)
        If stichwort = keysAndReplacers(i) Then
            ' Gebe den ERsatzwert fuer diesen KEy zurueck:
            getModifiedKeyIfTaktwechsel = keysAndReplacers(i + 1)
            Exit Function
        End If

    Next i

End Function

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="getProjectTitle"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Public Function getProjectTitle</code></span><small>(Zeile 79)</small></p>
<div style="padding-left:2em;">

> *No information availible. For more information expand source code.*



<details>

<summary> Referenzierungen dieser Prozedur (1)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```resetWorkbook```](#resetWorkbook) : <small>  Zeile 111 : ```    MsgBox "Alle generierten Tabellenblaetter wurden geloescht. Dieser Vorgang kann nicht rueckgaengig gemacht werden! (--> falls Falsch ginge ggf. schliessen ohne speichern, sofern alle relevanten Modifikationen vorab gespeichert wurden...)", vbOK, getProjectTitle()``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Function getProjectTitle() As String

    getProjectTitle = "Notengriff-Converter"

End Function

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="getReplacerCount"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Function getReplacerCount</code></span><small>(Zeile 482)</small></p>
<div style="padding-left:2em;">

>  Prueft das Stichwort fuer diese spezielle Spalte/ das Attribut und gibt darauf basierend eine ZEichenkette als Replacer zurueck. Diese Zeichenkette entspricht entweder dem Stichwort (Text uebernehmen) oder dem Dateipfad zu einem Bilddatei.




<details>

<summary> Referenzierungen dieser Prozedur (1)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```konvertiereZeile```](#konvertiereZeile) : <small>  Zeile 729 : ```                    oReplacer = getReplacerCount(stichwort)``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Function getReplacerCount(stichwort As String) As Replacer
    ' Prueft das Stichwort fuer diese spezielle Spalte/ das Attribut und gibt darauf basierend eine ZEichenkette als Replacer zurueck. Diese Zeichenkette entspricht entweder dem Stichwort (Text uebernehmen) oder dem Dateipfad zu einem Bilddatei.

    Dim oErsatz  As Replacer

    ' Einfaches durchschleusen fuer diese Spalte:

    oErsatz.isImage = False
    oErsatz.value = stichwort
    oErsatz.cellfitTo = "Height"


    getReplacerCount = oErsatz

End Function

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="getReplacerEmpty"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Function getReplacerEmpty</code></span><small>(Zeile 516)</small></p>
<div style="padding-left:2em;">

>  Gibt leeren Replacer zurueck




<details>

<summary> Referenzierungen dieser Prozedur (1)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```konvertiereZeile```](#konvertiereZeile) : <small>  Zeile 733 : ```                    oReplacer = getReplacerEmpty()``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Function getReplacerEmpty() As Replacer
    ' Gibt leeren Replacer zurueck

    Dim oErsatz  As Replacer

    oErsatz.isImage = False
    oErsatz.value = ""
    oErsatz.cellfitTo = "Height"

    getReplacerEmpty = oErsatz

End Function

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="getReplacerNote"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Function getReplacerNote</code></span><small>(Zeile 451)</small></p>
<div style="padding-left:2em;">

>  Prueft das Stichwort fuer diese spezielle Spalte/ das Attribut und gibt darauf basierend eine ZEichenkette als Replacer zurueck. Diese Zeichenkette entspricht entweder dem Stichwort (Text uebernehmen) oder dem Dateipfad zu einem Bilddatei.




<details>

<summary> Referenzierungen dieser Prozedur (1)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```konvertiereZeile```](#konvertiereZeile) : <small>  Zeile 727 : ```                    oReplacer = getReplacerNote(stichwort)``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Function getReplacerNote(stichwort As String) As Replacer
    ' Prueft das Stichwort fuer diese spezielle Spalte/ das Attribut und gibt darauf basierend eine ZEichenkette als Replacer zurueck. Diese Zeichenkette entspricht entweder dem Stichwort (Text uebernehmen) oder dem Dateipfad zu einem Bilddatei.

    Dim oErsatz  As Replacer
    'Dim extensionWithDot As String

    Dim conditionStartsWithUpperCase As Boolean
    Dim conditionEndsWith0 As Boolean

    ' # TODO:  Abhaengig von Gross/Kleinschreibweise wird das stichwort so umgeformt, dass das entsprechende Bild hierzu spaeter heraus gesucht wird
    ' Zuordnung: / fuer einfaches und schnelles Eintragen in Excel werden die Oktaven ergaenzt:
    ' Soll-zuordnung = {"ais" : "ais.png", "Ais" : "Ais1.png", "A0" : "A0.png")
    ' Alg: Sofern Anfangsbuchstabe GROSS ist UND am Ende keine 0 steht handelt es  sich um Toene der Oktav 1, bei der die 1 ergaenzt wird. Andernfalls immer standardmaessiges Durchschleusen des Keys mit Verbindung mit der Dateiendung

    conditionStartsWithUpperCase = Left(stichwort, 1) = UCase(Left(stichwort, 1))
    conditionEndsWith0 = Right(stichwort, 1) = 0

    If conditionStartsWithUpperCase And Not conditionEndsWith0 Then
        stichwort = stichwort & "1"
    End If

    oErsatz.isImage = True
    oErsatz.value = stichwort ' Die Dateierweiterung wird in der MEthode getFilePath angestellt.
    oErsatz.cellfitTo = "Width"

    getReplacerNote = oErsatz

End Function

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="getReplacerPost"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Function getReplacerPost</code></span><small>(Zeile 500)</small></p>
<div style="padding-left:2em;">

>  Prueft das Stichwort fuer diese spezielle Spalte/ das Attribut und gibt darauf basierend eine ZEichenkette als Replacer zurueck. Diese Zeichenkette entspricht entweder dem Stichwort (Text uebernehmen) oder dem Dateipfad zu einem Bilddatei.




<details>

<summary> Referenzierungen dieser Prozedur (1)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```konvertiereZeile```](#konvertiereZeile) : <small>  Zeile 731 : ```                    oReplacer = getReplacerPost(stichwort)``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Function getReplacerPost(stichwort As String) As Replacer
    ' Prueft das Stichwort fuer diese spezielle Spalte/ das Attribut und gibt darauf basierend eine ZEichenkette als Replacer zurueck. Diese Zeichenkette entspricht entweder dem Stichwort (Text uebernehmen) oder dem Dateipfad zu einem Bilddatei.

    Dim oErsatz  As Replacer

    ' Einfaches durchschleusen fuer diese Spalte:
    oErsatz.isImage = False
    oErsatz.value = stichwort

    getReplacerPost = oErsatz
    oErsatz.cellfitTo = "Height"

End Function

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="getReplacerPre1"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Function getReplacerPre1</code></span><small>(Zeile 378)</small></p>
<div style="padding-left:2em;">

>  Prueft das Stichwort fuer diese spezielle Spalte/ das Attribut und gibt darauf basierend eine ZEichenkette als Replacer zurueck. Diese Zeichenkette entspricht entweder dem Stichwort (Text uebernehmen) oder dem Dateipfad zu einem Bilddatei.




<details>

<summary> Referenzierungen dieser Prozedur (2)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```getReplacerPre2```](#getReplacerPre2) : <small>  Zeile 445 : ```    getReplacerPre2 = getReplacerPre1(stichwort)``` </small>
* [```konvertiereZeile```](#konvertiereZeile) : <small>  Zeile 723 : ```                    oReplacer = getReplacerPre1(stichwort)``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Function getReplacerPre1(stichwort As String) As Replacer
    ' Prueft das Stichwort fuer diese spezielle Spalte/ das Attribut und gibt darauf basierend eine ZEichenkette als Replacer zurueck. Diese Zeichenkette entspricht entweder dem Stichwort (Text uebernehmen) oder dem Dateipfad zu einem Bilddatei.

    ' Moegliche Optionen:
    ' - Durchschleusen des Strings
    ' - Wiederholungszeichen (Begin) --> str in TimesNewRoman ODER IMG
    ' - Klammer-Zahl (Wiederholungsklammer) --> str
    ' - Taktart-Wechsel --> IMG
    ' - Paukenschlag --> IMG
    ' [Trennerlinien werden unabhängig davon im Anschluss fuer jede Zeile gesondert geprueft!]

    Dim oErsatz  As Replacer
    ' dim found as Boolean



    ' Default-Init:
    oErsatz.isImage = False
    oErsatz.value = stichwort
    oErsatz.cellfitTo = "Height"
    ' found = False



    ' ' # OBSOLET / ALT: Bis V.1.16
    ' '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' ' Abfragen fuer einzelne Zeichen/Symbole:
    ' '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' ' Pruefe Option: Paukenschlag
    ' If UCase(stichwort) = "X" Then
    '     oErsatz.value = "paukenschlag"
    '     oErsatz.isImage = True



    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Abfragen fuer Gruppen / Kategorien:
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


    ' found = modifyReplacerIfSonderzeichen(oErsatz)
    Call modifyReplacerIfSonderzeichen(oErsatz)
    'Suche Sonderzeichen wie Paukenschlaege, Coda, Signum, ....

    Call modifyReplacerIfTaktwechsel(oErsatz)
    ' if not found then

        ' found = modifyReplacerIfTaktwechsel(oErsatz)
            ' Modifikation des Replacers erfolgte bereits innerhabl der Methode.

    '     ' ' # ALT: Bis V.1.16:
    '     ' ElseIf getModifiedKeyIfTaktwechsel(stichwort) <> "!" Then
    '     '     oErsatz.isImage = True
    '     '     oErsatz.value = getModifiedKeyIfTaktwechsel(stichwort)

    ' End If

    getReplacerPre1 = oErsatz

End Function

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="getReplacerPre2"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Function getReplacerPre2</code></span><small>(Zeile 441)</small></p>
<div style="padding-left:2em;">

>  Prueft das Stichwort fuer diese spezielle Spalte/ das Attribut und gibt darauf basierend eine ZEichenkette als Replacer zurueck. Diese Zeichenkette entspricht entweder dem Stichwort (Text uebernehmen) oder dem Dateipfad zu einem Bilddatei.




<details>

<summary> Referenzierungen dieser Prozedur (1)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```konvertiereZeile```](#konvertiereZeile) : <small>  Zeile 725 : ```                    oReplacer = getReplacerPre2(stichwort)``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Function getReplacerPre2(stichwort As String) As Replacer
    ' Prueft das Stichwort fuer diese spezielle Spalte/ das Attribut und gibt darauf basierend eine ZEichenkette als Replacer zurueck. Diese Zeichenkette entspricht entweder dem Stichwort (Text uebernehmen) oder dem Dateipfad zu einem Bilddatei.

    ' AKTUELL: DIE SELBEN ABFRAGEN WIE BEI PRE1-SPALTE
    getReplacerPre2 = getReplacerPre1(stichwort)

End Function

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="getTypeOfFollowingSeperatorLine"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Function getTypeOfFollowingSeperatorLine</code></span><small>(Zeile 1044)</small></p>
<div style="padding-left:2em;">

>  returns 0 falls kein eLinie folgt
 returns 1 falls durchgezogene Linie folgt
 returns -1 falls gestrichelte Linie folgt.




<details>

<summary> Referenzierungen dieser Prozedur (1)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```konvertiereZeile```](#konvertiereZeile) : <small>  Zeile 757 : ```    followingLineStyle = getTypeOfFollowingSeperatorLine(zeileSteuertabelle, oSeite)``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Function getTypeOfFollowingSeperatorLine(lastRowNumber As Integer, oSeite As Seitenformat) As Integer
' returns 0 falls kein eLinie folgt
' returns 1 falls durchgezogene Linie folgt
' returns -1 falls gestrichelte Linie folgt.

    Dim spalteSteuertabelle As Integer
    Dim value As Variant

    getTypeOfFollowingSeperatorLine = 0 ' Default

    For spalteSteuertabelle = oSeite.excelStartSpaltenNr To oSeite.excelStartSpaltenNr + oSeite.anzahlSubSpaltenProSpalte - 1

        value = UCase(wsTodo.Cells(lastRowNumber + 1, spalteSteuertabelle))
        If value = "LINE" Then

            getTypeOfFollowingSeperatorLine = 1
            Exit Function

        ElseIf value = "LINE--" Then

            getTypeOfFollowingSeperatorLine = -1
            Exit Function

        End If

    Next spalteSteuertabelle


End Function

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="identifyLastRow"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Function identifyLastRow</code></span><small>(Zeile 867)</small></p>
<div style="padding-left:2em;">

>  Liesst die STB ausgehend ab startzeile aus bis dass die Anzahl maxZeilen abgearbeitet wurde. Pro Zeile wird sich die Zeilennummer gemerkt, sofern Inhalt vorhanden ist.
 Ziel davon ist, dass man so erkennt, wenn die letzten n zeilen nur freizeilen sind (um manuell einen seitenumbruch zu generieren), oder ob nur etwas abstand dadurch generiert werden sollte...




<details>

<summary> Referenzierungen dieser Prozedur (1)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```addSeitenformat```](#addSeitenformat) : <small>  Zeile 980 : ```    letzteZeileSteuertabelle = identifyLastRow(startzeileSteuertabelle, oFormat.maxAnzahlEintraege)``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Function identifyLastRow(startzeile As Integer, maxZeilen As Integer) As Integer
    ' Liesst die STB ausgehend ab startzeile aus bis dass die Anzahl maxZeilen abgearbeitet wurde. Pro Zeile wird sich die Zeilennummer gemerkt, sofern Inhalt vorhanden ist.
    ' Ziel davon ist, dass man so erkennt, wenn die letzten n zeilen nur freizeilen sind (um manuell einen seitenumbruch zu generieren), oder ob nur etwas abstand dadurch generiert werden sollte...

    identifyLastRow = -1 ' default-initial

    ' Nur als temporaeres Hilfsobjekt, dmait alle Parameter nicht wiederholt werde muessen:
    Dim zeile As Integer
    Dim tempObj As Seitenformat
    tempObj = newSeitenformat(readParameters:=False)


    For zeile = startzeile To startzeile + maxZeilen


        If Not areaEmpty(wsTodo, zeile, tempObj.excelStartSpaltenNr, zeile, tempObj.excelStartSpaltenNr + tempObj.anzahlSubSpaltenProSpalte - 1) Then

            identifyLastRow = zeile

        End If

    Next zeile

End Function

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="konvertiereZeile"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Function konvertiereZeile</code></span><small>(Zeile 696)</small></p>
<div style="padding-left:2em;">

>  # TODOC: ALT:
 Konvertiert eine Zeile des Todo-Tabellenblattes in eine Zeile des Ergebnis-Tabellenblattes.
 Geht alle Spalten der STB durch und ruft fuer diese Spalte den jeweiligen Getter zum Holen des ReplacerObjektes auf. Die Logik bzgl. der Ersetzung erfolgt in den einzelnen Gettern. Rueckgabewert ist jeweils ein Replacer-Objekt mit den Attributen isImage:bool und value:string
 Die Zielpositionen fuer die Replacer werden aus dem uebergebenen Objekt oSeite gezogen.
 Danach wird dann die eigentliche Ersetzung durchgefuehrt.
 Rueckgabewert: True fuer normale Zeile ,False falls eine zusaetzliche ZEile der STB ueberspringen werden soll (auslassungsstichwort!)




<details>

<summary> Referenzierungen dieser Prozedur (1)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```erstelleKonvertierteSeite```](#erstelleKonvertierteSeite) : <small>  Zeile 677 : ```            If konvertiereZeile(zeileSteuertabelle, oSeite) = False Then``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Function konvertiereZeile(zeileSteuertabelle As Integer, oSeite As Seitenformat) As Boolean
    ' # TODOC: ALT:
    ' Konvertiert eine Zeile des Todo-Tabellenblattes in eine Zeile des Ergebnis-Tabellenblattes.
    ' Geht alle Spalten der STB durch und ruft fuer diese Spalte den jeweiligen Getter zum Holen des ReplacerObjektes auf. Die Logik bzgl. der Ersetzung erfolgt in den einzelnen Gettern. Rueckgabewert ist jeweils ein Replacer-Objekt mit den Attributen isImage:bool und value:string
    ' Die Zielpositionen fuer die Replacer werden aus dem uebergebenen Objekt oSeite gezogen.
    ' Danach wird dann die eigentliche Ersetzung durchgefuehrt.
    ' Rueckgabewert: True fuer normale Zeile ,False falls eine zusaetzliche ZEile der STB ueberspringen werden soll (auslassungsstichwort!)

    Dim spalteSteuertabelle As Integer
    Dim stichwort As String
    Dim pathImage As String
    Dim oReplacer As Replacer
    Dim zielspalte As Integer
    konvertiereZeile = True


    For spalteSteuertabelle = oSeite.excelStartSpaltenNr To oSeite.excelStartSpaltenNr + oSeite.anzahlSubSpaltenProSpalte - 1

        zielspalte = spalteSteuertabelle + oSeite.anzahlSubSpaltenProSpalte * (oSeite.spaltengruppe - 1)
        stichwort = wsTodo.Cells(zeileSteuertabelle, spalteSteuertabelle)


        If stichwort <> "" Then

            Select Case spalteSteuertabelle

                Case 1
                    oReplacer = getReplacerPre1(stichwort)
                Case 2
                    oReplacer = getReplacerPre2(stichwort)
                Case 3
                    oReplacer = getReplacerNote(stichwort)
                Case 4
                    oReplacer = getReplacerCount(stichwort)
                Case 5
                    oReplacer = getReplacerPost(stichwort)
                Case Else ' eigentlich obsolet
                    oReplacer = getReplacerEmpty()

            End Select
            '''''''''''''''''''''''''''''''''''
            ' Eigentliches Ersetzen:
            '''''''''''''''''''''''''''''''''''
            If oReplacer.isImage = True Then
                ' Bild einsetzen:

                pathImage = getFilePath(oReplacer.value)

                Call InsertImageFromFileToCell(oSeite.excelZeilenNr, zielspalte, pathImage, oReplacer.cellFitTo)

            Else
                ' Text uebernehmen:
                wsResult.Cells(oSeite.excelZeilenNr, zielspalte) = oReplacer.value

            End If
        End If

    Next spalteSteuertabelle

    ' Pruefe, ob durch das Stichwort in der folgenden Zeile der STB ein Trennlinie unterhalb der gerade beschriebenen Zeilen eingefuegt wwerden soll:
    Dim followingLineStyle As Integer
    followingLineStyle = getTypeOfFollowingSeperatorLine(zeileSteuertabelle, oSeite)

    If followingLineStyle <> 0 Then

        ' Linienart modifizieren via Uebergabeparameter
        Call insertFrameLineBelow(zeileSteuertabelle, oSeite, CBool(followingLineStyle - 1))
        konvertiereZeile = False
        oSeite.countOfSkippedLinesTodo = oSeite.countOfSkippedLinesTodo + 1
    End If

    Call SeitenformatNextPosition(oSeite)

    ' Anscheinend muss ich oSeite ähnlich wie bei python nicht zurueckuebergeben.... (modulweit / "global"?)

End Function

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<!-- --------------------------------------------------------------- -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- NEUE PROZEDUR-DOKUMENTATION -->
<!-- --------------------------------------------------------------- -->

<p><a name="newSeitenformat"></a>
<span style="background-color: lightgrey; padding: 2px;"><code>Private Function newSeitenformat</code></span><small>(Zeile 896)</small></p>
<div style="padding-left:2em;">

> 
 Standard-Parameter aus TODO-Steuertabelle auslesen und Standardwerte parametrisieren.
 # ACHTUNG: DEPENDENCIES zur Excel-Worksheet!





<details>

<summary> Referenzierungen dieser Prozedur (2)</summary>

<div style="padding-left:1em;">



Die Prozedur wird in den folgenden, uebergeordneten Prozeduren aufgerufen:



* [```identifyLastRow```](#identifyLastRow) : <small>  Zeile 876 : ```    tempObj = newSeitenformat(readParameters:=False)``` </small>
* [```addSeitenformat```](#addSeitenformat) : <small>  Zeile 970 : ```    oFormat = newSeitenformat()``` </small>




</details

</div>











<!-- TODO: ABRUFABFOLGE (DEV) -->


<!-- <div style="padding-left:1em;"> -->


<details>
    <summary>      Interne Aufrufabfolge (@PLACEHOLDER_PROCEDURE_COUNT_OF_ABRUFFOLGE@)</summary>

---


STATIC  - EXEMPLARISCHES ZIEL- OUTPUT für MAIN:

<!-- TODO: Links einfügen! gleiches prinzip wie bei  references!-->


* ```hauptfunc1```
  * ```unterfunktionA```
    * ```wiederholungsfunktion```
  * ```unterfunktionB```
* ```hauptfunc2```
* ```hauptfunc3```
* ```wiederholungsfunktion```
  * ```wiederholungsfunktion```






@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_INTRODUCTION@





@PLACEHOLDER_PROCEDURE_ABRUFFOLGE_ENTRY@


</details>


<!-- </div> -->













<details>
    <summary>      Source Code</summary>

---

```
Private Function newSeitenformat(Optional readParameters As Boolean = True) As Seitenformat
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''
    ' Standard-Parameter aus TODO-Steuertabelle auslesen und Standardwerte parametrisieren.
    ' # ACHTUNG: DEPENDENCIES zur Excel-Worksheet!
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''

    Dim oSeitenformat As Seitenformat

    Dim paramZeilenOffsetAusrichtung As Integer

    oSeitenformat.countOfSkippedLinesTodo = 0 ' Anzahl der uebersprungenen Zeilen innerhalb der Steuertabelle im bereich der fuer diese Seite umgewandelten Zeilen

    oSeitenformat.anzahlSubSpaltenProSpalte = 6 ' Azahl der Subspalten pro Spaltengruppe


    oSeitenformat.zeilengruppe = 1
    oSeitenformat.spaltengruppe = 1

    oSeitenformat.excelStartZeilenNr = 5 ' Excel-Zeilennummer, auf der die Seite den ersten Eintrag haben soll
    oSeitenformat.excelStartSpaltenNr = 1 ' Excel-Spaltennummer, auf der die Seite den ersten Eintrag haben soll


    oSeitenformat.excelZeilenNr = oSeitenformat.excelStartZeilenNr ' Tatsaechliche Zielzeilennummer
    oSeitenformat.excelSpaltenNr = oSeitenformat.excelStartSpaltenNr ' Tatsaechliche Zielspaltennummer

    oSeitenformat.finished = False

    If readParameters = False Then
        ' Vorzeitiges Verlassen der Funktion. Damit habe ich trotzdem duplizierten Code vermieden (hardcodierte parameter)
        newSeitenformat = oSeitenformat
        Exit Function

    End If


    '''''''''''''''''''''''''''''''''''''''''''''''
    ' AUSLESEN DER PARAMETER AUS DER STEUERTABELLE:
    '''''''''''''''''''''''''''''''''''''''''''''''
    Dim paramSpalte As Integer
    paramSpalte = 6 ' Spaltennummer der Steuertabelle, in der die Parameterwerte stehen


    oSeitenformat.titel = wsTodo.Cells(6, paramSpalte)
    oSeitenformat.zusatztext = wsTodo.Cells(7, paramSpalte)
    oSeitenformat.blattname = wsTodo.Cells(8, paramSpalte)
    oSeitenformat.ausrichtung = wsTodo.Cells(9, paramSpalte)

    ' Max. Zeilen- und Spaltenanzahl auslesen:
    paramZeilenOffsetAusrichtung = 0
    If oSeitenformat.ausrichtung = "Querformat" Then
        paramZeilenOffsetAusrichtung = 3
    End If

    oSeitenformat.maxAnzahlZeilen = wsTodo.Cells(12 + paramZeilenOffsetAusrichtung, paramSpalte)
    oSeitenformat.maxAnzahlSpalten = wsTodo.Cells(13 + paramZeilenOffsetAusrichtung, paramSpalte)

    ' Limitierend ist immer vorrangig die Spaltenanzahl - d.h. es werden IMMER alle Spalten benutzt, sofern es insgesamt mind. die Anzahl an Eintraegen wie Spalten gibt.
    oSeitenformat.anzahlSpalten = oSeitenformat.maxAnzahlSpalten

    newSeitenformat = oSeitenformat

End Function

```

</details>


</div>

<hr />
<!-- --------------------------------------------------------------- -->

<p>﻿</p>
<hr />
<p><a name="sec_tail"></a></p>
<h2>Schlussbemerkungen</h2>
<!-- 
**Notice:**

*To generate a docstring from the VBA-Source, make sure that the text to shown is located directly below the declaration line of the procedure. The text is considered completed with the first following line in the code which is not an entire comment line.  Empty lines that are to be included must also be labelled as comments.*



 **TODO:** Erstellt am (Datum) durch das  automatisierte Code-Dokumentationstool von .... in der Version ....







---



**ODER:** -->

<blockquote>
<p>Diese Dokumentation wurde automatisch generiert durch ein Programm, welches sich noch im Entwicklungsstadium befindet. Im folgenden werden die Modulinformationen des PYTHON-SCRIPTES aufgeführt, durch welches diese Dokumentation generiert wurde.</p>
</blockquote>
<details>

<summary> Modulinformationen anzeigen/verbergen.
</summary>

  @
Created on: Fri, 2023-12-29 (00:45:39)

@author: Matthias Kader


Für Ziel und Ablauf des Scriptes siehe MArkdown im Verzeichnis ../Tests/Programmablauf.html




### Fertig implementiert:

• Implementierung Inhaltsverzeichnis / Index

• Gesamtlayout inkl. Titel, Zwischenüberschriften für einzelne Sections

• Einbindung vom Programmkopf-Docstring

• Implementierung von References-Durchsuchungen

• Implementierung eines Exportes zu HTML


### TODO: Größere TODOS:

• Einbindung organisatorischer Daten bzgl. des zu dokumentierenden Codes und des verwendeten Skripts zum Dokumentieren




### AUSBLICK für später und in schön:

• Index an der Seite wie eine NavBar zum einzelnd scrollen



• Call Sequenz / Calling Sequence:
Schön (Ausblick) wäre auch ein weiterer Unterpunkt pro Prozedur, in der die Aufrufabfolge hervorgeht.
Idee ist etwas wie die Aufrufebenen-Auflistung beim Noten-Converter-Programm, d.h. ausgehend von einer Prozedur soll eine Liste stehen der Aufrufe von weiteren Prozeduren die aufgerufen werden (und die in diesem Dokument auch dokumentiert werden... also keine Builtins o.ä.). Im Idealfall kann jeder Punkt dieser Liste wiederum erweitert/expanded werden, darin ist dann wiederum die Liste von DIESER AUFGERUFENEN Funktion drin usw... Rekursiv. Jede Methode, die einmal so dokumentiert wurde kann weiter verwendet werden per Direktzugriff....


@

</details>

<p><small></p>
<p><strong>Notice:</strong></p>
<p><em>To generate a docstring from the VBA-Source make sure that the text to shown is located directly below the declaration line of the procedure. The text is considered completed with the first following line in the code which is not an entire comment line.  Empty lines that are to be included must also be labelled as comments.</em></p>
<p></small> </p>
<p><small> <strong>TODO:</strong> Erstellt am (Datum) durch das  automatisierte Code-Dokumentationstool von .... in der Version ....</small> </p>